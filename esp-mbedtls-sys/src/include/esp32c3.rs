/* automatically generated by rust-bindgen 0.68.1 */

#![allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    dead_code
)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const MBEDTLS_CONFIG_FILE: &[u8; 9] = b"config.h\0";
pub const MBEDTLS_SSL_DTLS_CONNECTION_ID_COMPAT: u32 = 0;
pub const MBEDTLS_SSL_MAX_EARLY_DATA_SIZE: u32 = 1024;
pub const MBEDTLS_SSL_TLS1_3_TICKET_AGE_TOLERANCE: u32 = 6000;
pub const MBEDTLS_SSL_TLS1_3_TICKET_NONCE_LENGTH: u32 = 32;
pub const MBEDTLS_SSL_TLS1_3_DEFAULT_NEW_SESSION_TICKETS: u32 = 1;
pub const MBEDTLS_VERSION_MAJOR: u32 = 3;
pub const MBEDTLS_VERSION_MINOR: u32 = 4;
pub const MBEDTLS_VERSION_PATCH: u32 = 0;
pub const MBEDTLS_VERSION_NUMBER: u32 = 50593792;
pub const MBEDTLS_VERSION_STRING: &[u8; 6] = b"3.4.0\0";
pub const MBEDTLS_VERSION_STRING_FULL: &[u8; 15] = b"mbed TLS 3.4.0\0";
pub const MBEDTLS_PSA_BUILTIN_ALG_CCM: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CCM_STAR_NO_TAG: u32 = 1;
pub const PSA_WANT_ALG_CCM: u32 = 1;
pub const PSA_WANT_ALG_CCM_STAR_NO_TAG: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CMAC: u32 = 1;
pub const PSA_WANT_ALG_CMAC: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_ECDH: u32 = 1;
pub const PSA_WANT_ALG_ECDH: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_ECDSA: u32 = 1;
pub const PSA_WANT_ALG_ECDSA: u32 = 1;
pub const PSA_WANT_ALG_ECDSA_ANY: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA: u32 = 1;
pub const PSA_WANT_ALG_DETERMINISTIC_ECDSA: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_KEY_PAIR: u32 = 1;
pub const PSA_WANT_KEY_TYPE_ECC_KEY_PAIR: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_PUBLIC_KEY: u32 = 1;
pub const PSA_WANT_KEY_TYPE_ECC_PUBLIC_KEY: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_GCM: u32 = 1;
pub const PSA_WANT_ALG_GCM: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_HMAC: u32 = 1;
pub const PSA_WANT_ALG_HMAC: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_HKDF: u32 = 1;
pub const PSA_WANT_ALG_HKDF: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_HKDF_EXTRACT: u32 = 1;
pub const PSA_WANT_ALG_HKDF_EXTRACT: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_HKDF_EXPAND: u32 = 1;
pub const PSA_WANT_ALG_HKDF_EXPAND: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_TLS12_PRF: u32 = 1;
pub const PSA_WANT_ALG_TLS12_PRF: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_TLS12_PSK_TO_MS: u32 = 1;
pub const PSA_WANT_ALG_TLS12_PSK_TO_MS: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_MD5: u32 = 1;
pub const PSA_WANT_ALG_MD5: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_PAKE: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_JPAKE: u32 = 1;
pub const PSA_WANT_ALG_JPAKE: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_RIPEMD160: u32 = 1;
pub const PSA_WANT_ALG_RIPEMD160: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_RSA_PKCS1V15_CRYPT: u32 = 1;
pub const PSA_WANT_ALG_RSA_PKCS1V15_CRYPT: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_RSA_PKCS1V15_SIGN: u32 = 1;
pub const PSA_WANT_ALG_RSA_PKCS1V15_SIGN: u32 = 1;
pub const PSA_WANT_ALG_RSA_PKCS1V15_SIGN_RAW: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_RSA_OAEP: u32 = 1;
pub const PSA_WANT_ALG_RSA_OAEP: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_RSA_PSS: u32 = 1;
pub const PSA_WANT_ALG_RSA_PSS: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR: u32 = 1;
pub const PSA_WANT_KEY_TYPE_RSA_KEY_PAIR: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_PUBLIC_KEY: u32 = 1;
pub const PSA_WANT_KEY_TYPE_RSA_PUBLIC_KEY: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA_1: u32 = 1;
pub const PSA_WANT_ALG_SHA_1: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA_224: u32 = 1;
pub const PSA_WANT_ALG_SHA_224: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA_256: u32 = 1;
pub const PSA_WANT_ALG_SHA_256: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA_384: u32 = 1;
pub const PSA_WANT_ALG_SHA_384: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA_512: u32 = 1;
pub const PSA_WANT_ALG_SHA_512: u32 = 1;
pub const PSA_WANT_KEY_TYPE_AES: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_AES: u32 = 1;
pub const PSA_WANT_KEY_TYPE_ARIA: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_ARIA: u32 = 1;
pub const PSA_WANT_KEY_TYPE_CAMELLIA: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_CAMELLIA: u32 = 1;
pub const PSA_WANT_KEY_TYPE_DES: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_DES: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_TLS12_ECJPAKE_TO_PMS: u32 = 1;
pub const PSA_WANT_ALG_TLS12_ECJPAKE_TO_PMS: u32 = 1;
pub const PSA_WANT_KEY_TYPE_CHACHA20: u32 = 1;
pub const PSA_WANT_ALG_STREAM_CIPHER: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_CHACHA20: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_STREAM_CIPHER: u32 = 1;
pub const PSA_WANT_ALG_CHACHA20_POLY1305: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CHACHA20_POLY1305: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CBC_NO_PADDING: u32 = 1;
pub const PSA_WANT_ALG_CBC_NO_PADDING: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CBC_PKCS7: u32 = 1;
pub const PSA_WANT_ALG_CBC_PKCS7: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_ECB_NO_PADDING: u32 = 1;
pub const PSA_WANT_ALG_ECB_NO_PADDING: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CFB: u32 = 1;
pub const PSA_WANT_ALG_CFB: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CTR: u32 = 1;
pub const PSA_WANT_ALG_CTR: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_OFB: u32 = 1;
pub const PSA_WANT_ALG_OFB: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_BRAINPOOL_P_R1_256: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_BRAINPOOL_P_R1_384: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_BRAINPOOL_P_R1_512: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_MONTGOMERY_255: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_MONTGOMERY_448: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_R1_192: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_R1_224: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_R1_256: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_R1_384: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_R1_521: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_K1_192: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_K1_256: u32 = 1;
pub const PSA_HAVE_FULL_ECDSA: u32 = 1;
pub const PSA_HAVE_FULL_JPAKE: u32 = 1;
pub const PSA_WANT_KEY_TYPE_DERIVE: u32 = 1;
pub const PSA_WANT_KEY_TYPE_PASSWORD: u32 = 1;
pub const PSA_WANT_KEY_TYPE_PASSWORD_HASH: u32 = 1;
pub const PSA_WANT_KEY_TYPE_RAW_DATA: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const __NEWLIB_H__: u32 = 1;
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6] = b"3.3.0\0";
pub const __NEWLIB__: u32 = 3;
pub const __NEWLIB_MINOR__: u32 = 3;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_IO_POS_ARGS: u32 = 1;
pub const _WANT_REENT_SMALL: u32 = 1;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _MB_LEN_MAX: u32 = 1;
pub const _ICONV_ENABLED: u32 = 1;
pub const HAVE_INITFINI_ARRAY: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _RETARGETABLE_LOCKING: u32 = 1;
pub const _WANT_USE_LONG_TIME_T: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const _POSIX_THREADS: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 1;
pub const _POSIX_TIMERS: u32 = 1;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200112;
pub const _POSIX_CLOCK_SELECTION: u32 = 200112;
pub const _UNIX98_THREAD_MUTEX_ATTRIBUTES: u32 = 1;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const ARG_MAX: u32 = 4096;
pub const CHILD_MAX: u32 = 40;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const OPEN_MAX: u32 = 64;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const IOV_MAX: u32 = 1024;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 0;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const MB_LEN_MAX: u32 = 1;
pub const NL_ARGMAX: u32 = 32;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const CHAR_MIN: u32 = 0;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3] = b"hh\0";
pub const __INT16: &[u8; 2] = b"h\0";
pub const __INT64: &[u8; 3] = b"ll\0";
pub const __FAST8: &[u8; 3] = b"hh\0";
pub const __FAST16: &[u8; 2] = b"h\0";
pub const __FAST64: &[u8; 3] = b"ll\0";
pub const __LEAST8: &[u8; 3] = b"hh\0";
pub const __LEAST16: &[u8; 2] = b"h\0";
pub const __LEAST64: &[u8; 3] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const MBEDTLS_ERR_MPI_FILE_IO_ERROR: i32 = -2;
pub const MBEDTLS_ERR_MPI_BAD_INPUT_DATA: i32 = -4;
pub const MBEDTLS_ERR_MPI_INVALID_CHARACTER: i32 = -6;
pub const MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL: i32 = -8;
pub const MBEDTLS_ERR_MPI_NEGATIVE_VALUE: i32 = -10;
pub const MBEDTLS_ERR_MPI_DIVISION_BY_ZERO: i32 = -12;
pub const MBEDTLS_ERR_MPI_NOT_ACCEPTABLE: i32 = -14;
pub const MBEDTLS_ERR_MPI_ALLOC_FAILED: i32 = -16;
pub const MBEDTLS_MPI_MAX_LIMBS: u32 = 10000;
pub const MBEDTLS_MPI_WINDOW_SIZE: u32 = 2;
pub const MBEDTLS_MPI_MAX_SIZE: u32 = 1024;
pub const MBEDTLS_MPI_MAX_BITS: u32 = 8192;
pub const MBEDTLS_MPI_MAX_BITS_SCALE100: u32 = 819200;
pub const MBEDTLS_LN_2_DIV_LN_10_SCALE100: u32 = 332;
pub const MBEDTLS_MPI_RW_BUFFER_SIZE: u32 = 2484;
pub const MBEDTLS_ERR_ECP_BAD_INPUT_DATA: i32 = -20352;
pub const MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL: i32 = -20224;
pub const MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE: i32 = -20096;
pub const MBEDTLS_ERR_ECP_VERIFY_FAILED: i32 = -19968;
pub const MBEDTLS_ERR_ECP_ALLOC_FAILED: i32 = -19840;
pub const MBEDTLS_ERR_ECP_RANDOM_FAILED: i32 = -19712;
pub const MBEDTLS_ERR_ECP_INVALID_KEY: i32 = -19584;
pub const MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH: i32 = -19456;
pub const MBEDTLS_ERR_ECP_IN_PROGRESS: i32 = -19200;
pub const MBEDTLS_ECP_DP_MAX: u32 = 14;
pub const MBEDTLS_ECP_WINDOW_SIZE: u32 = 4;
pub const MBEDTLS_ECP_FIXED_POINT_OPTIM: u32 = 1;
pub const MBEDTLS_ECP_MAX_BITS: u32 = 521;
pub const MBEDTLS_ECP_MAX_BYTES: u32 = 66;
pub const MBEDTLS_ECP_MAX_PT_LEN: u32 = 133;
pub const MBEDTLS_ECP_PF_UNCOMPRESSED: u32 = 0;
pub const MBEDTLS_ECP_PF_COMPRESSED: u32 = 1;
pub const MBEDTLS_ECP_TLS_NAMED_CURVE: u32 = 3;
pub const MBEDTLS_ERR_MD_FEATURE_UNAVAILABLE: i32 = -20608;
pub const MBEDTLS_ERR_MD_BAD_INPUT_DATA: i32 = -20736;
pub const MBEDTLS_ERR_MD_ALLOC_FAILED: i32 = -20864;
pub const MBEDTLS_ERR_MD_FILE_IO_ERROR: i32 = -20992;
pub const MBEDTLS_MD_MAX_SIZE: u32 = 64;
pub const MBEDTLS_MD_MAX_BLOCK_SIZE: u32 = 128;
pub const MBEDTLS_ERR_RSA_BAD_INPUT_DATA: i32 = -16512;
pub const MBEDTLS_ERR_RSA_INVALID_PADDING: i32 = -16640;
pub const MBEDTLS_ERR_RSA_KEY_GEN_FAILED: i32 = -16768;
pub const MBEDTLS_ERR_RSA_KEY_CHECK_FAILED: i32 = -16896;
pub const MBEDTLS_ERR_RSA_PUBLIC_FAILED: i32 = -17024;
pub const MBEDTLS_ERR_RSA_PRIVATE_FAILED: i32 = -17152;
pub const MBEDTLS_ERR_RSA_VERIFY_FAILED: i32 = -17280;
pub const MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE: i32 = -17408;
pub const MBEDTLS_ERR_RSA_RNG_FAILED: i32 = -17536;
pub const MBEDTLS_RSA_PKCS_V15: u32 = 0;
pub const MBEDTLS_RSA_PKCS_V21: u32 = 1;
pub const MBEDTLS_RSA_SIGN: u32 = 1;
pub const MBEDTLS_RSA_CRYPT: u32 = 2;
pub const MBEDTLS_RSA_SALT_LEN_ANY: i32 = -1;
pub const MBEDTLS_ERR_PK_ALLOC_FAILED: i32 = -16256;
pub const MBEDTLS_ERR_PK_TYPE_MISMATCH: i32 = -16128;
pub const MBEDTLS_ERR_PK_BAD_INPUT_DATA: i32 = -16000;
pub const MBEDTLS_ERR_PK_FILE_IO_ERROR: i32 = -15872;
pub const MBEDTLS_ERR_PK_KEY_INVALID_VERSION: i32 = -15744;
pub const MBEDTLS_ERR_PK_KEY_INVALID_FORMAT: i32 = -15616;
pub const MBEDTLS_ERR_PK_UNKNOWN_PK_ALG: i32 = -15488;
pub const MBEDTLS_ERR_PK_PASSWORD_REQUIRED: i32 = -15360;
pub const MBEDTLS_ERR_PK_PASSWORD_MISMATCH: i32 = -15232;
pub const MBEDTLS_ERR_PK_INVALID_PUBKEY: i32 = -15104;
pub const MBEDTLS_ERR_PK_INVALID_ALG: i32 = -14976;
pub const MBEDTLS_ERR_PK_UNKNOWN_NAMED_CURVE: i32 = -14848;
pub const MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE: i32 = -14720;
pub const MBEDTLS_ERR_PK_SIG_LEN_MISMATCH: i32 = -14592;
pub const MBEDTLS_ERR_PK_BUFFER_TOO_SMALL: i32 = -14464;
pub const MBEDTLS_PK_SIGNATURE_MAX_SIZE: u32 = 0;
pub const MBEDTLS_PK_DEBUG_MAX_ITEMS: u32 = 3;
pub const MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE: i32 = -24704;
pub const MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA: i32 = -24832;
pub const MBEDTLS_ERR_CIPHER_ALLOC_FAILED: i32 = -24960;
pub const MBEDTLS_ERR_CIPHER_INVALID_PADDING: i32 = -25088;
pub const MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED: i32 = -25216;
pub const MBEDTLS_ERR_CIPHER_AUTH_FAILED: i32 = -25344;
pub const MBEDTLS_ERR_CIPHER_INVALID_CONTEXT: i32 = -25472;
pub const MBEDTLS_CIPHER_VARIABLE_IV_LEN: u32 = 1;
pub const MBEDTLS_CIPHER_VARIABLE_KEY_LEN: u32 = 2;
pub const MBEDTLS_MAX_IV_LENGTH: u32 = 16;
pub const MBEDTLS_MAX_BLOCK_LENGTH: u32 = 16;
pub const MBEDTLS_MAX_KEY_LENGTH: u32 = 64;
pub const MBEDTLS_TLS_RSA_WITH_NULL_MD5: u32 = 1;
pub const MBEDTLS_TLS_RSA_WITH_NULL_SHA: u32 = 2;
pub const MBEDTLS_TLS_PSK_WITH_NULL_SHA: u32 = 44;
pub const MBEDTLS_TLS_DHE_PSK_WITH_NULL_SHA: u32 = 45;
pub const MBEDTLS_TLS_RSA_PSK_WITH_NULL_SHA: u32 = 46;
pub const MBEDTLS_TLS_RSA_WITH_AES_128_CBC_SHA: u32 = 47;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA: u32 = 51;
pub const MBEDTLS_TLS_RSA_WITH_AES_256_CBC_SHA: u32 = 53;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA: u32 = 57;
pub const MBEDTLS_TLS_RSA_WITH_NULL_SHA256: u32 = 59;
pub const MBEDTLS_TLS_RSA_WITH_AES_128_CBC_SHA256: u32 = 60;
pub const MBEDTLS_TLS_RSA_WITH_AES_256_CBC_SHA256: u32 = 61;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA: u32 = 65;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA: u32 = 69;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256: u32 = 103;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256: u32 = 107;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA: u32 = 132;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA: u32 = 136;
pub const MBEDTLS_TLS_PSK_WITH_AES_128_CBC_SHA: u32 = 140;
pub const MBEDTLS_TLS_PSK_WITH_AES_256_CBC_SHA: u32 = 141;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CBC_SHA: u32 = 144;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CBC_SHA: u32 = 145;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_128_CBC_SHA: u32 = 148;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_256_CBC_SHA: u32 = 149;
pub const MBEDTLS_TLS_RSA_WITH_AES_128_GCM_SHA256: u32 = 156;
pub const MBEDTLS_TLS_RSA_WITH_AES_256_GCM_SHA384: u32 = 157;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256: u32 = 158;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384: u32 = 159;
pub const MBEDTLS_TLS_PSK_WITH_AES_128_GCM_SHA256: u32 = 168;
pub const MBEDTLS_TLS_PSK_WITH_AES_256_GCM_SHA384: u32 = 169;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_128_GCM_SHA256: u32 = 170;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_256_GCM_SHA384: u32 = 171;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256: u32 = 172;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384: u32 = 173;
pub const MBEDTLS_TLS_PSK_WITH_AES_128_CBC_SHA256: u32 = 174;
pub const MBEDTLS_TLS_PSK_WITH_AES_256_CBC_SHA384: u32 = 175;
pub const MBEDTLS_TLS_PSK_WITH_NULL_SHA256: u32 = 176;
pub const MBEDTLS_TLS_PSK_WITH_NULL_SHA384: u32 = 177;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256: u32 = 178;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384: u32 = 179;
pub const MBEDTLS_TLS_DHE_PSK_WITH_NULL_SHA256: u32 = 180;
pub const MBEDTLS_TLS_DHE_PSK_WITH_NULL_SHA384: u32 = 181;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256: u32 = 182;
pub const MBEDTLS_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384: u32 = 183;
pub const MBEDTLS_TLS_RSA_PSK_WITH_NULL_SHA256: u32 = 184;
pub const MBEDTLS_TLS_RSA_PSK_WITH_NULL_SHA384: u32 = 185;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 186;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 190;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256: u32 = 192;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256: u32 = 196;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_NULL_SHA: u32 = 49153;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA: u32 = 49156;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA: u32 = 49157;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_NULL_SHA: u32 = 49158;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA: u32 = 49161;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA: u32 = 49162;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_NULL_SHA: u32 = 49163;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA: u32 = 49166;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA: u32 = 49167;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_NULL_SHA: u32 = 49168;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA: u32 = 49171;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA: u32 = 49172;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256: u32 = 49187;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384: u32 = 49188;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256: u32 = 49189;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384: u32 = 49190;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256: u32 = 49191;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384: u32 = 49192;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256: u32 = 49193;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384: u32 = 49194;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: u32 = 49195;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384: u32 = 49196;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256: u32 = 49197;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384: u32 = 49198;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256: u32 = 49199;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384: u32 = 49200;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256: u32 = 49201;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384: u32 = 49202;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA: u32 = 49205;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA: u32 = 49206;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256: u32 = 49207;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384: u32 = 49208;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_NULL_SHA: u32 = 49209;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_NULL_SHA256: u32 = 49210;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_NULL_SHA384: u32 = 49211;
pub const MBEDTLS_TLS_RSA_WITH_ARIA_128_CBC_SHA256: u32 = 49212;
pub const MBEDTLS_TLS_RSA_WITH_ARIA_256_CBC_SHA384: u32 = 49213;
pub const MBEDTLS_TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256: u32 = 49220;
pub const MBEDTLS_TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384: u32 = 49221;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256: u32 = 49224;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384: u32 = 49225;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256: u32 = 49226;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384: u32 = 49227;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256: u32 = 49228;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384: u32 = 49229;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256: u32 = 49230;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384: u32 = 49231;
pub const MBEDTLS_TLS_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 49232;
pub const MBEDTLS_TLS_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 49233;
pub const MBEDTLS_TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 49234;
pub const MBEDTLS_TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 49235;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256: u32 = 49244;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384: u32 = 49245;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256: u32 = 49246;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384: u32 = 49247;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 49248;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 49249;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256: u32 = 49250;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384: u32 = 49251;
pub const MBEDTLS_TLS_PSK_WITH_ARIA_128_CBC_SHA256: u32 = 49252;
pub const MBEDTLS_TLS_PSK_WITH_ARIA_256_CBC_SHA384: u32 = 49253;
pub const MBEDTLS_TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256: u32 = 49254;
pub const MBEDTLS_TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384: u32 = 49255;
pub const MBEDTLS_TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256: u32 = 49256;
pub const MBEDTLS_TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384: u32 = 49257;
pub const MBEDTLS_TLS_PSK_WITH_ARIA_128_GCM_SHA256: u32 = 49258;
pub const MBEDTLS_TLS_PSK_WITH_ARIA_256_GCM_SHA384: u32 = 49259;
pub const MBEDTLS_TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256: u32 = 49260;
pub const MBEDTLS_TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384: u32 = 49261;
pub const MBEDTLS_TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256: u32 = 49262;
pub const MBEDTLS_TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384: u32 = 49263;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256: u32 = 49264;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384: u32 = 49265;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49266;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49267;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49268;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49269;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49270;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49271;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49272;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49273;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49274;
pub const MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49275;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49276;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49277;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49286;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49287;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49288;
pub const MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49289;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49290;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49291;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49292;
pub const MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49293;
pub const MBEDTLS_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49294;
pub const MBEDTLS_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49295;
pub const MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49296;
pub const MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49297;
pub const MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256: u32 = 49298;
pub const MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384: u32 = 49299;
pub const MBEDTLS_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49300;
pub const MBEDTLS_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49301;
pub const MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49302;
pub const MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49303;
pub const MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49304;
pub const MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49305;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: u32 = 49306;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: u32 = 49307;
pub const MBEDTLS_TLS_RSA_WITH_AES_128_CCM: u32 = 49308;
pub const MBEDTLS_TLS_RSA_WITH_AES_256_CCM: u32 = 49309;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CCM: u32 = 49310;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CCM: u32 = 49311;
pub const MBEDTLS_TLS_RSA_WITH_AES_128_CCM_8: u32 = 49312;
pub const MBEDTLS_TLS_RSA_WITH_AES_256_CCM_8: u32 = 49313;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CCM_8: u32 = 49314;
pub const MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CCM_8: u32 = 49315;
pub const MBEDTLS_TLS_PSK_WITH_AES_128_CCM: u32 = 49316;
pub const MBEDTLS_TLS_PSK_WITH_AES_256_CCM: u32 = 49317;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CCM: u32 = 49318;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CCM: u32 = 49319;
pub const MBEDTLS_TLS_PSK_WITH_AES_128_CCM_8: u32 = 49320;
pub const MBEDTLS_TLS_PSK_WITH_AES_256_CCM_8: u32 = 49321;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CCM_8: u32 = 49322;
pub const MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CCM_8: u32 = 49323;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CCM: u32 = 49324;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CCM: u32 = 49325;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8: u32 = 49326;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8: u32 = 49327;
pub const MBEDTLS_TLS_ECJPAKE_WITH_AES_128_CCM_8: u32 = 49407;
pub const MBEDTLS_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256: u32 = 52392;
pub const MBEDTLS_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256: u32 = 52393;
pub const MBEDTLS_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256: u32 = 52394;
pub const MBEDTLS_TLS_PSK_WITH_CHACHA20_POLY1305_SHA256: u32 = 52395;
pub const MBEDTLS_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256: u32 = 52396;
pub const MBEDTLS_TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256: u32 = 52397;
pub const MBEDTLS_TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256: u32 = 52398;
pub const MBEDTLS_TLS1_3_AES_128_GCM_SHA256: u32 = 4865;
pub const MBEDTLS_TLS1_3_AES_256_GCM_SHA384: u32 = 4866;
pub const MBEDTLS_TLS1_3_CHACHA20_POLY1305_SHA256: u32 = 4867;
pub const MBEDTLS_TLS1_3_AES_128_CCM_SHA256: u32 = 4868;
pub const MBEDTLS_TLS1_3_AES_128_CCM_8_SHA256: u32 = 4869;
pub const MBEDTLS_CIPHERSUITE_WEAK: u32 = 1;
pub const MBEDTLS_CIPHERSUITE_SHORT_TAG: u32 = 2;
pub const MBEDTLS_CIPHERSUITE_NODTLS: u32 = 4;
pub const PSA_CRYPTO_API_VERSION_MAJOR: u32 = 1;
pub const PSA_CRYPTO_API_VERSION_MINOR: u32 = 0;
pub const PSA_MAC_TRUNCATION_OFFSET: u32 = 16;
pub const PSA_AEAD_TAG_LENGTH_OFFSET: u32 = 16;
pub const PSA_HASH_MAX_SIZE: u32 = 64;
pub const PSA_HMAC_MAX_HASH_BLOCK_SIZE: u32 = 128;
pub const PSA_MAC_MAX_SIZE: u32 = 64;
pub const PSA_AEAD_TAG_MAX_SIZE: u32 = 16;
pub const PSA_VENDOR_RSA_MAX_KEY_BITS: u32 = 4096;
pub const PSA_VENDOR_ECC_MAX_CURVE_BITS: u32 = 521;
pub const PSA_TLS12_PSK_TO_MS_PSK_MAX_SIZE: u32 = 128;
pub const PSA_TLS12_ECJPAKE_TO_PMS_INPUT_SIZE: u32 = 65;
pub const PSA_TLS12_ECJPAKE_TO_PMS_DATA_SIZE: u32 = 32;
pub const PSA_BLOCK_CIPHER_BLOCK_MAX_SIZE: u32 = 16;
pub const PSA_AEAD_NONCE_MAX_SIZE: u32 = 13;
pub const PSA_AEAD_FINISH_OUTPUT_MAX_SIZE: u32 = 16;
pub const PSA_AEAD_VERIFY_OUTPUT_MAX_SIZE: u32 = 16;
pub const PSA_CIPHER_IV_MAX_SIZE: u32 = 16;
pub const PSA_CIPHER_FINISH_OUTPUT_MAX_SIZE: u32 = 16;
pub const MBEDTLS_AES_BLOCK_SIZE: u32 = 16;
pub const MBEDTLS_DES3_BLOCK_SIZE: u32 = 8;
pub const MBEDTLS_CIPHER_BLKSIZE_MAX: u32 = 16;
pub const MBEDTLS_GCM_ENCRYPT: u32 = 1;
pub const MBEDTLS_GCM_DECRYPT: u32 = 0;
pub const MBEDTLS_ERR_GCM_AUTH_FAILED: i32 = -18;
pub const MBEDTLS_ERR_GCM_BAD_INPUT: i32 = -20;
pub const MBEDTLS_ERR_GCM_BUFFER_TOO_SMALL: i32 = -22;
pub const MBEDTLS_CCM_DECRYPT: u32 = 0;
pub const MBEDTLS_CCM_ENCRYPT: u32 = 1;
pub const MBEDTLS_CCM_STAR_DECRYPT: u32 = 2;
pub const MBEDTLS_CCM_STAR_ENCRYPT: u32 = 3;
pub const MBEDTLS_ERR_CCM_BAD_INPUT: i32 = -13;
pub const MBEDTLS_ERR_CCM_AUTH_FAILED: i32 = -15;
pub const MBEDTLS_ERR_POLY1305_BAD_INPUT_DATA: i32 = -87;
pub const MBEDTLS_ERR_CHACHAPOLY_BAD_STATE: i32 = -84;
pub const MBEDTLS_ERR_CHACHAPOLY_AUTH_FAILED: i32 = -86;
pub const MBEDTLS_ERR_CHACHA20_BAD_INPUT_DATA: i32 = -81;
pub const MBEDTLS_ERR_SHA1_BAD_INPUT_DATA: i32 = -115;
pub const MBEDTLS_ERR_SHA256_BAD_INPUT_DATA: i32 = -116;
pub const MBEDTLS_ERR_SHA512_BAD_INPUT_DATA: i32 = -117;
pub const MBEDTLS_PSA_BUILTIN_CIPHER: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_AEAD: u32 = 1;
pub const MBEDTLS_PSA_JPAKE_BUFFER_SIZE: u32 = 336;
pub const PSA_MAX_KEY_BITS: u32 = 65528;
pub const MBEDTLS_PSA_KA_MASK_DUAL_USE: u32 = 0;
pub const PSA_CRYPTO_ITS_RANDOM_SEED_UID: u32 = 4294967122;
pub const MBEDTLS_PSA_KEY_SLOT_COUNT: u32 = 32;
pub const PSA_PAKE_OPERATION_STAGE_SETUP: u32 = 0;
pub const PSA_PAKE_OPERATION_STAGE_COLLECT_INPUTS: u32 = 1;
pub const PSA_PAKE_OPERATION_STAGE_COMPUTATION: u32 = 2;
pub const PSA_PAKE_OUTPUT_MAX_SIZE: u32 = 65;
pub const PSA_PAKE_INPUT_MAX_SIZE: u32 = 65;
pub const MBEDTLS_ERR_ASN1_OUT_OF_DATA: i32 = -96;
pub const MBEDTLS_ERR_ASN1_UNEXPECTED_TAG: i32 = -98;
pub const MBEDTLS_ERR_ASN1_INVALID_LENGTH: i32 = -100;
pub const MBEDTLS_ERR_ASN1_LENGTH_MISMATCH: i32 = -102;
pub const MBEDTLS_ERR_ASN1_INVALID_DATA: i32 = -104;
pub const MBEDTLS_ERR_ASN1_ALLOC_FAILED: i32 = -106;
pub const MBEDTLS_ERR_ASN1_BUF_TOO_SMALL: i32 = -108;
pub const MBEDTLS_ASN1_BOOLEAN: u32 = 1;
pub const MBEDTLS_ASN1_INTEGER: u32 = 2;
pub const MBEDTLS_ASN1_BIT_STRING: u32 = 3;
pub const MBEDTLS_ASN1_OCTET_STRING: u32 = 4;
pub const MBEDTLS_ASN1_NULL: u32 = 5;
pub const MBEDTLS_ASN1_OID: u32 = 6;
pub const MBEDTLS_ASN1_ENUMERATED: u32 = 10;
pub const MBEDTLS_ASN1_UTF8_STRING: u32 = 12;
pub const MBEDTLS_ASN1_SEQUENCE: u32 = 16;
pub const MBEDTLS_ASN1_SET: u32 = 17;
pub const MBEDTLS_ASN1_PRINTABLE_STRING: u32 = 19;
pub const MBEDTLS_ASN1_T61_STRING: u32 = 20;
pub const MBEDTLS_ASN1_IA5_STRING: u32 = 22;
pub const MBEDTLS_ASN1_UTC_TIME: u32 = 23;
pub const MBEDTLS_ASN1_GENERALIZED_TIME: u32 = 24;
pub const MBEDTLS_ASN1_UNIVERSAL_STRING: u32 = 28;
pub const MBEDTLS_ASN1_BMP_STRING: u32 = 30;
pub const MBEDTLS_ASN1_PRIMITIVE: u32 = 0;
pub const MBEDTLS_ASN1_CONSTRUCTED: u32 = 32;
pub const MBEDTLS_ASN1_CONTEXT_SPECIFIC: u32 = 128;
pub const MBEDTLS_ASN1_TAG_CLASS_MASK: u32 = 192;
pub const MBEDTLS_ASN1_TAG_PC_MASK: u32 = 32;
pub const MBEDTLS_ASN1_TAG_VALUE_MASK: u32 = 31;
pub const MBEDTLS_X509_MAX_INTERMEDIATE_CA: u32 = 8;
pub const MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE: i32 = -8320;
pub const MBEDTLS_ERR_X509_UNKNOWN_OID: i32 = -8448;
pub const MBEDTLS_ERR_X509_INVALID_FORMAT: i32 = -8576;
pub const MBEDTLS_ERR_X509_INVALID_VERSION: i32 = -8704;
pub const MBEDTLS_ERR_X509_INVALID_SERIAL: i32 = -8832;
pub const MBEDTLS_ERR_X509_INVALID_ALG: i32 = -8960;
pub const MBEDTLS_ERR_X509_INVALID_NAME: i32 = -9088;
pub const MBEDTLS_ERR_X509_INVALID_DATE: i32 = -9216;
pub const MBEDTLS_ERR_X509_INVALID_SIGNATURE: i32 = -9344;
pub const MBEDTLS_ERR_X509_INVALID_EXTENSIONS: i32 = -9472;
pub const MBEDTLS_ERR_X509_UNKNOWN_VERSION: i32 = -9600;
pub const MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG: i32 = -9728;
pub const MBEDTLS_ERR_X509_SIG_MISMATCH: i32 = -9856;
pub const MBEDTLS_ERR_X509_CERT_VERIFY_FAILED: i32 = -9984;
pub const MBEDTLS_ERR_X509_CERT_UNKNOWN_FORMAT: i32 = -10112;
pub const MBEDTLS_ERR_X509_BAD_INPUT_DATA: i32 = -10240;
pub const MBEDTLS_ERR_X509_ALLOC_FAILED: i32 = -10368;
pub const MBEDTLS_ERR_X509_FILE_IO_ERROR: i32 = -10496;
pub const MBEDTLS_ERR_X509_BUFFER_TOO_SMALL: i32 = -10624;
pub const MBEDTLS_ERR_X509_FATAL_ERROR: i32 = -12288;
pub const MBEDTLS_X509_BADCERT_EXPIRED: u32 = 1;
pub const MBEDTLS_X509_BADCERT_REVOKED: u32 = 2;
pub const MBEDTLS_X509_BADCERT_CN_MISMATCH: u32 = 4;
pub const MBEDTLS_X509_BADCERT_NOT_TRUSTED: u32 = 8;
pub const MBEDTLS_X509_BADCRL_NOT_TRUSTED: u32 = 16;
pub const MBEDTLS_X509_BADCRL_EXPIRED: u32 = 32;
pub const MBEDTLS_X509_BADCERT_MISSING: u32 = 64;
pub const MBEDTLS_X509_BADCERT_SKIP_VERIFY: u32 = 128;
pub const MBEDTLS_X509_BADCERT_OTHER: u32 = 256;
pub const MBEDTLS_X509_BADCERT_FUTURE: u32 = 512;
pub const MBEDTLS_X509_BADCRL_FUTURE: u32 = 1024;
pub const MBEDTLS_X509_BADCERT_KEY_USAGE: u32 = 2048;
pub const MBEDTLS_X509_BADCERT_EXT_KEY_USAGE: u32 = 4096;
pub const MBEDTLS_X509_BADCERT_NS_CERT_TYPE: u32 = 8192;
pub const MBEDTLS_X509_BADCERT_BAD_MD: u32 = 16384;
pub const MBEDTLS_X509_BADCERT_BAD_PK: u32 = 32768;
pub const MBEDTLS_X509_BADCERT_BAD_KEY: u32 = 65536;
pub const MBEDTLS_X509_BADCRL_BAD_MD: u32 = 131072;
pub const MBEDTLS_X509_BADCRL_BAD_PK: u32 = 262144;
pub const MBEDTLS_X509_BADCRL_BAD_KEY: u32 = 524288;
pub const MBEDTLS_X509_SAN_OTHER_NAME: u32 = 0;
pub const MBEDTLS_X509_SAN_RFC822_NAME: u32 = 1;
pub const MBEDTLS_X509_SAN_DNS_NAME: u32 = 2;
pub const MBEDTLS_X509_SAN_X400_ADDRESS_NAME: u32 = 3;
pub const MBEDTLS_X509_SAN_DIRECTORY_NAME: u32 = 4;
pub const MBEDTLS_X509_SAN_EDI_PARTY_NAME: u32 = 5;
pub const MBEDTLS_X509_SAN_UNIFORM_RESOURCE_IDENTIFIER: u32 = 6;
pub const MBEDTLS_X509_SAN_IP_ADDRESS: u32 = 7;
pub const MBEDTLS_X509_SAN_REGISTERED_ID: u32 = 8;
pub const MBEDTLS_X509_KU_DIGITAL_SIGNATURE: u32 = 128;
pub const MBEDTLS_X509_KU_NON_REPUDIATION: u32 = 64;
pub const MBEDTLS_X509_KU_KEY_ENCIPHERMENT: u32 = 32;
pub const MBEDTLS_X509_KU_DATA_ENCIPHERMENT: u32 = 16;
pub const MBEDTLS_X509_KU_KEY_AGREEMENT: u32 = 8;
pub const MBEDTLS_X509_KU_KEY_CERT_SIGN: u32 = 4;
pub const MBEDTLS_X509_KU_CRL_SIGN: u32 = 2;
pub const MBEDTLS_X509_KU_ENCIPHER_ONLY: u32 = 1;
pub const MBEDTLS_X509_KU_DECIPHER_ONLY: u32 = 32768;
pub const MBEDTLS_X509_NS_CERT_TYPE_SSL_CLIENT: u32 = 128;
pub const MBEDTLS_X509_NS_CERT_TYPE_SSL_SERVER: u32 = 64;
pub const MBEDTLS_X509_NS_CERT_TYPE_EMAIL: u32 = 32;
pub const MBEDTLS_X509_NS_CERT_TYPE_OBJECT_SIGNING: u32 = 16;
pub const MBEDTLS_X509_NS_CERT_TYPE_RESERVED: u32 = 8;
pub const MBEDTLS_X509_NS_CERT_TYPE_SSL_CA: u32 = 4;
pub const MBEDTLS_X509_NS_CERT_TYPE_EMAIL_CA: u32 = 2;
pub const MBEDTLS_X509_NS_CERT_TYPE_OBJECT_SIGNING_CA: u32 = 1;
pub const MBEDTLS_X509_FORMAT_DER: u32 = 1;
pub const MBEDTLS_X509_FORMAT_PEM: u32 = 2;
pub const MBEDTLS_X509_MAX_DN_NAME_SIZE: u32 = 256;
pub const MBEDTLS_X509_CRT_VERSION_1: u32 = 0;
pub const MBEDTLS_X509_CRT_VERSION_2: u32 = 1;
pub const MBEDTLS_X509_CRT_VERSION_3: u32 = 2;
pub const MBEDTLS_X509_RFC5280_MAX_SERIAL_LEN: u32 = 20;
pub const MBEDTLS_X509_RFC5280_UTC_TIME_LEN: u32 = 15;
pub const MBEDTLS_X509_MAX_FILE_PATH_LEN: u32 = 512;
pub const MBEDTLS_X509_MAX_VERIFY_CHAIN_SIZE: u32 = 10;
pub const MBEDTLS_ERR_DHM_BAD_INPUT_DATA: i32 = -12416;
pub const MBEDTLS_ERR_DHM_READ_PARAMS_FAILED: i32 = -12544;
pub const MBEDTLS_ERR_DHM_MAKE_PARAMS_FAILED: i32 = -12672;
pub const MBEDTLS_ERR_DHM_READ_PUBLIC_FAILED: i32 = -12800;
pub const MBEDTLS_ERR_DHM_MAKE_PUBLIC_FAILED: i32 = -12928;
pub const MBEDTLS_ERR_DHM_CALC_SECRET_FAILED: i32 = -13056;
pub const MBEDTLS_ERR_DHM_INVALID_FORMAT: i32 = -13184;
pub const MBEDTLS_ERR_DHM_ALLOC_FAILED: i32 = -13312;
pub const MBEDTLS_ERR_DHM_FILE_IO_ERROR: i32 = -13440;
pub const MBEDTLS_ERR_DHM_SET_GROUP_FAILED: i32 = -13696;
pub const MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS: i32 = -28672;
pub const MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE: i32 = -28800;
pub const MBEDTLS_ERR_SSL_BAD_INPUT_DATA: i32 = -28928;
pub const MBEDTLS_ERR_SSL_INVALID_MAC: i32 = -29056;
pub const MBEDTLS_ERR_SSL_INVALID_RECORD: i32 = -29184;
pub const MBEDTLS_ERR_SSL_CONN_EOF: i32 = -29312;
pub const MBEDTLS_ERR_SSL_DECODE_ERROR: i32 = -29440;
pub const MBEDTLS_ERR_SSL_NO_RNG: i32 = -29696;
pub const MBEDTLS_ERR_SSL_NO_CLIENT_CERTIFICATE: i32 = -29824;
pub const MBEDTLS_ERR_SSL_UNSUPPORTED_EXTENSION: i32 = -29952;
pub const MBEDTLS_ERR_SSL_NO_APPLICATION_PROTOCOL: i32 = -30080;
pub const MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED: i32 = -30208;
pub const MBEDTLS_ERR_SSL_CA_CHAIN_REQUIRED: i32 = -30336;
pub const MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE: i32 = -30464;
pub const MBEDTLS_ERR_SSL_FATAL_ALERT_MESSAGE: i32 = -30592;
pub const MBEDTLS_ERR_SSL_UNRECOGNIZED_NAME: i32 = -30720;
pub const MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY: i32 = -30848;
pub const MBEDTLS_ERR_SSL_BAD_CERTIFICATE: i32 = -31232;
pub const MBEDTLS_ERR_SSL_RECEIVED_NEW_SESSION_TICKET: i32 = -31488;
pub const MBEDTLS_ERR_SSL_CANNOT_READ_EARLY_DATA: i32 = -31616;
pub const MBEDTLS_ERR_SSL_CANNOT_WRITE_EARLY_DATA: i32 = -31744;
pub const MBEDTLS_ERR_SSL_ALLOC_FAILED: i32 = -32512;
pub const MBEDTLS_ERR_SSL_HW_ACCEL_FAILED: i32 = -32640;
pub const MBEDTLS_ERR_SSL_HW_ACCEL_FALLTHROUGH: i32 = -28544;
pub const MBEDTLS_ERR_SSL_BAD_PROTOCOL_VERSION: i32 = -28288;
pub const MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE: i32 = -28160;
pub const MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED: i32 = -28032;
pub const MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH: i32 = -27904;
pub const MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY: i32 = -27776;
pub const MBEDTLS_ERR_SSL_INTERNAL_ERROR: i32 = -27648;
pub const MBEDTLS_ERR_SSL_COUNTER_WRAPPING: i32 = -27520;
pub const MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO: i32 = -27392;
pub const MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED: i32 = -27264;
pub const MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL: i32 = -27136;
pub const MBEDTLS_ERR_SSL_WANT_READ: i32 = -26880;
pub const MBEDTLS_ERR_SSL_WANT_WRITE: i32 = -26752;
pub const MBEDTLS_ERR_SSL_TIMEOUT: i32 = -26624;
pub const MBEDTLS_ERR_SSL_CLIENT_RECONNECT: i32 = -26496;
pub const MBEDTLS_ERR_SSL_UNEXPECTED_RECORD: i32 = -26368;
pub const MBEDTLS_ERR_SSL_NON_FATAL: i32 = -26240;
pub const MBEDTLS_ERR_SSL_ILLEGAL_PARAMETER: i32 = -26112;
pub const MBEDTLS_ERR_SSL_CONTINUE_PROCESSING: i32 = -25984;
pub const MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS: i32 = -25856;
pub const MBEDTLS_ERR_SSL_EARLY_MESSAGE: i32 = -25728;
pub const MBEDTLS_ERR_SSL_UNEXPECTED_CID: i32 = -24576;
pub const MBEDTLS_ERR_SSL_VERSION_MISMATCH: i32 = -24320;
pub const MBEDTLS_ERR_SSL_BAD_CONFIG: i32 = -24192;
pub const MBEDTLS_SSL_TLS1_3_PSK_MODE_PURE: u32 = 0;
pub const MBEDTLS_SSL_TLS1_3_PSK_MODE_ECDHE: u32 = 1;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_NONE: u32 = 0;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_SECP192K1: u32 = 18;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_SECP192R1: u32 = 19;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_SECP224K1: u32 = 20;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_SECP224R1: u32 = 21;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_SECP256K1: u32 = 22;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_SECP256R1: u32 = 23;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_SECP384R1: u32 = 24;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_SECP521R1: u32 = 25;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_BP256R1: u32 = 26;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_BP384R1: u32 = 27;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_BP512R1: u32 = 28;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_X25519: u32 = 29;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_X448: u32 = 30;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_FFDHE2048: u32 = 256;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_FFDHE3072: u32 = 257;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_FFDHE4096: u32 = 258;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_FFDHE6144: u32 = 259;
pub const MBEDTLS_SSL_IANA_TLS_GROUP_FFDHE8192: u32 = 260;
pub const MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK: u32 = 1;
pub const MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_EPHEMERAL: u32 = 2;
pub const MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK_EPHEMERAL: u32 = 4;
pub const MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_ALL: u32 = 7;
pub const MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK_ALL: u32 = 5;
pub const MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_EPHEMERAL_ALL: u32 = 6;
pub const MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_NONE: u32 = 0;
pub const MBEDTLS_SSL_MAJOR_VERSION_3: u32 = 3;
pub const MBEDTLS_SSL_MINOR_VERSION_3: u32 = 3;
pub const MBEDTLS_SSL_MINOR_VERSION_4: u32 = 4;
pub const MBEDTLS_SSL_TRANSPORT_STREAM: u32 = 0;
pub const MBEDTLS_SSL_TRANSPORT_DATAGRAM: u32 = 1;
pub const MBEDTLS_SSL_MAX_HOST_NAME_LEN: u32 = 255;
pub const MBEDTLS_SSL_MAX_ALPN_NAME_LEN: u32 = 255;
pub const MBEDTLS_SSL_MAX_ALPN_LIST_LEN: u32 = 65535;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_NONE: u32 = 0;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_512: u32 = 1;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_1024: u32 = 2;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_2048: u32 = 3;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_4096: u32 = 4;
pub const MBEDTLS_SSL_MAX_FRAG_LEN_INVALID: u32 = 5;
pub const MBEDTLS_SSL_IS_CLIENT: u32 = 0;
pub const MBEDTLS_SSL_IS_SERVER: u32 = 1;
pub const MBEDTLS_SSL_EXTENDED_MS_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_EXTENDED_MS_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_CID_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_CID_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_ETM_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_ETM_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_COMPRESS_NULL: u32 = 0;
pub const MBEDTLS_SSL_VERIFY_NONE: u32 = 0;
pub const MBEDTLS_SSL_VERIFY_OPTIONAL: u32 = 1;
pub const MBEDTLS_SSL_VERIFY_REQUIRED: u32 = 2;
pub const MBEDTLS_SSL_VERIFY_UNSET: u32 = 3;
pub const MBEDTLS_SSL_LEGACY_RENEGOTIATION: u32 = 0;
pub const MBEDTLS_SSL_SECURE_RENEGOTIATION: u32 = 1;
pub const MBEDTLS_SSL_RENEGOTIATION_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_RENEGOTIATION_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_ANTI_REPLAY_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_ANTI_REPLAY_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_RENEGOTIATION_NOT_ENFORCED: i32 = -1;
pub const MBEDTLS_SSL_RENEGO_MAX_RECORDS_DEFAULT: u32 = 16;
pub const MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION: u32 = 0;
pub const MBEDTLS_SSL_LEGACY_ALLOW_RENEGOTIATION: u32 = 1;
pub const MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE: u32 = 2;
pub const MBEDTLS_SSL_TRUNC_HMAC_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_TRUNC_HMAC_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_TRUNCATED_HMAC_LEN: u32 = 10;
pub const MBEDTLS_SSL_SESSION_TICKETS_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_SESSION_TICKETS_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_PRESET_DEFAULT: u32 = 0;
pub const MBEDTLS_SSL_PRESET_SUITEB: u32 = 2;
pub const MBEDTLS_SSL_CERT_REQ_CA_LIST_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_CERT_REQ_CA_LIST_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_EARLY_DATA_DISABLED: u32 = 0;
pub const MBEDTLS_SSL_EARLY_DATA_ENABLED: u32 = 1;
pub const MBEDTLS_SSL_DTLS_SRTP_MKI_UNSUPPORTED: u32 = 0;
pub const MBEDTLS_SSL_DTLS_SRTP_MKI_SUPPORTED: u32 = 1;
pub const MBEDTLS_SSL_SRV_CIPHERSUITE_ORDER_CLIENT: u32 = 1;
pub const MBEDTLS_SSL_SRV_CIPHERSUITE_ORDER_SERVER: u32 = 0;
pub const MBEDTLS_SSL_TLS1_3_TICKET_RESUMPTION_KEY_LEN: u32 = 48;
pub const MBEDTLS_SSL_DTLS_TIMEOUT_DFL_MIN: u32 = 1000;
pub const MBEDTLS_SSL_DTLS_TIMEOUT_DFL_MAX: u32 = 60000;
pub const MBEDTLS_SSL_IN_CONTENT_LEN: u32 = 16384;
pub const MBEDTLS_SSL_OUT_CONTENT_LEN: u32 = 16384;
pub const MBEDTLS_SSL_DTLS_MAX_BUFFERING: u32 = 32768;
pub const MBEDTLS_SSL_CID_IN_LEN_MAX: u32 = 32;
pub const MBEDTLS_SSL_CID_OUT_LEN_MAX: u32 = 32;
pub const MBEDTLS_SSL_CID_TLS1_3_PADDING_GRANULARITY: u32 = 16;
pub const MBEDTLS_SSL_VERIFY_DATA_MAX_LEN: u32 = 12;
pub const MBEDTLS_SSL_EMPTY_RENEGOTIATION_INFO: u32 = 255;
pub const MBEDTLS_SSL_HASH_NONE: u32 = 0;
pub const MBEDTLS_SSL_HASH_MD5: u32 = 1;
pub const MBEDTLS_SSL_HASH_SHA1: u32 = 2;
pub const MBEDTLS_SSL_HASH_SHA224: u32 = 3;
pub const MBEDTLS_SSL_HASH_SHA256: u32 = 4;
pub const MBEDTLS_SSL_HASH_SHA384: u32 = 5;
pub const MBEDTLS_SSL_HASH_SHA512: u32 = 6;
pub const MBEDTLS_SSL_SIG_ANON: u32 = 0;
pub const MBEDTLS_SSL_SIG_RSA: u32 = 1;
pub const MBEDTLS_SSL_SIG_ECDSA: u32 = 3;
pub const MBEDTLS_TLS1_3_SIG_RSA_PKCS1_SHA256: u32 = 1025;
pub const MBEDTLS_TLS1_3_SIG_RSA_PKCS1_SHA384: u32 = 1281;
pub const MBEDTLS_TLS1_3_SIG_RSA_PKCS1_SHA512: u32 = 1537;
pub const MBEDTLS_TLS1_3_SIG_ECDSA_SECP256R1_SHA256: u32 = 1027;
pub const MBEDTLS_TLS1_3_SIG_ECDSA_SECP384R1_SHA384: u32 = 1283;
pub const MBEDTLS_TLS1_3_SIG_ECDSA_SECP521R1_SHA512: u32 = 1539;
pub const MBEDTLS_TLS1_3_SIG_RSA_PSS_RSAE_SHA256: u32 = 2052;
pub const MBEDTLS_TLS1_3_SIG_RSA_PSS_RSAE_SHA384: u32 = 2053;
pub const MBEDTLS_TLS1_3_SIG_RSA_PSS_RSAE_SHA512: u32 = 2054;
pub const MBEDTLS_TLS1_3_SIG_ED25519: u32 = 2055;
pub const MBEDTLS_TLS1_3_SIG_ED448: u32 = 2056;
pub const MBEDTLS_TLS1_3_SIG_RSA_PSS_PSS_SHA256: u32 = 2057;
pub const MBEDTLS_TLS1_3_SIG_RSA_PSS_PSS_SHA384: u32 = 2058;
pub const MBEDTLS_TLS1_3_SIG_RSA_PSS_PSS_SHA512: u32 = 2059;
pub const MBEDTLS_TLS1_3_SIG_RSA_PKCS1_SHA1: u32 = 513;
pub const MBEDTLS_TLS1_3_SIG_ECDSA_SHA1: u32 = 515;
pub const MBEDTLS_TLS1_3_SIG_NONE: u32 = 0;
pub const MBEDTLS_SSL_CERT_TYPE_RSA_SIGN: u32 = 1;
pub const MBEDTLS_SSL_CERT_TYPE_ECDSA_SIGN: u32 = 64;
pub const MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC: u32 = 20;
pub const MBEDTLS_SSL_MSG_ALERT: u32 = 21;
pub const MBEDTLS_SSL_MSG_HANDSHAKE: u32 = 22;
pub const MBEDTLS_SSL_MSG_APPLICATION_DATA: u32 = 23;
pub const MBEDTLS_SSL_MSG_CID: u32 = 25;
pub const MBEDTLS_SSL_ALERT_LEVEL_WARNING: u32 = 1;
pub const MBEDTLS_SSL_ALERT_LEVEL_FATAL: u32 = 2;
pub const MBEDTLS_SSL_ALERT_MSG_CLOSE_NOTIFY: u32 = 0;
pub const MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE: u32 = 10;
pub const MBEDTLS_SSL_ALERT_MSG_BAD_RECORD_MAC: u32 = 20;
pub const MBEDTLS_SSL_ALERT_MSG_DECRYPTION_FAILED: u32 = 21;
pub const MBEDTLS_SSL_ALERT_MSG_RECORD_OVERFLOW: u32 = 22;
pub const MBEDTLS_SSL_ALERT_MSG_DECOMPRESSION_FAILURE: u32 = 30;
pub const MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE: u32 = 40;
pub const MBEDTLS_SSL_ALERT_MSG_NO_CERT: u32 = 41;
pub const MBEDTLS_SSL_ALERT_MSG_BAD_CERT: u32 = 42;
pub const MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT: u32 = 43;
pub const MBEDTLS_SSL_ALERT_MSG_CERT_REVOKED: u32 = 44;
pub const MBEDTLS_SSL_ALERT_MSG_CERT_EXPIRED: u32 = 45;
pub const MBEDTLS_SSL_ALERT_MSG_CERT_UNKNOWN: u32 = 46;
pub const MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER: u32 = 47;
pub const MBEDTLS_SSL_ALERT_MSG_UNKNOWN_CA: u32 = 48;
pub const MBEDTLS_SSL_ALERT_MSG_ACCESS_DENIED: u32 = 49;
pub const MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR: u32 = 50;
pub const MBEDTLS_SSL_ALERT_MSG_DECRYPT_ERROR: u32 = 51;
pub const MBEDTLS_SSL_ALERT_MSG_EXPORT_RESTRICTION: u32 = 60;
pub const MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION: u32 = 70;
pub const MBEDTLS_SSL_ALERT_MSG_INSUFFICIENT_SECURITY: u32 = 71;
pub const MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR: u32 = 80;
pub const MBEDTLS_SSL_ALERT_MSG_INAPROPRIATE_FALLBACK: u32 = 86;
pub const MBEDTLS_SSL_ALERT_MSG_USER_CANCELED: u32 = 90;
pub const MBEDTLS_SSL_ALERT_MSG_NO_RENEGOTIATION: u32 = 100;
pub const MBEDTLS_SSL_ALERT_MSG_MISSING_EXTENSION: u32 = 109;
pub const MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_EXT: u32 = 110;
pub const MBEDTLS_SSL_ALERT_MSG_UNRECOGNIZED_NAME: u32 = 112;
pub const MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY: u32 = 115;
pub const MBEDTLS_SSL_ALERT_MSG_CERT_REQUIRED: u32 = 116;
pub const MBEDTLS_SSL_ALERT_MSG_NO_APPLICATION_PROTOCOL: u32 = 120;
pub const MBEDTLS_SSL_HS_HELLO_REQUEST: u32 = 0;
pub const MBEDTLS_SSL_HS_CLIENT_HELLO: u32 = 1;
pub const MBEDTLS_SSL_HS_SERVER_HELLO: u32 = 2;
pub const MBEDTLS_SSL_HS_HELLO_VERIFY_REQUEST: u32 = 3;
pub const MBEDTLS_SSL_HS_NEW_SESSION_TICKET: u32 = 4;
pub const MBEDTLS_SSL_HS_END_OF_EARLY_DATA: u32 = 5;
pub const MBEDTLS_SSL_HS_ENCRYPTED_EXTENSIONS: u32 = 8;
pub const MBEDTLS_SSL_HS_CERTIFICATE: u32 = 11;
pub const MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE: u32 = 12;
pub const MBEDTLS_SSL_HS_CERTIFICATE_REQUEST: u32 = 13;
pub const MBEDTLS_SSL_HS_SERVER_HELLO_DONE: u32 = 14;
pub const MBEDTLS_SSL_HS_CERTIFICATE_VERIFY: u32 = 15;
pub const MBEDTLS_SSL_HS_CLIENT_KEY_EXCHANGE: u32 = 16;
pub const MBEDTLS_SSL_HS_FINISHED: u32 = 20;
pub const MBEDTLS_SSL_HS_MESSAGE_HASH: u32 = 254;
pub const MBEDTLS_TLS_EXT_SERVERNAME: u32 = 0;
pub const MBEDTLS_TLS_EXT_SERVERNAME_HOSTNAME: u32 = 0;
pub const MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH: u32 = 1;
pub const MBEDTLS_TLS_EXT_TRUNCATED_HMAC: u32 = 4;
pub const MBEDTLS_TLS_EXT_STATUS_REQUEST: u32 = 5;
pub const MBEDTLS_TLS_EXT_SUPPORTED_ELLIPTIC_CURVES: u32 = 10;
pub const MBEDTLS_TLS_EXT_SUPPORTED_GROUPS: u32 = 10;
pub const MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS: u32 = 11;
pub const MBEDTLS_TLS_EXT_SIG_ALG: u32 = 13;
pub const MBEDTLS_TLS_EXT_USE_SRTP: u32 = 14;
pub const MBEDTLS_TLS_EXT_HEARTBEAT: u32 = 15;
pub const MBEDTLS_TLS_EXT_ALPN: u32 = 16;
pub const MBEDTLS_TLS_EXT_SCT: u32 = 18;
pub const MBEDTLS_TLS_EXT_CLI_CERT_TYPE: u32 = 19;
pub const MBEDTLS_TLS_EXT_SERV_CERT_TYPE: u32 = 20;
pub const MBEDTLS_TLS_EXT_PADDING: u32 = 21;
pub const MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC: u32 = 22;
pub const MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET: u32 = 23;
pub const MBEDTLS_TLS_EXT_RECORD_SIZE_LIMIT: u32 = 28;
pub const MBEDTLS_TLS_EXT_SESSION_TICKET: u32 = 35;
pub const MBEDTLS_TLS_EXT_PRE_SHARED_KEY: u32 = 41;
pub const MBEDTLS_TLS_EXT_EARLY_DATA: u32 = 42;
pub const MBEDTLS_TLS_EXT_SUPPORTED_VERSIONS: u32 = 43;
pub const MBEDTLS_TLS_EXT_COOKIE: u32 = 44;
pub const MBEDTLS_TLS_EXT_PSK_KEY_EXCHANGE_MODES: u32 = 45;
pub const MBEDTLS_TLS_EXT_CERT_AUTH: u32 = 47;
pub const MBEDTLS_TLS_EXT_OID_FILTERS: u32 = 48;
pub const MBEDTLS_TLS_EXT_POST_HANDSHAKE_AUTH: u32 = 49;
pub const MBEDTLS_TLS_EXT_SIG_ALG_CERT: u32 = 50;
pub const MBEDTLS_TLS_EXT_KEY_SHARE: u32 = 51;
pub const MBEDTLS_TLS_EXT_CID: u32 = 54;
pub const MBEDTLS_TLS_EXT_ECJPAKE_KKPP: u32 = 256;
pub const MBEDTLS_TLS_EXT_RENEGOTIATION_INFO: u32 = 65281;
pub const MBEDTLS_PSK_MAX_LEN: u32 = 48;
pub const MBEDTLS_TLS1_3_MD_MAX_SIZE: u32 = 64;
pub const MBEDTLS_SSL_SEQUENCE_NUMBER_LEN: u32 = 8;
pub const MBEDTLS_SSL_TLS1_3_TICKET_ALLOW_PSK_RESUMPTION: u32 = 1;
pub const MBEDTLS_SSL_TLS1_3_TICKET_ALLOW_PSK_EPHEMERAL_RESUMPTION: u32 = 4;
pub const MBEDTLS_SSL_TLS1_3_TICKET_ALLOW_EARLY_DATA: u32 = 8;
pub const MBEDTLS_SSL_TLS1_3_TICKET_FLAGS_MASK: u32 = 13;
pub const MBEDTLS_SSL_UNEXPECTED_CID_IGNORE: u32 = 0;
pub const MBEDTLS_SSL_UNEXPECTED_CID_FAIL: u32 = 1;
pub const MBEDTLS_ERR_ENTROPY_SOURCE_FAILED: i32 = -60;
pub const MBEDTLS_ERR_ENTROPY_MAX_SOURCES: i32 = -62;
pub const MBEDTLS_ERR_ENTROPY_NO_SOURCES_DEFINED: i32 = -64;
pub const MBEDTLS_ERR_ENTROPY_NO_STRONG_SOURCE: i32 = -61;
pub const MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR: i32 = -63;
pub const MBEDTLS_ENTROPY_MAX_SOURCES: u32 = 20;
pub const MBEDTLS_ENTROPY_MAX_GATHER: u32 = 128;
pub const MBEDTLS_ENTROPY_BLOCK_SIZE: u32 = 64;
pub const MBEDTLS_ENTROPY_MAX_SEED_SIZE: u32 = 1024;
pub const MBEDTLS_ENTROPY_SOURCE_MANUAL: u32 = 20;
pub const MBEDTLS_ENTROPY_SOURCE_STRONG: u32 = 1;
pub const MBEDTLS_ENTROPY_SOURCE_WEAK: u32 = 0;
pub const MBEDTLS_PRINTF_SIZET: &[u8; 3] = b"zu\0";
pub const MBEDTLS_PRINTF_LONGLONG: &[u8; 4] = b"lld\0";
pub const MBEDTLS_AES_ENCRYPT: u32 = 1;
pub const MBEDTLS_AES_DECRYPT: u32 = 0;
pub const MBEDTLS_ERR_AES_INVALID_KEY_LENGTH: i32 = -32;
pub const MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH: i32 = -34;
pub const MBEDTLS_ERR_AES_BAD_INPUT_DATA: i32 = -33;
pub const MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED: i32 = -52;
pub const MBEDTLS_ERR_CTR_DRBG_REQUEST_TOO_BIG: i32 = -54;
pub const MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG: i32 = -56;
pub const MBEDTLS_ERR_CTR_DRBG_FILE_IO_ERROR: i32 = -58;
pub const MBEDTLS_CTR_DRBG_BLOCKSIZE: u32 = 16;
pub const MBEDTLS_CTR_DRBG_KEYSIZE: u32 = 32;
pub const MBEDTLS_CTR_DRBG_KEYBITS: u32 = 256;
pub const MBEDTLS_CTR_DRBG_SEEDLEN: u32 = 48;
pub const MBEDTLS_CTR_DRBG_ENTROPY_LEN: u32 = 48;
pub const MBEDTLS_CTR_DRBG_RESEED_INTERVAL: u32 = 10000;
pub const MBEDTLS_CTR_DRBG_MAX_INPUT: u32 = 256;
pub const MBEDTLS_CTR_DRBG_MAX_REQUEST: u32 = 1024;
pub const MBEDTLS_CTR_DRBG_MAX_SEED_INPUT: u32 = 384;
pub const MBEDTLS_CTR_DRBG_PR_OFF: u32 = 0;
pub const MBEDTLS_CTR_DRBG_PR_ON: u32 = 1;
pub const MBEDTLS_CTR_DRBG_ENTROPY_NONCE_LEN: u32 = 0;
pub type __int8_t = crate::c_types::c_schar;
pub type __uint8_t = crate::c_types::c_uchar;
pub type __int16_t = crate::c_types::c_short;
pub type __uint16_t = crate::c_types::c_ushort;
pub type __int32_t = crate::c_types::c_int;
pub type __uint32_t = crate::c_types::c_uint;
pub type __int64_t = crate::c_types::c_longlong;
pub type __uint64_t = crate::c_types::c_ulonglong;
pub type __int_least8_t = crate::c_types::c_schar;
pub type __uint_least8_t = crate::c_types::c_uchar;
pub type __int_least16_t = crate::c_types::c_short;
pub type __uint_least16_t = crate::c_types::c_ushort;
pub type __int_least32_t = crate::c_types::c_int;
pub type __uint_least32_t = crate::c_types::c_uint;
pub type __int_least64_t = crate::c_types::c_longlong;
pub type __uint_least64_t = crate::c_types::c_ulonglong;
pub type __intmax_t = crate::c_types::c_longlong;
pub type __uintmax_t = crate::c_types::c_ulonglong;
pub type __intptr_t = crate::c_types::c_int;
pub type __uintptr_t = crate::c_types::c_uint;
pub type wchar_t = crate::c_types::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: crate::c_types::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = crate::c_types::c_schar;
pub type uint_fast8_t = crate::c_types::c_uchar;
pub type int_fast16_t = crate::c_types::c_short;
pub type uint_fast16_t = crate::c_types::c_ushort;
pub type int_fast32_t = crate::c_types::c_int;
pub type uint_fast32_t = crate::c_types::c_uint;
pub type int_fast64_t = crate::c_types::c_longlong;
pub type uint_fast64_t = crate::c_types::c_ulonglong;
pub type mbedtls_iso_c_forbids_empty_translation_units = crate::c_types::c_int;
extern "C" {
    #[doc = " \\brief       Securely zeroize a buffer\n\n              The function is meant to wipe the data contained in a buffer so\n              that it can no longer be recovered even if the program memory\n              is later compromised. Call this function on sensitive data\n              stored on the stack before returning from a function, and on\n              sensitive data stored on the heap before freeing the heap\n              object.\n\n              It is extremely difficult to guarantee that calls to\n              mbedtls_platform_zeroize() are not removed by aggressive\n              compiler optimizations in a portable way. For this reason, Mbed\n              TLS provides the configuration option\n              MBEDTLS_PLATFORM_ZEROIZE_ALT, which allows users to configure\n              mbedtls_platform_zeroize() to use a suitable implementation for\n              their platform and needs\n\n \\param buf   Buffer to be zeroized\n \\param len   Length of the buffer in bytes\n"]
    pub fn mbedtls_platform_zeroize(buf: *mut crate::c_types::c_void, len: usize);
}
pub type mbedtls_mpi_sint = i32;
pub type mbedtls_mpi_uint = u32;
pub type mbedtls_t_udbl = u64;
#[doc = " \\brief          MPI structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_mpi {
    pub private_s: crate::c_types::c_int,
    pub private_n: usize,
    pub private_p: *mut mbedtls_mpi_uint,
}
extern "C" {
    #[doc = " \\brief           Initialize an MPI context.\n\n                  This makes the MPI ready to be set or freed,\n                  but does not define a value for the MPI.\n\n \\param X         The MPI context to initialize. This must not be \\c NULL."]
    pub fn mbedtls_mpi_init(X: *mut mbedtls_mpi);
}
extern "C" {
    #[doc = " \\brief          This function frees the components of an MPI context.\n\n \\param X        The MPI context to be cleared. This may be \\c NULL,\n                 in which case this function is a no-op. If it is\n                 not \\c NULL, it must point to an initialized MPI."]
    pub fn mbedtls_mpi_free(X: *mut mbedtls_mpi);
}
extern "C" {
    #[doc = " \\brief          Enlarge an MPI to the specified number of limbs.\n\n \\note           This function does nothing if the MPI is\n                 already large enough.\n\n \\param X        The MPI to grow. It must be initialized.\n \\param nblimbs  The target number of limbs.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return         Another negative error code on other kinds of failure."]
    pub fn mbedtls_mpi_grow(X: *mut mbedtls_mpi, nblimbs: usize) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function resizes an MPI downwards, keeping at least the\n                 specified number of limbs.\n\n                 If \\c X is smaller than \\c nblimbs, it is resized up\n                 instead.\n\n \\param X        The MPI to shrink. This must point to an initialized MPI.\n \\param nblimbs  The minimum number of limbs to keep.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed\n                 (this can only happen when resizing up).\n \\return         Another negative error code on other kinds of failure."]
    pub fn mbedtls_mpi_shrink(X: *mut mbedtls_mpi, nblimbs: usize) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Make a copy of an MPI.\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param Y        The source MPI. This must point to an initialized MPI.\n\n \\note           The limb-buffer in the destination MPI is enlarged\n                 if necessary to hold the value in the source MPI.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return         Another negative error code on other kinds of failure."]
    pub fn mbedtls_mpi_copy(X: *mut mbedtls_mpi, Y: *const mbedtls_mpi) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Swap the contents of two MPIs.\n\n \\param X        The first MPI. It must be initialized.\n \\param Y        The second MPI. It must be initialized."]
    pub fn mbedtls_mpi_swap(X: *mut mbedtls_mpi, Y: *mut mbedtls_mpi);
}
extern "C" {
    #[doc = " \\brief          Perform a safe conditional copy of MPI which doesn't\n                 reveal whether the condition was true or not.\n\n \\param X        The MPI to conditionally assign to. This must point\n                 to an initialized MPI.\n \\param Y        The MPI to be assigned from. This must point to an\n                 initialized MPI.\n \\param assign   The condition deciding whether to perform the\n                 assignment or not. Must be either 0 or 1:\n                 * \\c 1: Perform the assignment `X = Y`.\n                 * \\c 0: Keep the original value of \\p X.\n\n \\note           This function is equivalent to\n                      `if( assign ) mbedtls_mpi_copy( X, Y );`\n                 except that it avoids leaking any information about whether\n                 the assignment was done or not (the above code may leak\n                 information through branch prediction and/or memory access\n                 patterns analysis).\n\n \\warning        If \\p assign is neither 0 nor 1, the result of this function\n                 is indeterminate, and the resulting value in \\p X might be\n                 neither its original value nor the value in \\p Y.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return         Another negative error code on other kinds of failure."]
    pub fn mbedtls_mpi_safe_cond_assign(
        X: *mut mbedtls_mpi,
        Y: *const mbedtls_mpi,
        assign: crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a safe conditional swap which doesn't\n                 reveal whether the condition was true or not.\n\n \\param X        The first MPI. This must be initialized.\n \\param Y        The second MPI. This must be initialized.\n \\param swap     The condition deciding whether to perform\n                 the swap or not. Must be either 0 or 1:\n                 * \\c 1: Swap the values of \\p X and \\p Y.\n                 * \\c 0: Keep the original values of \\p X and \\p Y.\n\n \\note           This function is equivalent to\n                      if( swap ) mbedtls_mpi_swap( X, Y );\n                 except that it avoids leaking any information about whether\n                 the swap was done or not (the above code may leak\n                 information through branch prediction and/or memory access\n                 patterns analysis).\n\n \\warning        If \\p swap is neither 0 nor 1, the result of this function\n                 is indeterminate, and both \\p X and \\p Y might end up with\n                 values different to either of the original ones.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return         Another negative error code on other kinds of failure.\n"]
    pub fn mbedtls_mpi_safe_cond_swap(
        X: *mut mbedtls_mpi,
        Y: *mut mbedtls_mpi,
        swap: crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Store integer value in MPI.\n\n \\param X        The MPI to set. This must be initialized.\n \\param z        The value to use.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return         Another negative error code on other kinds of failure."]
    pub fn mbedtls_mpi_lset(X: *mut mbedtls_mpi, z: mbedtls_mpi_sint) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Get a specific bit from an MPI.\n\n \\param X        The MPI to query. This must be initialized.\n \\param pos      Zero-based index of the bit to query.\n\n \\return         \\c 0 or \\c 1 on success, depending on whether bit \\c pos\n                 of \\c X is unset or set.\n \\return         A negative error code on failure."]
    pub fn mbedtls_mpi_get_bit(X: *const mbedtls_mpi, pos: usize) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Modify a specific bit in an MPI.\n\n \\note           This function will grow the target MPI if necessary to set a\n                 bit to \\c 1 in a not yet existing limb. It will not grow if\n                 the bit should be set to \\c 0.\n\n \\param X        The MPI to modify. This must be initialized.\n \\param pos      Zero-based index of the bit to modify.\n \\param val      The desired value of bit \\c pos: \\c 0 or \\c 1.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return         Another negative error code on other kinds of failure."]
    pub fn mbedtls_mpi_set_bit(
        X: *mut mbedtls_mpi,
        pos: usize,
        val: crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Return the number of bits of value \\c 0 before the\n                 least significant bit of value \\c 1.\n\n \\note           This is the same as the zero-based index of\n                 the least significant bit of value \\c 1.\n\n \\param X        The MPI to query.\n\n \\return         The number of bits of value \\c 0 before the least significant\n                 bit of value \\c 1 in \\p X."]
    pub fn mbedtls_mpi_lsb(X: *const mbedtls_mpi) -> usize;
}
extern "C" {
    #[doc = " \\brief          Return the number of bits up to and including the most\n                 significant bit of value \\c 1.\n\n * \\note         This is same as the one-based index of the most\n                 significant bit of value \\c 1.\n\n \\param X        The MPI to query. This must point to an initialized MPI.\n\n \\return         The number of bits up to and including the most\n                 significant bit of value \\c 1."]
    pub fn mbedtls_mpi_bitlen(X: *const mbedtls_mpi) -> usize;
}
extern "C" {
    #[doc = " \\brief          Return the total size of an MPI value in bytes.\n\n \\param X        The MPI to use. This must point to an initialized MPI.\n\n \\note           The value returned by this function may be less than\n                 the number of bytes used to store \\p X internally.\n                 This happens if and only if there are trailing bytes\n                 of value zero.\n\n \\return         The least number of bytes capable of storing\n                 the absolute value of \\p X."]
    pub fn mbedtls_mpi_size(X: *const mbedtls_mpi) -> usize;
}
extern "C" {
    #[doc = " \\brief          Import an MPI from an ASCII string.\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param radix    The numeric base of the input string.\n \\param s        Null-terminated string buffer.\n\n \\return         \\c 0 if successful.\n \\return         A negative error code on failure."]
    pub fn mbedtls_mpi_read_string(
        X: *mut mbedtls_mpi,
        radix: crate::c_types::c_int,
        s: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Export an MPI to an ASCII string.\n\n \\param X        The source MPI. This must point to an initialized MPI.\n \\param radix    The numeric base of the output string.\n \\param buf      The buffer to write the string to. This must be writable\n                 buffer of length \\p buflen Bytes.\n \\param buflen   The available size in Bytes of \\p buf.\n \\param olen     The address at which to store the length of the string\n                 written, including the  final \\c NULL byte. This must\n                 not be \\c NULL.\n\n \\note           You can call this function with `buflen == 0` to obtain the\n                 minimum required buffer size in `*olen`.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL if the target buffer \\p buf\n                 is too small to hold the value of \\p X in the desired base.\n                 In this case, `*olen` is nonetheless updated to contain the\n                 size of \\p buf required for a successful call.\n \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_write_string(
        X: *const mbedtls_mpi,
        radix: crate::c_types::c_int,
        buf: *mut crate::c_types::c_char,
        buflen: usize,
        olen: *mut usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Import an MPI from unsigned big endian binary data.\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param buf      The input buffer. This must be a readable buffer of length\n                 \\p buflen Bytes.\n \\param buflen   The length of the input buffer \\p p in Bytes.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_read_binary(
        X: *mut mbedtls_mpi,
        buf: *const crate::c_types::c_uchar,
        buflen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Import X from unsigned binary data, little endian\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param buf      The input buffer. This must be a readable buffer of length\n                 \\p buflen Bytes.\n \\param buflen   The length of the input buffer \\p p in Bytes.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_read_binary_le(
        X: *mut mbedtls_mpi,
        buf: *const crate::c_types::c_uchar,
        buflen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Export X into unsigned binary data, big endian.\n                 Always fills the whole buffer, which will start with zeros\n                 if the number is smaller.\n\n \\param X        The source MPI. This must point to an initialized MPI.\n \\param buf      The output buffer. This must be a writable buffer of length\n                 \\p buflen Bytes.\n \\param buflen   The size of the output buffer \\p buf in Bytes.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL if \\p buf isn't\n                 large enough to hold the value of \\p X.\n \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_write_binary(
        X: *const mbedtls_mpi,
        buf: *mut crate::c_types::c_uchar,
        buflen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Export X into unsigned binary data, little endian.\n                 Always fills the whole buffer, which will end with zeros\n                 if the number is smaller.\n\n \\param X        The source MPI. This must point to an initialized MPI.\n \\param buf      The output buffer. This must be a writable buffer of length\n                 \\p buflen Bytes.\n \\param buflen   The size of the output buffer \\p buf in Bytes.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL if \\p buf isn't\n                 large enough to hold the value of \\p X.\n \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_write_binary_le(
        X: *const mbedtls_mpi,
        buf: *mut crate::c_types::c_uchar,
        buflen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a left-shift on an MPI: X <<= count\n\n \\param X        The MPI to shift. This must point to an initialized MPI.\n \\param count    The number of bits to shift by.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_shift_l(X: *mut mbedtls_mpi, count: usize) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a right-shift on an MPI: X >>= count\n\n \\param X        The MPI to shift. This must point to an initialized MPI.\n \\param count    The number of bits to shift by.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_shift_r(X: *mut mbedtls_mpi, count: usize) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Compare the absolute values of two MPIs.\n\n \\param X        The left-hand MPI. This must point to an initialized MPI.\n \\param Y        The right-hand MPI. This must point to an initialized MPI.\n\n \\return         \\c 1 if `|X|` is greater than `|Y|`.\n \\return         \\c -1 if `|X|` is lesser than `|Y|`.\n \\return         \\c 0 if `|X|` is equal to `|Y|`."]
    pub fn mbedtls_mpi_cmp_abs(
        X: *const mbedtls_mpi,
        Y: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Compare two MPIs.\n\n \\param X        The left-hand MPI. This must point to an initialized MPI.\n \\param Y        The right-hand MPI. This must point to an initialized MPI.\n\n \\return         \\c 1 if \\p X is greater than \\p Y.\n \\return         \\c -1 if \\p X is lesser than \\p Y.\n \\return         \\c 0 if \\p X is equal to \\p Y."]
    pub fn mbedtls_mpi_cmp_mpi(
        X: *const mbedtls_mpi,
        Y: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Check if an MPI is less than the other in constant time.\n\n \\param X        The left-hand MPI. This must point to an initialized MPI\n                 with the same allocated length as Y.\n \\param Y        The right-hand MPI. This must point to an initialized MPI\n                 with the same allocated length as X.\n \\param ret      The result of the comparison:\n                 \\c 1 if \\p X is less than \\p Y.\n                 \\c 0 if \\p X is greater than or equal to \\p Y.\n\n \\return         0 on success.\n \\return         MBEDTLS_ERR_MPI_BAD_INPUT_DATA if the allocated length of\n                 the two input MPIs is not the same."]
    pub fn mbedtls_mpi_lt_mpi_ct(
        X: *const mbedtls_mpi,
        Y: *const mbedtls_mpi,
        ret: *mut crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Compare an MPI with an integer.\n\n \\param X        The left-hand MPI. This must point to an initialized MPI.\n \\param z        The integer value to compare \\p X to.\n\n \\return         \\c 1 if \\p X is greater than \\p z.\n \\return         \\c -1 if \\p X is lesser than \\p z.\n \\return         \\c 0 if \\p X is equal to \\p z."]
    pub fn mbedtls_mpi_cmp_int(X: *const mbedtls_mpi, z: mbedtls_mpi_sint)
        -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform an unsigned addition of MPIs: X = |A| + |B|\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param A        The first summand. This must point to an initialized MPI.\n \\param B        The second summand. This must point to an initialized MPI.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_add_abs(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform an unsigned subtraction of MPIs: X = |A| - |B|\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param A        The minuend. This must point to an initialized MPI.\n \\param B        The subtrahend. This must point to an initialized MPI.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_NEGATIVE_VALUE if \\p B is greater than \\p A.\n \\return         Another negative error code on different kinds of failure.\n"]
    pub fn mbedtls_mpi_sub_abs(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a signed addition of MPIs: X = A + B\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param A        The first summand. This must point to an initialized MPI.\n \\param B        The second summand. This must point to an initialized MPI.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_add_mpi(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a signed subtraction of MPIs: X = A - B\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param A        The minuend. This must point to an initialized MPI.\n \\param B        The subtrahend. This must point to an initialized MPI.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_sub_mpi(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a signed addition of an MPI and an integer: X = A + b\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param A        The first summand. This must point to an initialized MPI.\n \\param b        The second summand.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_add_int(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        b: mbedtls_mpi_sint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a signed subtraction of an MPI and an integer:\n                 X = A - b\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param A        The minuend. This must point to an initialized MPI.\n \\param b        The subtrahend.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_sub_int(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        b: mbedtls_mpi_sint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a multiplication of two MPIs: X = A * B\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param A        The first factor. This must point to an initialized MPI.\n \\param B        The second factor. This must point to an initialized MPI.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on different kinds of failure.\n"]
    pub fn mbedtls_mpi_mul_mpi(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a multiplication of an MPI with an unsigned integer:\n                 X = A * b\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param A        The first factor. This must point to an initialized MPI.\n \\param b        The second factor.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on different kinds of failure.\n"]
    pub fn mbedtls_mpi_mul_int(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        b: mbedtls_mpi_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a division with remainder of two MPIs:\n                 A = Q * B + R\n\n \\param Q        The destination MPI for the quotient.\n                 This may be \\c NULL if the value of the\n                 quotient is not needed. This must not alias A or B.\n \\param R        The destination MPI for the remainder value.\n                 This may be \\c NULL if the value of the\n                 remainder is not needed. This must not alias A or B.\n \\param A        The dividend. This must point to an initialized MPI.\n \\param B        The divisor. This must point to an initialized MPI.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return         #MBEDTLS_ERR_MPI_DIVISION_BY_ZERO if \\p B equals zero.\n \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_div_mpi(
        Q: *mut mbedtls_mpi,
        R: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a division with remainder of an MPI by an integer:\n                 A = Q * b + R\n\n \\param Q        The destination MPI for the quotient.\n                 This may be \\c NULL if the value of the\n                 quotient is not needed.  This must not alias A.\n \\param R        The destination MPI for the remainder value.\n                 This may be \\c NULL if the value of the\n                 remainder is not needed.  This must not alias A.\n \\param A        The dividend. This must point to an initialized MPi.\n \\param b        The divisor.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return         #MBEDTLS_ERR_MPI_DIVISION_BY_ZERO if \\p b equals zero.\n \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_div_int(
        Q: *mut mbedtls_mpi,
        R: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        b: mbedtls_mpi_sint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a modular reduction. R = A mod B\n\n \\param R        The destination MPI for the residue value.\n                 This must point to an initialized MPI.\n \\param A        The MPI to compute the residue of.\n                 This must point to an initialized MPI.\n \\param B        The base of the modular reduction.\n                 This must point to an initialized MPI.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         #MBEDTLS_ERR_MPI_DIVISION_BY_ZERO if \\p B equals zero.\n \\return         #MBEDTLS_ERR_MPI_NEGATIVE_VALUE if \\p B is negative.\n \\return         Another negative error code on different kinds of failure.\n"]
    pub fn mbedtls_mpi_mod_mpi(
        R: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a modular reduction with respect to an integer.\n                 r = A mod b\n\n \\param r        The address at which to store the residue.\n                 This must not be \\c NULL.\n \\param A        The MPI to compute the residue of.\n                 This must point to an initialized MPi.\n \\param b        The integer base of the modular reduction.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         #MBEDTLS_ERR_MPI_DIVISION_BY_ZERO if \\p b equals zero.\n \\return         #MBEDTLS_ERR_MPI_NEGATIVE_VALUE if \\p b is negative.\n \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_mod_int(
        r: *mut mbedtls_mpi_uint,
        A: *const mbedtls_mpi,
        b: mbedtls_mpi_sint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a sliding-window exponentiation: X = A^E mod N\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n                 This must not alias E or N.\n \\param A        The base of the exponentiation.\n                 This must point to an initialized MPI.\n \\param E        The exponent MPI. This must point to an initialized MPI.\n \\param N        The base for the modular reduction. This must point to an\n                 initialized MPI.\n \\param prec_RR  A helper MPI depending solely on \\p N which can be used to\n                 speed-up multiple modular exponentiations for the same value\n                 of \\p N. This may be \\c NULL. If it is not \\c NULL, it must\n                 point to an initialized MPI. If it hasn't been used after\n                 the call to mbedtls_mpi_init(), this function will compute\n                 the helper value and store it in \\p prec_RR for reuse on\n                 subsequent calls to this function. Otherwise, the function\n                 will assume that \\p prec_RR holds the helper value set by a\n                 previous call to mbedtls_mpi_exp_mod(), and reuse it.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         #MBEDTLS_ERR_MPI_BAD_INPUT_DATA if \\c N is negative or\n                 even, or if \\c E is negative.\n \\return         Another negative error code on different kinds of failures.\n"]
    pub fn mbedtls_mpi_exp_mod(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        E: *const mbedtls_mpi,
        N: *const mbedtls_mpi,
        prec_RR: *mut mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Fill an MPI with a number of random bytes.\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param size     The number of random bytes to generate.\n \\param f_rng    The RNG function to use. This must not be \\c NULL.\n \\param p_rng    The RNG parameter to be passed to \\p f_rng. This may be\n                 \\c NULL if \\p f_rng doesn't need a context argument.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on failure.\n\n \\note           The bytes obtained from the RNG are interpreted\n                 as a big-endian representation of an MPI; this can\n                 be relevant in applications like deterministic ECDSA."]
    pub fn mbedtls_mpi_fill_random(
        X: *mut mbedtls_mpi,
        size: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " Generate a random number uniformly in a range.\n\n This function generates a random number between \\p min inclusive and\n \\p N exclusive.\n\n The procedure complies with RFC 6979 §3.3 (deterministic ECDSA)\n when the RNG is a suitably parametrized instance of HMAC_DRBG\n and \\p min is \\c 1.\n\n \\note           There are `N - min` possible outputs. The lower bound\n                 \\p min can be reached, but the upper bound \\p N cannot.\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param min      The minimum value to return.\n                 It must be nonnegative.\n \\param N        The upper bound of the range, exclusive.\n                 In other words, this is one plus the maximum value to return.\n                 \\p N must be strictly larger than \\p min.\n \\param f_rng    The RNG function to use. This must not be \\c NULL.\n \\param p_rng    The RNG parameter to be passed to \\p f_rng.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         #MBEDTLS_ERR_MPI_BAD_INPUT_DATA if \\p min or \\p N is invalid\n                 or if they are incompatible.\n \\return         #MBEDTLS_ERR_MPI_NOT_ACCEPTABLE if the implementation was\n                 unable to find a suitable value within a limited number\n                 of attempts. This has a negligible probability if \\p N\n                 is significantly larger than \\p min, which is the case\n                 for all usual cryptographic applications.\n \\return         Another negative error code on failure."]
    pub fn mbedtls_mpi_random(
        X: *mut mbedtls_mpi,
        min: mbedtls_mpi_sint,
        N: *const mbedtls_mpi,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Compute the greatest common divisor: G = gcd(A, B)\n\n \\param G        The destination MPI. This must point to an initialized MPI.\n \\param A        The first operand. This must point to an initialized MPI.\n \\param B        The second operand. This must point to an initialized MPI.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on different kinds of failure."]
    pub fn mbedtls_mpi_gcd(
        G: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        B: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Compute the modular inverse: X = A^-1 mod N\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param A        The MPI to calculate the modular inverse of. This must point\n                 to an initialized MPI.\n \\param N        The base of the modular inversion. This must point to an\n                 initialized MPI.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         #MBEDTLS_ERR_MPI_BAD_INPUT_DATA if \\p N is less than\n                 or equal to one.\n \\return         #MBEDTLS_ERR_MPI_NOT_ACCEPTABLE if \\p has no modular inverse\n                 with respect to \\p N."]
    pub fn mbedtls_mpi_inv_mod(
        X: *mut mbedtls_mpi,
        A: *const mbedtls_mpi,
        N: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Miller-Rabin primality test.\n\n \\warning        If \\p X is potentially generated by an adversary, for example\n                 when validating cryptographic parameters that you didn't\n                 generate yourself and that are supposed to be prime, then\n                 \\p rounds should be at least the half of the security\n                 strength of the cryptographic algorithm. On the other hand,\n                 if \\p X is chosen uniformly or non-adversarially (as is the\n                 case when mbedtls_mpi_gen_prime calls this function), then\n                 \\p rounds can be much lower.\n\n \\param X        The MPI to check for primality.\n                 This must point to an initialized MPI.\n \\param rounds   The number of bases to perform the Miller-Rabin primality\n                 test for. The probability of returning 0 on a composite is\n                 at most 2<sup>-2*\\p rounds</sup>.\n \\param f_rng    The RNG function to use. This must not be \\c NULL.\n \\param p_rng    The RNG parameter to be passed to \\p f_rng.\n                 This may be \\c NULL if \\p f_rng doesn't use\n                 a context parameter.\n\n \\return         \\c 0 if successful, i.e. \\p X is probably prime.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         #MBEDTLS_ERR_MPI_NOT_ACCEPTABLE if \\p X is not prime.\n \\return         Another negative error code on other kinds of failure."]
    pub fn mbedtls_mpi_is_prime_ext(
        X: *const mbedtls_mpi,
        rounds: crate::c_types::c_int,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
#[doc = "< (X-1)/2 is prime too"]
pub const mbedtls_mpi_gen_prime_flag_t_MBEDTLS_MPI_GEN_PRIME_FLAG_DH: mbedtls_mpi_gen_prime_flag_t =
    1;
#[doc = "< lower error rate from 2<sup>-80</sup> to 2<sup>-128</sup>"]
pub const mbedtls_mpi_gen_prime_flag_t_MBEDTLS_MPI_GEN_PRIME_FLAG_LOW_ERR:
    mbedtls_mpi_gen_prime_flag_t = 2;
#[doc = " \\brief Flags for mbedtls_mpi_gen_prime()\n\n Each of these flags is a constraint on the result X returned by\n mbedtls_mpi_gen_prime()."]
pub type mbedtls_mpi_gen_prime_flag_t = crate::c_types::c_uint;
extern "C" {
    #[doc = " \\brief          Generate a prime number.\n\n \\param X        The destination MPI to store the generated prime in.\n                 This must point to an initialized MPi.\n \\param nbits    The required size of the destination MPI in bits.\n                 This must be between \\c 3 and #MBEDTLS_MPI_MAX_BITS.\n \\param flags    A mask of flags of type #mbedtls_mpi_gen_prime_flag_t.\n \\param f_rng    The RNG function to use. This must not be \\c NULL.\n \\param p_rng    The RNG parameter to be passed to \\p f_rng.\n                 This may be \\c NULL if \\p f_rng doesn't use\n                 a context parameter.\n\n \\return         \\c 0 if successful, in which case \\p X holds a\n                 probably prime number.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         #MBEDTLS_ERR_MPI_BAD_INPUT_DATA if `nbits` is not between\n                 \\c 3 and #MBEDTLS_MPI_MAX_BITS."]
    pub fn mbedtls_mpi_gen_prime(
        X: *mut mbedtls_mpi,
        nbits: usize,
        flags: crate::c_types::c_int,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Checkup routine\n\n \\return         0 if successful, or 1 if the test failed"]
    pub fn mbedtls_mpi_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[doc = "< Curve not defined."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_NONE: mbedtls_ecp_group_id = 0;
#[doc = "< Domain parameters for the 192-bit curve defined by FIPS 186-4 and SEC1."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP192R1: mbedtls_ecp_group_id = 1;
#[doc = "< Domain parameters for the 224-bit curve defined by FIPS 186-4 and SEC1."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP224R1: mbedtls_ecp_group_id = 2;
#[doc = "< Domain parameters for the 256-bit curve defined by FIPS 186-4 and SEC1."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP256R1: mbedtls_ecp_group_id = 3;
#[doc = "< Domain parameters for the 384-bit curve defined by FIPS 186-4 and SEC1."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP384R1: mbedtls_ecp_group_id = 4;
#[doc = "< Domain parameters for the 521-bit curve defined by FIPS 186-4 and SEC1."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP521R1: mbedtls_ecp_group_id = 5;
#[doc = "< Domain parameters for 256-bit Brainpool curve."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_BP256R1: mbedtls_ecp_group_id = 6;
#[doc = "< Domain parameters for 384-bit Brainpool curve."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_BP384R1: mbedtls_ecp_group_id = 7;
#[doc = "< Domain parameters for 512-bit Brainpool curve."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_BP512R1: mbedtls_ecp_group_id = 8;
#[doc = "< Domain parameters for Curve25519."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_CURVE25519: mbedtls_ecp_group_id = 9;
#[doc = "< Domain parameters for 192-bit \"Koblitz\" curve."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP192K1: mbedtls_ecp_group_id = 10;
#[doc = "< Domain parameters for 224-bit \"Koblitz\" curve."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP224K1: mbedtls_ecp_group_id = 11;
#[doc = "< Domain parameters for 256-bit \"Koblitz\" curve."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP256K1: mbedtls_ecp_group_id = 12;
#[doc = "< Domain parameters for Curve448."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_CURVE448: mbedtls_ecp_group_id = 13;
#[doc = " Domain-parameter identifiers: curve, subgroup, and generator.\n\n \\note Only curves over prime fields are supported.\n\n \\warning This library does not support validation of arbitrary domain\n parameters. Therefore, only standardized domain parameters from trusted\n sources should be used. See mbedtls_ecp_group_load()."]
pub type mbedtls_ecp_group_id = crate::c_types::c_uint;
pub const mbedtls_ecp_curve_type_MBEDTLS_ECP_TYPE_NONE: mbedtls_ecp_curve_type = 0;
pub const mbedtls_ecp_curve_type_MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS: mbedtls_ecp_curve_type = 1;
pub const mbedtls_ecp_curve_type_MBEDTLS_ECP_TYPE_MONTGOMERY: mbedtls_ecp_curve_type = 2;
pub type mbedtls_ecp_curve_type = crate::c_types::c_uint;
pub const mbedtls_ecp_modulus_type_MBEDTLS_ECP_MOD_NONE: mbedtls_ecp_modulus_type = 0;
pub const mbedtls_ecp_modulus_type_MBEDTLS_ECP_MOD_COORDINATE: mbedtls_ecp_modulus_type = 1;
pub const mbedtls_ecp_modulus_type_MBEDTLS_ECP_MOD_SCALAR: mbedtls_ecp_modulus_type = 2;
pub type mbedtls_ecp_modulus_type = crate::c_types::c_uint;
#[doc = " Curve information, for use by other modules.\n\n The fields of this structure are part of the public API and can be\n accessed directly by applications. Future versions of the library may\n add extra fields or reorder existing fields."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ecp_curve_info {
    #[doc = "< An internal identifier."]
    pub grp_id: mbedtls_ecp_group_id,
    #[doc = "< The TLS NamedCurve identifier."]
    pub tls_id: u16,
    #[doc = "< The curve size in bits."]
    pub bit_size: u16,
    #[doc = "< A human-friendly name."]
    pub name: *const crate::c_types::c_char,
}
#[doc = " \\brief           The ECP point structure, in Jacobian coordinates.\n\n \\note            All functions expect and return points satisfying\n                  the following condition: <code>Z == 0</code> or\n                  <code>Z == 1</code>. Other values of \\p Z are\n                  used only by internal functions.\n                  The point is zero, or \"at infinity\", if <code>Z == 0</code>.\n                  Otherwise, \\p X and \\p Y are its standard (affine)\n                  coordinates."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ecp_point {
    pub private_X: mbedtls_mpi,
    pub private_Y: mbedtls_mpi,
    pub private_Z: mbedtls_mpi,
}
#[doc = " \\brief           The ECP group structure.\n\n We consider two types of curve equations:\n <ul><li>Short Weierstrass: <code>y^2 = x^3 + A x + B mod P</code>\n (SEC1 + RFC-4492)</li>\n <li>Montgomery: <code>y^2 = x^3 + A x^2 + x mod P</code> (Curve25519,\n Curve448)</li></ul>\n In both cases, the generator (\\p G) for a prime-order subgroup is fixed.\n\n For Short Weierstrass, this subgroup is the whole curve, and its\n cardinality is denoted by \\p N. Our code requires that \\p N is an\n odd prime as mbedtls_ecp_mul() requires an odd number, and\n mbedtls_ecdsa_sign() requires that it is prime for blinding purposes.\n\n For Montgomery curves, we do not store \\p A, but <code>(A + 2) / 4</code>,\n which is the quantity used in the formulas. Additionally, \\p nbits is\n not the size of \\p N but the required size for private keys.\n\n If \\p modp is NULL, reduction modulo \\p P is done using a generic algorithm.\n Otherwise, \\p modp must point to a function that takes an \\p mbedtls_mpi in the\n range of <code>0..2^(2*pbits)-1</code>, and transforms it in-place to an integer\n which is congruent mod \\p P to the given MPI, and is close enough to \\p pbits\n in size, so that it may be efficiently brought in the 0..P-1 range by a few\n additions or subtractions. Therefore, it is only an approximative modular\n reduction. It must return 0 on success and non-zero on failure.\n\n \\note        Alternative implementations of the ECP module must obey the\n              following constraints.\n              * Group IDs must be distinct: if two group structures have\n                the same ID, then they must be identical.\n              * The fields \\c id, \\c P, \\c A, \\c B, \\c G, \\c N,\n                \\c pbits and \\c nbits must have the same type and semantics\n                as in the built-in implementation.\n                They must be available for reading, but direct modification\n                of these fields does not need to be supported.\n                They do not need to be at the same offset in the structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ecp_group {
    #[doc = "< An internal group identifier."]
    pub id: mbedtls_ecp_group_id,
    #[doc = "< The prime modulus of the base field."]
    pub P: mbedtls_mpi,
    #[doc = "< For Short Weierstrass: \\p A in the equation. For\nMontgomery curves: <code>(A + 2) / 4</code>."]
    pub A: mbedtls_mpi,
    #[doc = "< For Short Weierstrass: \\p B in the equation.\nFor Montgomery curves: unused."]
    pub B: mbedtls_mpi,
    #[doc = "< The generator of the subgroup used."]
    pub G: mbedtls_ecp_point,
    #[doc = "< The order of \\p G."]
    pub N: mbedtls_mpi,
    #[doc = "< The number of bits in \\p P."]
    pub pbits: usize,
    #[doc = "< For Short Weierstrass: The number of bits in \\p P.\nFor Montgomery curves: the number of bits in the\nprivate keys."]
    pub nbits: usize,
    pub private_h: crate::c_types::c_uint,
    pub private_modp: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut mbedtls_mpi) -> crate::c_types::c_int,
    >,
    pub private_t_pre: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mbedtls_ecp_point,
            arg2: *mut crate::c_types::c_void,
        ) -> crate::c_types::c_int,
    >,
    pub private_t_post: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut mbedtls_ecp_point,
            arg2: *mut crate::c_types::c_void,
        ) -> crate::c_types::c_int,
    >,
    pub private_t_data: *mut crate::c_types::c_void,
    pub private_T: *mut mbedtls_ecp_point,
    pub private_T_size: usize,
}
pub type mbedtls_ecp_restart_ctx = crate::c_types::c_void;
#[doc = " \\brief    The ECP key-pair structure.\n\n A generic key-pair that may be used for ECDSA and fixed ECDH, for example.\n\n \\note    Members are deliberately in the same order as in the\n          ::mbedtls_ecdsa_context structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ecp_keypair {
    pub private_grp: mbedtls_ecp_group,
    pub private_d: mbedtls_mpi,
    pub private_Q: mbedtls_ecp_point,
}
extern "C" {
    pub fn mbedtls_ecp_get_type(grp: *const mbedtls_ecp_group) -> mbedtls_ecp_curve_type;
}
extern "C" {
    #[doc = " \\brief           This function retrieves the information defined in\n                  mbedtls_ecp_curve_info() for all supported curves.\n\n \\note            This function returns information about all curves\n                  supported by the library. Some curves may not be\n                  supported for all algorithms. Call mbedtls_ecdh_can_do()\n                  or mbedtls_ecdsa_can_do() to check if a curve is\n                  supported for ECDH or ECDSA.\n\n \\return          A statically allocated array. The last entry is 0."]
    pub fn mbedtls_ecp_curve_list() -> *const mbedtls_ecp_curve_info;
}
extern "C" {
    #[doc = " \\brief           This function retrieves the list of internal group\n                  identifiers of all supported curves in the order of\n                  preference.\n\n \\note            This function returns information about all curves\n                  supported by the library. Some curves may not be\n                  supported for all algorithms. Call mbedtls_ecdh_can_do()\n                  or mbedtls_ecdsa_can_do() to check if a curve is\n                  supported for ECDH or ECDSA.\n\n \\return          A statically allocated array,\n                  terminated with MBEDTLS_ECP_DP_NONE."]
    pub fn mbedtls_ecp_grp_id_list() -> *const mbedtls_ecp_group_id;
}
extern "C" {
    #[doc = " \\brief           This function retrieves curve information from an internal\n                  group identifier.\n\n \\param grp_id    An \\c MBEDTLS_ECP_DP_XXX value.\n\n \\return          The associated curve information on success.\n \\return          NULL on failure."]
    pub fn mbedtls_ecp_curve_info_from_grp_id(
        grp_id: mbedtls_ecp_group_id,
    ) -> *const mbedtls_ecp_curve_info;
}
extern "C" {
    #[doc = " \\brief           This function retrieves curve information from a TLS\n                  NamedCurve value.\n\n \\param tls_id    An \\c MBEDTLS_ECP_DP_XXX value.\n\n \\return          The associated curve information on success.\n \\return          NULL on failure."]
    pub fn mbedtls_ecp_curve_info_from_tls_id(tls_id: u16) -> *const mbedtls_ecp_curve_info;
}
extern "C" {
    #[doc = " \\brief           This function retrieves curve information from a\n                  human-readable name.\n\n \\param name      The human-readable name.\n\n \\return          The associated curve information on success.\n \\return          NULL on failure."]
    pub fn mbedtls_ecp_curve_info_from_name(
        name: *const crate::c_types::c_char,
    ) -> *const mbedtls_ecp_curve_info;
}
extern "C" {
    #[doc = " \\brief           This function initializes a point as zero.\n\n \\param pt        The point to initialize."]
    pub fn mbedtls_ecp_point_init(pt: *mut mbedtls_ecp_point);
}
extern "C" {
    #[doc = " \\brief           This function initializes an ECP group context\n                  without loading any domain parameters.\n\n \\note            After this function is called, domain parameters\n                  for various ECP groups can be loaded through the\n                  mbedtls_ecp_group_load() or mbedtls_ecp_tls_read_group()\n                  functions."]
    pub fn mbedtls_ecp_group_init(grp: *mut mbedtls_ecp_group);
}
extern "C" {
    #[doc = " \\brief           This function initializes a key pair as an invalid one.\n\n \\param key       The key pair to initialize."]
    pub fn mbedtls_ecp_keypair_init(key: *mut mbedtls_ecp_keypair);
}
extern "C" {
    #[doc = " \\brief           This function frees the components of a point.\n\n \\param pt        The point to free."]
    pub fn mbedtls_ecp_point_free(pt: *mut mbedtls_ecp_point);
}
extern "C" {
    #[doc = " \\brief           This function frees the components of an ECP group.\n\n \\param grp       The group to free. This may be \\c NULL, in which\n                  case this function returns immediately. If it is not\n                  \\c NULL, it must point to an initialized ECP group."]
    pub fn mbedtls_ecp_group_free(grp: *mut mbedtls_ecp_group);
}
extern "C" {
    #[doc = " \\brief           This function frees the components of a key pair.\n\n \\param key       The key pair to free. This may be \\c NULL, in which\n                  case this function returns immediately. If it is not\n                  \\c NULL, it must point to an initialized ECP key pair."]
    pub fn mbedtls_ecp_keypair_free(key: *mut mbedtls_ecp_keypair);
}
extern "C" {
    #[doc = " \\brief           This function copies the contents of point \\p Q into\n                  point \\p P.\n\n \\param P         The destination point. This must be initialized.\n \\param Q         The source point. This must be initialized.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.\n \\return          Another negative error code for other kinds of failure."]
    pub fn mbedtls_ecp_copy(
        P: *mut mbedtls_ecp_point,
        Q: *const mbedtls_ecp_point,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function copies the contents of group \\p src into\n                  group \\p dst.\n\n \\param dst       The destination group. This must be initialized.\n \\param src       The source group. This must be initialized.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_group_copy(
        dst: *mut mbedtls_ecp_group,
        src: *const mbedtls_ecp_group,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets a point to the point at infinity.\n\n \\param pt        The point to set. This must be initialized.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_set_zero(pt: *mut mbedtls_ecp_point) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function checks if a point is the point at infinity.\n\n \\param pt        The point to test. This must be initialized.\n\n \\return          \\c 1 if the point is zero.\n \\return          \\c 0 if the point is non-zero.\n \\return          A negative error code on failure."]
    pub fn mbedtls_ecp_is_zero(pt: *mut mbedtls_ecp_point) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function compares two points.\n\n \\note            This assumes that the points are normalized. Otherwise,\n                  they may compare as \"not equal\" even if they are.\n\n \\param P         The first point to compare. This must be initialized.\n \\param Q         The second point to compare. This must be initialized.\n\n \\return          \\c 0 if the points are equal.\n \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the points are not equal."]
    pub fn mbedtls_ecp_point_cmp(
        P: *const mbedtls_ecp_point,
        Q: *const mbedtls_ecp_point,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function imports a non-zero point from two ASCII\n                  strings.\n\n \\param P         The destination point. This must be initialized.\n \\param radix     The numeric base of the input.\n \\param x         The first affine coordinate, as a null-terminated string.\n \\param y         The second affine coordinate, as a null-terminated string.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_MPI_XXX error code on failure."]
    pub fn mbedtls_ecp_point_read_string(
        P: *mut mbedtls_ecp_point,
        radix: crate::c_types::c_int,
        x: *const crate::c_types::c_char,
        y: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function exports a point into unsigned binary data.\n\n \\param grp       The group to which the point should belong.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param P         The point to export. This must be initialized.\n \\param format    The point format. This must be either\n                  #MBEDTLS_ECP_PF_COMPRESSED or #MBEDTLS_ECP_PF_UNCOMPRESSED.\n                  (For groups without these formats, this parameter is\n                  ignored. But it still has to be either of the above\n                  values.)\n \\param olen      The address at which to store the length of\n                  the output in Bytes. This must not be \\c NULL.\n \\param buf       The output buffer. This must be a writable buffer\n                  of length \\p buflen Bytes.\n \\param buflen    The length of the output buffer \\p buf in Bytes.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL if the output buffer\n                  is too small to hold the point.\n \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the point format\n                  or the export for the given group is not implemented.\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_point_write_binary(
        grp: *const mbedtls_ecp_group,
        P: *const mbedtls_ecp_point,
        format: crate::c_types::c_int,
        olen: *mut usize,
        buf: *mut crate::c_types::c_uchar,
        buflen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function imports a point from unsigned binary data.\n\n \\note            This function does not check that the point actually\n                  belongs to the given group, see mbedtls_ecp_check_pubkey()\n                  for that.\n\n \\note            For compressed points, see #MBEDTLS_ECP_PF_COMPRESSED for\n                  limitations.\n\n \\param grp       The group to which the point should belong.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param P         The destination context to import the point to.\n                  This must be initialized.\n \\param buf       The input buffer. This must be a readable buffer\n                  of length \\p ilen Bytes.\n \\param ilen      The length of the input buffer \\p buf in Bytes.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the input is invalid.\n \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.\n \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the import for the\n                  given group is not implemented."]
    pub fn mbedtls_ecp_point_read_binary(
        grp: *const mbedtls_ecp_group,
        P: *mut mbedtls_ecp_point,
        buf: *const crate::c_types::c_uchar,
        ilen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function imports a point from a TLS ECPoint record.\n\n \\note            On function return, \\p *buf is updated to point immediately\n                  after the ECPoint record.\n\n \\param grp       The ECP group to use.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param pt        The destination point.\n \\param buf       The address of the pointer to the start of the input buffer.\n \\param len       The length of the buffer.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_MPI_XXX error code on initialization\n                  failure.\n \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if input is invalid."]
    pub fn mbedtls_ecp_tls_read_point(
        grp: *const mbedtls_ecp_group,
        pt: *mut mbedtls_ecp_point,
        buf: *mut *const crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function exports a point as a TLS ECPoint record\n                  defined in RFC 4492, Section 5.4.\n\n \\param grp       The ECP group to use.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param pt        The point to be exported. This must be initialized.\n \\param format    The point format to use. This must be either\n                  #MBEDTLS_ECP_PF_COMPRESSED or #MBEDTLS_ECP_PF_UNCOMPRESSED.\n \\param olen      The address at which to store the length in Bytes\n                  of the data written.\n \\param buf       The target buffer. This must be a writable buffer of\n                  length \\p blen Bytes.\n \\param blen      The length of the target buffer \\p buf in Bytes.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the input is invalid.\n \\return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL if the target buffer\n                  is too small to hold the exported point.\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_tls_write_point(
        grp: *const mbedtls_ecp_group,
        pt: *const mbedtls_ecp_point,
        format: crate::c_types::c_int,
        olen: *mut usize,
        buf: *mut crate::c_types::c_uchar,
        blen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets up an ECP group context\n                  from a standardized set of domain parameters.\n\n \\note            The index should be a value of the NamedCurve enum,\n                  as defined in <em>RFC-4492: Elliptic Curve Cryptography\n                  (ECC) Cipher Suites for Transport Layer Security (TLS)</em>,\n                  usually in the form of an \\c MBEDTLS_ECP_DP_XXX macro.\n\n \\param grp       The group context to setup. This must be initialized.\n \\param id        The identifier of the domain parameter set to load.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if \\p id doesn't\n                  correspond to a known group.\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_group_load(
        grp: *mut mbedtls_ecp_group,
        id: mbedtls_ecp_group_id,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets up an ECP group context from a TLS\n                  ECParameters record as defined in RFC 4492, Section 5.4.\n\n \\note            The read pointer \\p buf is updated to point right after\n                  the ECParameters record on exit.\n\n \\param grp       The group context to setup. This must be initialized.\n \\param buf       The address of the pointer to the start of the input buffer.\n \\param len       The length of the input buffer \\c *buf in Bytes.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if input is invalid.\n \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the group is not\n                  recognized.\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_tls_read_group(
        grp: *mut mbedtls_ecp_group,
        buf: *mut *const crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function extracts an elliptic curve group ID from a\n                  TLS ECParameters record as defined in RFC 4492, Section 5.4.\n\n \\note            The read pointer \\p buf is updated to point right after\n                  the ECParameters record on exit.\n\n \\param grp       The address at which to store the group id.\n                  This must not be \\c NULL.\n \\param buf       The address of the pointer to the start of the input buffer.\n \\param len       The length of the input buffer \\c *buf in Bytes.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if input is invalid.\n \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the group is not\n                  recognized.\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_tls_read_group_id(
        grp: *mut mbedtls_ecp_group_id,
        buf: *mut *const crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function exports an elliptic curve as a TLS\n                  ECParameters record as defined in RFC 4492, Section 5.4.\n\n \\param grp       The ECP group to be exported.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param olen      The address at which to store the number of Bytes written.\n                  This must not be \\c NULL.\n \\param buf       The buffer to write to. This must be a writable buffer\n                  of length \\p blen Bytes.\n \\param blen      The length of the output buffer \\p buf in Bytes.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL if the output\n                  buffer is too small to hold the exported group.\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_tls_write_group(
        grp: *const mbedtls_ecp_group,
        olen: *mut usize,
        buf: *mut crate::c_types::c_uchar,
        blen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs a scalar multiplication of a point\n                  by an integer: \\p R = \\p m * \\p P.\n\n                  It is not thread-safe to use same group in multiple threads.\n\n \\note            To prevent timing attacks, this function\n                  executes the exact same sequence of base-field\n                  operations for any valid \\p m. It avoids any if-branch or\n                  array index depending on the value of \\p m. It also uses\n                  \\p f_rng to randomize some intermediate results.\n\n \\param grp       The ECP group to use.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param R         The point in which to store the result of the calculation.\n                  This must be initialized.\n \\param m         The integer by which to multiply. This must be initialized.\n \\param P         The point to multiply. This must be initialized.\n \\param f_rng     The RNG function. This must not be \\c NULL.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may be \\c\n                  NULL if \\p f_rng doesn't need a context.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_INVALID_KEY if \\p m is not a valid private\n                  key, or \\p P is not a valid public key.\n \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_mul(
        grp: *mut mbedtls_ecp_group,
        R: *mut mbedtls_ecp_point,
        m: *const mbedtls_mpi,
        P: *const mbedtls_ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs multiplication of a point by\n                  an integer: \\p R = \\p m * \\p P in a restartable way.\n\n \\see             mbedtls_ecp_mul()\n\n \\note            This function does the same as \\c mbedtls_ecp_mul(), but\n                  it can return early and restart according to the limit set\n                  with \\c mbedtls_ecp_set_max_ops() to reduce blocking.\n\n \\param grp       The ECP group to use.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param R         The point in which to store the result of the calculation.\n                  This must be initialized.\n \\param m         The integer by which to multiply. This must be initialized.\n \\param P         The point to multiply. This must be initialized.\n \\param f_rng     The RNG function. This must not be \\c NULL.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may be \\c\n                  NULL if \\p f_rng doesn't need a context.\n \\param rs_ctx    The restart context (NULL disables restart).\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_INVALID_KEY if \\p m is not a valid private\n                  key, or \\p P is not a valid public key.\n \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.\n \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of\n                  operations was reached: see \\c mbedtls_ecp_set_max_ops().\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_mul_restartable(
        grp: *mut mbedtls_ecp_group,
        R: *mut mbedtls_ecp_point,
        m: *const mbedtls_mpi,
        P: *const mbedtls_ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        rs_ctx: *mut mbedtls_ecp_restart_ctx,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs multiplication and addition of two\n                  points by integers: \\p R = \\p m * \\p P + \\p n * \\p Q\n\n                  It is not thread-safe to use same group in multiple threads.\n\n \\note            In contrast to mbedtls_ecp_mul(), this function does not\n                  guarantee a constant execution flow and timing.\n\n \\note            This function is only defined for short Weierstrass curves.\n                  It may not be included in builds without any short\n                  Weierstrass curve.\n\n \\param grp       The ECP group to use.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param R         The point in which to store the result of the calculation.\n                  This must be initialized.\n \\param m         The integer by which to multiply \\p P.\n                  This must be initialized.\n \\param P         The point to multiply by \\p m. This must be initialized.\n \\param n         The integer by which to multiply \\p Q.\n                  This must be initialized.\n \\param Q         The point to be multiplied by \\p n.\n                  This must be initialized.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_INVALID_KEY if \\p m or \\p n are not\n                  valid private keys, or \\p P or \\p Q are not valid public\n                  keys.\n \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.\n \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if \\p grp does not\n                  designate a short Weierstrass curve.\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_muladd(
        grp: *mut mbedtls_ecp_group,
        R: *mut mbedtls_ecp_point,
        m: *const mbedtls_mpi,
        P: *const mbedtls_ecp_point,
        n: *const mbedtls_mpi,
        Q: *const mbedtls_ecp_point,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs multiplication and addition of two\n                  points by integers: \\p R = \\p m * \\p P + \\p n * \\p Q in a\n                  restartable way.\n\n \\see             \\c mbedtls_ecp_muladd()\n\n \\note            This function works the same as \\c mbedtls_ecp_muladd(),\n                  but it can return early and restart according to the limit\n                  set with \\c mbedtls_ecp_set_max_ops() to reduce blocking.\n\n \\note            This function is only defined for short Weierstrass curves.\n                  It may not be included in builds without any short\n                  Weierstrass curve.\n\n \\param grp       The ECP group to use.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param R         The point in which to store the result of the calculation.\n                  This must be initialized.\n \\param m         The integer by which to multiply \\p P.\n                  This must be initialized.\n \\param P         The point to multiply by \\p m. This must be initialized.\n \\param n         The integer by which to multiply \\p Q.\n                  This must be initialized.\n \\param Q         The point to be multiplied by \\p n.\n                  This must be initialized.\n \\param rs_ctx    The restart context (NULL disables restart).\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_INVALID_KEY if \\p m or \\p n are not\n                  valid private keys, or \\p P or \\p Q are not valid public\n                  keys.\n \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.\n \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if \\p grp does not\n                  designate a short Weierstrass curve.\n \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of\n                  operations was reached: see \\c mbedtls_ecp_set_max_ops().\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_muladd_restartable(
        grp: *mut mbedtls_ecp_group,
        R: *mut mbedtls_ecp_point,
        m: *const mbedtls_mpi,
        P: *const mbedtls_ecp_point,
        n: *const mbedtls_mpi,
        Q: *const mbedtls_ecp_point,
        rs_ctx: *mut mbedtls_ecp_restart_ctx,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function checks that a point is a valid public key\n                  on this curve.\n\n                  It only checks that the point is non-zero, has\n                  valid coordinates and lies on the curve. It does not verify\n                  that it is indeed a multiple of \\p G. This additional\n                  check is computationally more expensive, is not required\n                  by standards, and should not be necessary if the group\n                  used has a small cofactor. In particular, it is useless for\n                  the NIST groups which all have a cofactor of 1.\n\n \\note            This function uses bare components rather than an\n                  ::mbedtls_ecp_keypair structure, to ease use with other\n                  structures, such as ::mbedtls_ecdh_context or\n                  ::mbedtls_ecdsa_context.\n\n \\param grp       The ECP group the point should belong to.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param pt        The point to check. This must be initialized.\n\n \\return          \\c 0 if the point is a valid public key.\n \\return          #MBEDTLS_ERR_ECP_INVALID_KEY if the point is not\n                  a valid public key for the given curve.\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_check_pubkey(
        grp: *const mbedtls_ecp_group,
        pt: *const mbedtls_ecp_point,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function checks that an \\p mbedtls_mpi is a\n                  valid private key for this curve.\n\n \\note            This function uses bare components rather than an\n                  ::mbedtls_ecp_keypair structure to ease use with other\n                  structures, such as ::mbedtls_ecdh_context or\n                  ::mbedtls_ecdsa_context.\n\n \\param grp       The ECP group the private key should belong to.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param d         The integer to check. This must be initialized.\n\n \\return          \\c 0 if the point is a valid private key.\n \\return          #MBEDTLS_ERR_ECP_INVALID_KEY if the point is not a valid\n                  private key for the given curve.\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_check_privkey(
        grp: *const mbedtls_ecp_group,
        d: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function generates a private key.\n\n \\param grp       The ECP group to generate a private key for.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param d         The destination MPI (secret part). This must be initialized.\n \\param f_rng     The RNG function. This must not be \\c NULL.\n \\param p_rng     The RNG parameter to be passed to \\p f_rng. This may be\n                  \\c NULL if \\p f_rng doesn't need a context argument.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX error code\n                  on failure."]
    pub fn mbedtls_ecp_gen_privkey(
        grp: *const mbedtls_ecp_group,
        d: *mut mbedtls_mpi,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function generates a keypair with a configurable base\n                  point.\n\n \\note            This function uses bare components rather than an\n                  ::mbedtls_ecp_keypair structure to ease use with other\n                  structures, such as ::mbedtls_ecdh_context or\n                  ::mbedtls_ecdsa_context.\n\n \\param grp       The ECP group to generate a key pair for.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param G         The base point to use. This must be initialized\n                  and belong to \\p grp. It replaces the default base\n                  point \\c grp->G used by mbedtls_ecp_gen_keypair().\n \\param d         The destination MPI (secret part).\n                  This must be initialized.\n \\param Q         The destination point (public part).\n                  This must be initialized.\n \\param f_rng     The RNG function. This must not be \\c NULL.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may\n                  be \\c NULL if \\p f_rng doesn't need a context argument.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX error code\n                  on failure."]
    pub fn mbedtls_ecp_gen_keypair_base(
        grp: *mut mbedtls_ecp_group,
        G: *const mbedtls_ecp_point,
        d: *mut mbedtls_mpi,
        Q: *mut mbedtls_ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function generates an ECP keypair.\n\n \\note            This function uses bare components rather than an\n                  ::mbedtls_ecp_keypair structure to ease use with other\n                  structures, such as ::mbedtls_ecdh_context or\n                  ::mbedtls_ecdsa_context.\n\n \\param grp       The ECP group to generate a key pair for.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param d         The destination MPI (secret part).\n                  This must be initialized.\n \\param Q         The destination point (public part).\n                  This must be initialized.\n \\param f_rng     The RNG function. This must not be \\c NULL.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may\n                  be \\c NULL if \\p f_rng doesn't need a context argument.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX error code\n                  on failure."]
    pub fn mbedtls_ecp_gen_keypair(
        grp: *mut mbedtls_ecp_group,
        d: *mut mbedtls_mpi,
        Q: *mut mbedtls_ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function generates an ECP key.\n\n \\param grp_id    The ECP group identifier.\n \\param key       The destination key. This must be initialized.\n \\param f_rng     The RNG function to use. This must not be \\c NULL.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may\n                  be \\c NULL if \\p f_rng doesn't need a context argument.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX error code\n                  on failure."]
    pub fn mbedtls_ecp_gen_key(
        grp_id: mbedtls_ecp_group_id,
        key: *mut mbedtls_ecp_keypair,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function reads an elliptic curve private key.\n\n \\param grp_id    The ECP group identifier.\n \\param key       The destination key.\n \\param buf       The buffer containing the binary representation of the\n                  key. (Big endian integer for Weierstrass curves, byte\n                  string for Montgomery curves.)\n \\param buflen    The length of the buffer in bytes.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_INVALID_KEY error if the key is\n                  invalid.\n \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the operation for\n                  the group is not implemented.\n \\return          Another negative error code on different kinds of failure."]
    pub fn mbedtls_ecp_read_key(
        grp_id: mbedtls_ecp_group_id,
        key: *mut mbedtls_ecp_keypair,
        buf: *const crate::c_types::c_uchar,
        buflen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function exports an elliptic curve private key.\n\n \\param key       The private key.\n \\param buf       The output buffer for containing the binary representation\n                  of the key. (Big endian integer for Weierstrass curves, byte\n                  string for Montgomery curves.)\n \\param buflen    The total length of the buffer in bytes.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL if the \\p key\nrepresentation is larger than the available space in \\p buf.\n \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the operation for\n                  the group is not implemented.\n \\return          Another negative error code on different kinds of failure."]
    pub fn mbedtls_ecp_write_key(
        key: *mut mbedtls_ecp_keypair,
        buf: *mut crate::c_types::c_uchar,
        buflen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function checks that the keypair objects\n                  \\p pub and \\p prv have the same group and the\n                  same public point, and that the private key in\n                  \\p prv is consistent with the public key.\n\n \\param pub       The keypair structure holding the public key. This\n                  must be initialized. If it contains a private key, that\n                  part is ignored.\n \\param prv       The keypair structure holding the full keypair.\n                  This must be initialized.\n \\param f_rng     The RNG function. This must not be \\c NULL.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may be \\c\n                  NULL if \\p f_rng doesn't need a context.\n\n \\return          \\c 0 on success, meaning that the keys are valid and match.\n \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the keys are invalid or do not match.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX or an \\c MBEDTLS_ERR_MPI_XXX\n                  error code on calculation failure."]
    pub fn mbedtls_ecp_check_pub_priv(
        pub_: *const mbedtls_ecp_keypair,
        prv: *const mbedtls_ecp_keypair,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function exports generic key-pair parameters.\n\n \\param key       The key pair to export from.\n \\param grp       Slot for exported ECP group.\n                  It must point to an initialized ECP group.\n \\param d         Slot for the exported secret value.\n                  It must point to an initialized mpi.\n \\param Q         Slot for the exported public value.\n                  It must point to an initialized ECP point.\n\n \\return          \\c 0 on success,\n \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.\n \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if key id doesn't\n                  correspond to a known group.\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_ecp_export(
        key: *const mbedtls_ecp_keypair,
        grp: *mut mbedtls_ecp_group,
        d: *mut mbedtls_mpi,
        Q: *mut mbedtls_ecp_point,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          The ECP checkup routine.\n\n \\return         \\c 0 on success.\n \\return         \\c 1 on failure."]
    pub fn mbedtls_ecp_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[doc = "< None."]
pub const mbedtls_md_type_t_MBEDTLS_MD_NONE: mbedtls_md_type_t = 0;
#[doc = "< The MD5 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_MD5: mbedtls_md_type_t = 1;
#[doc = "< The SHA-1 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA1: mbedtls_md_type_t = 2;
#[doc = "< The SHA-224 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA224: mbedtls_md_type_t = 3;
#[doc = "< The SHA-256 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA256: mbedtls_md_type_t = 4;
#[doc = "< The SHA-384 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA384: mbedtls_md_type_t = 5;
#[doc = "< The SHA-512 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA512: mbedtls_md_type_t = 6;
#[doc = "< The RIPEMD-160 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_RIPEMD160: mbedtls_md_type_t = 7;
#[doc = " \\brief     Supported message digests.\n\n \\warning   MD5 and SHA-1 are considered weak message digests and\n            their use constitutes a security risk. We recommend considering\n            stronger message digests instead.\n"]
pub type mbedtls_md_type_t = crate::c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_md_info_t {
    _unused: [u8; 0],
}
pub const mbedtls_md_engine_t_MBEDTLS_MD_ENGINE_LEGACY: mbedtls_md_engine_t = 0;
pub const mbedtls_md_engine_t_MBEDTLS_MD_ENGINE_PSA: mbedtls_md_engine_t = 1;
#[doc = " Used internally to indicate whether a context uses legacy or PSA.\n\n Internal use only."]
pub type mbedtls_md_engine_t = crate::c_types::c_uint;
#[doc = " The generic message-digest context."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_md_context_t {
    pub private_md_info: *const mbedtls_md_info_t,
    pub private_md_ctx: *mut crate::c_types::c_void,
    pub private_hmac_ctx: *mut crate::c_types::c_void,
}
extern "C" {
    #[doc = " \\brief           This function returns the message-digest information\n                  associated with the given digest type.\n\n \\param md_type   The type of digest to search for.\n\n \\return          The message-digest information associated with \\p md_type.\n \\return          NULL if the associated message-digest information is not found."]
    pub fn mbedtls_md_info_from_type(md_type: mbedtls_md_type_t) -> *const mbedtls_md_info_t;
}
extern "C" {
    #[doc = " \\brief           This function initializes a message-digest context without\n                  binding it to a particular message-digest algorithm.\n\n                  This function should always be called first. It prepares the\n                  context for mbedtls_md_setup() for binding it to a\n                  message-digest algorithm."]
    pub fn mbedtls_md_init(ctx: *mut mbedtls_md_context_t);
}
extern "C" {
    #[doc = " \\brief           This function clears the internal structure of \\p ctx and\n                  frees any embedded internal structure, but does not free\n                  \\p ctx itself.\n\n                  If you have called mbedtls_md_setup() on \\p ctx, you must\n                  call mbedtls_md_free() when you are no longer using the\n                  context.\n                  Calling this function if you have previously\n                  called mbedtls_md_init() and nothing else is optional.\n                  You must not call this function if you have not called\n                  mbedtls_md_init()."]
    pub fn mbedtls_md_free(ctx: *mut mbedtls_md_context_t);
}
extern "C" {
    #[doc = " \\brief           This function selects the message digest algorithm to use,\n                  and allocates internal structures.\n\n                  It should be called after mbedtls_md_init() or\n                  mbedtls_md_free(). Makes it necessary to call\n                  mbedtls_md_free() later.\n\n \\param ctx       The context to set up.\n \\param md_info   The information structure of the message-digest algorithm\n                  to use.\n \\param hmac      Defines if HMAC is used. 0: HMAC is not used (saves some memory),\n                  or non-zero: HMAC is used with this context.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification\n                  failure.\n \\return          #MBEDTLS_ERR_MD_ALLOC_FAILED on memory-allocation failure."]
    pub fn mbedtls_md_setup(
        ctx: *mut mbedtls_md_context_t,
        md_info: *const mbedtls_md_info_t,
        hmac: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function clones the state of a message-digest\n                  context.\n\n \\note            You must call mbedtls_md_setup() on \\c dst before calling\n                  this function.\n\n \\note            The two contexts must have the same type,\n                  for example, both are SHA-256.\n\n \\warning         This function clones the message-digest state, not the\n                  HMAC state.\n\n \\param dst       The destination context.\n \\param src       The context to be cloned.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification failure.\n \\return          #MBEDTLS_ERR_MD_FEATURE_UNAVAILABLE if both contexts are\n                  not using the same engine. This can be avoided by moving\n                  the call to psa_crypto_init() before the first call to\n                  mbedtls_md_setup()."]
    pub fn mbedtls_md_clone(
        dst: *mut mbedtls_md_context_t,
        src: *const mbedtls_md_context_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function extracts the message-digest size from the\n                  message-digest information structure.\n\n \\param md_info   The information structure of the message-digest algorithm\n                  to use.\n\n \\return          The size of the message-digest output in Bytes."]
    pub fn mbedtls_md_get_size(md_info: *const mbedtls_md_info_t) -> crate::c_types::c_uchar;
}
extern "C" {
    #[doc = " \\brief           This function extracts the message-digest type from the\n                  message-digest information structure.\n\n \\param md_info   The information structure of the message-digest algorithm\n                  to use.\n\n \\return          The type of the message digest."]
    pub fn mbedtls_md_get_type(md_info: *const mbedtls_md_info_t) -> mbedtls_md_type_t;
}
extern "C" {
    #[doc = " \\brief           This function starts a message-digest computation.\n\n                  You must call this function after setting up the context\n                  with mbedtls_md_setup(), and before passing data with\n                  mbedtls_md_update().\n\n \\param ctx       The generic message-digest context.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification\n                  failure."]
    pub fn mbedtls_md_starts(ctx: *mut mbedtls_md_context_t) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function feeds an input buffer into an ongoing\n                  message-digest computation.\n\n                  You must call mbedtls_md_starts() before calling this\n                  function. You may call this function multiple times.\n                  Afterwards, call mbedtls_md_finish().\n\n \\param ctx       The generic message-digest context.\n \\param input     The buffer holding the input data.\n \\param ilen      The length of the input data.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification\n                  failure."]
    pub fn mbedtls_md_update(
        ctx: *mut mbedtls_md_context_t,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function finishes the digest operation,\n                  and writes the result to the output buffer.\n\n                  Call this function after a call to mbedtls_md_starts(),\n                  followed by any number of calls to mbedtls_md_update().\n                  Afterwards, you may either clear the context with\n                  mbedtls_md_free(), or call mbedtls_md_starts() to reuse\n                  the context for another digest operation with the same\n                  algorithm.\n\n \\param ctx       The generic message-digest context.\n \\param output    The buffer for the generic message-digest checksum result.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification\n                  failure."]
    pub fn mbedtls_md_finish(
        ctx: *mut mbedtls_md_context_t,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function calculates the message-digest of a buffer,\n                 with respect to a configurable message-digest algorithm\n                 in a single call.\n\n                 The result is calculated as\n                 Output = message_digest(input buffer).\n\n \\param md_info  The information structure of the message-digest algorithm\n                 to use.\n \\param input    The buffer holding the data.\n \\param ilen     The length of the input data.\n \\param output   The generic message-digest checksum result.\n\n \\return         \\c 0 on success.\n \\return         #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification\n                 failure."]
    pub fn mbedtls_md(
        md_info: *const mbedtls_md_info_t,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function returns the list of digests supported by the\n                  generic digest module.\n\n \\note            The list starts with the strongest available hashes.\n\n \\return          A statically allocated array of digests. Each element\n                  in the returned list is an integer belonging to the\n                  message-digest enumeration #mbedtls_md_type_t.\n                  The last entry is 0."]
    pub fn mbedtls_md_list() -> *const crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function returns the message-digest information\n                  associated with the given digest name.\n\n \\param md_name   The name of the digest to search for.\n\n \\return          The message-digest information associated with \\p md_name.\n \\return          NULL if the associated message-digest information is not found."]
    pub fn mbedtls_md_info_from_string(
        md_name: *const crate::c_types::c_char,
    ) -> *const mbedtls_md_info_t;
}
extern "C" {
    #[doc = " \\brief           This function extracts the message-digest name from the\n                  message-digest information structure.\n\n \\param md_info   The information structure of the message-digest algorithm\n                  to use.\n\n \\return          The name of the message digest."]
    pub fn mbedtls_md_get_name(md_info: *const mbedtls_md_info_t) -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " \\brief           This function returns the message-digest information\n                  from the given context.\n\n \\param ctx       The context from which to extract the information.\n                  This must be initialized (or \\c NULL).\n\n \\return          The message-digest information associated with \\p ctx.\n \\return          \\c NULL if \\p ctx is \\c NULL."]
    pub fn mbedtls_md_info_from_ctx(ctx: *const mbedtls_md_context_t) -> *const mbedtls_md_info_t;
}
extern "C" {
    #[doc = " \\brief           This function sets the HMAC key and prepares to\n                  authenticate a new message.\n\n                  Call this function after mbedtls_md_setup(), to use\n                  the MD context for an HMAC calculation, then call\n                  mbedtls_md_hmac_update() to provide the input data, and\n                  mbedtls_md_hmac_finish() to get the HMAC value.\n\n \\param ctx       The message digest context containing an embedded HMAC\n                  context.\n \\param key       The HMAC secret key.\n \\param keylen    The length of the HMAC key in Bytes.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification\n                  failure."]
    pub fn mbedtls_md_hmac_starts(
        ctx: *mut mbedtls_md_context_t,
        key: *const crate::c_types::c_uchar,
        keylen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function feeds an input buffer into an ongoing HMAC\n                  computation.\n\n                  Call mbedtls_md_hmac_starts() or mbedtls_md_hmac_reset()\n                  before calling this function.\n                  You may call this function multiple times to pass the\n                  input piecewise.\n                  Afterwards, call mbedtls_md_hmac_finish().\n\n \\param ctx       The message digest context containing an embedded HMAC\n                  context.\n \\param input     The buffer holding the input data.\n \\param ilen      The length of the input data.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification\n                  failure."]
    pub fn mbedtls_md_hmac_update(
        ctx: *mut mbedtls_md_context_t,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function finishes the HMAC operation, and writes\n                  the result to the output buffer.\n\n                  Call this function after mbedtls_md_hmac_starts() and\n                  mbedtls_md_hmac_update() to get the HMAC value. Afterwards\n                  you may either call mbedtls_md_free() to clear the context,\n                  or call mbedtls_md_hmac_reset() to reuse the context with\n                  the same HMAC key.\n\n \\param ctx       The message digest context containing an embedded HMAC\n                  context.\n \\param output    The generic HMAC checksum result.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification\n                  failure."]
    pub fn mbedtls_md_hmac_finish(
        ctx: *mut mbedtls_md_context_t,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function prepares to authenticate a new message with\n                  the same key as the previous HMAC operation.\n\n                  You may call this function after mbedtls_md_hmac_finish().\n                  Afterwards call mbedtls_md_hmac_update() to pass the new\n                  input.\n\n \\param ctx       The message digest context containing an embedded HMAC\n                  context.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification\n                  failure."]
    pub fn mbedtls_md_hmac_reset(ctx: *mut mbedtls_md_context_t) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function calculates the full generic HMAC\n                 on the input buffer with the provided key.\n\n                 The function allocates the context, performs the\n                 calculation, and frees the context.\n\n                 The HMAC result is calculated as\n                 output = generic HMAC(hmac key, input buffer).\n\n \\param md_info  The information structure of the message-digest algorithm\n                 to use.\n \\param key      The HMAC secret key.\n \\param keylen   The length of the HMAC secret key in Bytes.\n \\param input    The buffer holding the input data.\n \\param ilen     The length of the input data.\n \\param output   The generic HMAC result.\n\n \\return         \\c 0 on success.\n \\return         #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification\n                 failure."]
    pub fn mbedtls_md_hmac(
        md_info: *const mbedtls_md_info_t,
        key: *const crate::c_types::c_uchar,
        keylen: usize,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
#[doc = " \\brief   The RSA context structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_rsa_context {
    pub private_ver: crate::c_types::c_int,
    pub private_len: usize,
    pub private_N: mbedtls_mpi,
    pub private_E: mbedtls_mpi,
    pub private_D: mbedtls_mpi,
    pub private_P: mbedtls_mpi,
    pub private_Q: mbedtls_mpi,
    pub private_DP: mbedtls_mpi,
    pub private_DQ: mbedtls_mpi,
    pub private_QP: mbedtls_mpi,
    pub private_RN: mbedtls_mpi,
    pub private_RP: mbedtls_mpi,
    pub private_RQ: mbedtls_mpi,
    pub private_Vi: mbedtls_mpi,
    pub private_Vf: mbedtls_mpi,
    pub private_padding: crate::c_types::c_int,
    pub private_hash_id: crate::c_types::c_int,
}
extern "C" {
    #[doc = " \\brief          This function initializes an RSA context.\n\n \\note           This function initializes the padding and the hash\n                 identifier to respectively #MBEDTLS_RSA_PKCS_V15 and\n                 #MBEDTLS_MD_NONE. See mbedtls_rsa_set_padding() for more\n                 information about those parameters.\n\n \\param ctx      The RSA context to initialize. This must not be \\c NULL."]
    pub fn mbedtls_rsa_init(ctx: *mut mbedtls_rsa_context);
}
extern "C" {
    #[doc = " \\brief          This function sets padding for an already initialized RSA\n                 context.\n\n \\note           Set padding to #MBEDTLS_RSA_PKCS_V21 for the RSAES-OAEP\n                 encryption scheme and the RSASSA-PSS signature scheme.\n\n \\note           The \\p hash_id parameter is ignored when using\n                 #MBEDTLS_RSA_PKCS_V15 padding.\n\n \\note           The choice of padding mode is strictly enforced for private\n                 key operations, since there might be security concerns in\n                 mixing padding modes. For public key operations it is\n                 a default value, which can be overridden by calling specific\n                 \\c mbedtls_rsa_rsaes_xxx or \\c mbedtls_rsa_rsassa_xxx\n                 functions.\n\n \\note           The hash selected in \\p hash_id is always used for OEAP\n                 encryption. For PSS signatures, it is always used for\n                 making signatures, but can be overridden for verifying them.\n                 If set to #MBEDTLS_MD_NONE, it is always overridden.\n\n \\param ctx      The initialized RSA context to be configured.\n \\param padding  The padding mode to use. This must be either\n                 #MBEDTLS_RSA_PKCS_V15 or #MBEDTLS_RSA_PKCS_V21.\n \\param hash_id  The hash identifier for PSS or OAEP, if \\p padding is\n                 #MBEDTLS_RSA_PKCS_V21. #MBEDTLS_MD_NONE is accepted by this\n                 function but may be not suitable for some operations.\n                 Ignored if \\p padding is #MBEDTLS_RSA_PKCS_V15.\n\n \\return         \\c 0 on success.\n \\return         #MBEDTLS_ERR_RSA_INVALID_PADDING failure:\n                 \\p padding or \\p hash_id is invalid."]
    pub fn mbedtls_rsa_set_padding(
        ctx: *mut mbedtls_rsa_context,
        padding: crate::c_types::c_int,
        hash_id: mbedtls_md_type_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function retrieves padding mode of initialized\n                 RSA context.\n\n \\param ctx      The initialized RSA context.\n\n \\return         RSA padding mode.\n"]
    pub fn mbedtls_rsa_get_padding_mode(ctx: *const mbedtls_rsa_context) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function retrieves hash identifier of mbedtls_md_type_t\n                 type.\n\n \\param ctx      The initialized RSA context.\n\n \\return         Hash identifier of mbedtls_md_type_t type.\n"]
    pub fn mbedtls_rsa_get_md_alg(ctx: *const mbedtls_rsa_context) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function imports a set of core parameters into an\n                 RSA context.\n\n \\note           This function can be called multiple times for successive\n                 imports, if the parameters are not simultaneously present.\n\n                 Any sequence of calls to this function should be followed\n                 by a call to mbedtls_rsa_complete(), which checks and\n                 completes the provided information to a ready-for-use\n                 public or private RSA key.\n\n \\note           See mbedtls_rsa_complete() for more information on which\n                 parameters are necessary to set up a private or public\n                 RSA key.\n\n \\note           The imported parameters are copied and need not be preserved\n                 for the lifetime of the RSA context being set up.\n\n \\param ctx      The initialized RSA context to store the parameters in.\n \\param N        The RSA modulus. This may be \\c NULL.\n \\param P        The first prime factor of \\p N. This may be \\c NULL.\n \\param Q        The second prime factor of \\p N. This may be \\c NULL.\n \\param D        The private exponent. This may be \\c NULL.\n \\param E        The public exponent. This may be \\c NULL.\n\n \\return         \\c 0 on success.\n \\return         A non-zero error code on failure."]
    pub fn mbedtls_rsa_import(
        ctx: *mut mbedtls_rsa_context,
        N: *const mbedtls_mpi,
        P: *const mbedtls_mpi,
        Q: *const mbedtls_mpi,
        D: *const mbedtls_mpi,
        E: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function imports core RSA parameters, in raw big-endian\n                 binary format, into an RSA context.\n\n \\note           This function can be called multiple times for successive\n                 imports, if the parameters are not simultaneously present.\n\n                 Any sequence of calls to this function should be followed\n                 by a call to mbedtls_rsa_complete(), which checks and\n                 completes the provided information to a ready-for-use\n                 public or private RSA key.\n\n \\note           See mbedtls_rsa_complete() for more information on which\n                 parameters are necessary to set up a private or public\n                 RSA key.\n\n \\note           The imported parameters are copied and need not be preserved\n                 for the lifetime of the RSA context being set up.\n\n \\param ctx      The initialized RSA context to store the parameters in.\n \\param N        The RSA modulus. This may be \\c NULL.\n \\param N_len    The Byte length of \\p N; it is ignored if \\p N == NULL.\n \\param P        The first prime factor of \\p N. This may be \\c NULL.\n \\param P_len    The Byte length of \\p P; it is ignored if \\p P == NULL.\n \\param Q        The second prime factor of \\p N. This may be \\c NULL.\n \\param Q_len    The Byte length of \\p Q; it is ignored if \\p Q == NULL.\n \\param D        The private exponent. This may be \\c NULL.\n \\param D_len    The Byte length of \\p D; it is ignored if \\p D == NULL.\n \\param E        The public exponent. This may be \\c NULL.\n \\param E_len    The Byte length of \\p E; it is ignored if \\p E == NULL.\n\n \\return         \\c 0 on success.\n \\return         A non-zero error code on failure."]
    pub fn mbedtls_rsa_import_raw(
        ctx: *mut mbedtls_rsa_context,
        N: *const crate::c_types::c_uchar,
        N_len: usize,
        P: *const crate::c_types::c_uchar,
        P_len: usize,
        Q: *const crate::c_types::c_uchar,
        Q_len: usize,
        D: *const crate::c_types::c_uchar,
        D_len: usize,
        E: *const crate::c_types::c_uchar,
        E_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function completes an RSA context from\n                 a set of imported core parameters.\n\n                 To setup an RSA public key, precisely \\p N and \\p E\n                 must have been imported.\n\n                 To setup an RSA private key, sufficient information must\n                 be present for the other parameters to be derivable.\n\n                 The default implementation supports the following:\n                 <ul><li>Derive \\p P, \\p Q from \\p N, \\p D, \\p E.</li>\n                 <li>Derive \\p N, \\p D from \\p P, \\p Q, \\p E.</li></ul>\n                 Alternative implementations need not support these.\n\n                 If this function runs successfully, it guarantees that\n                 the RSA context can be used for RSA operations without\n                 the risk of failure or crash.\n\n \\warning        This function need not perform consistency checks\n                 for the imported parameters. In particular, parameters that\n                 are not needed by the implementation might be silently\n                 discarded and left unchecked. To check the consistency\n                 of the key material, see mbedtls_rsa_check_privkey().\n\n \\param ctx      The initialized RSA context holding imported parameters.\n\n \\return         \\c 0 on success.\n \\return         #MBEDTLS_ERR_RSA_BAD_INPUT_DATA if the attempted derivations\n                 failed.\n"]
    pub fn mbedtls_rsa_complete(ctx: *mut mbedtls_rsa_context) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function exports the core parameters of an RSA key.\n\n                 If this function runs successfully, the non-NULL buffers\n                 pointed to by \\p N, \\p P, \\p Q, \\p D, and \\p E are fully\n                 written, with additional unused space filled leading by\n                 zero Bytes.\n\n                 Possible reasons for returning\n                 #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED:<ul>\n                 <li>An alternative RSA implementation is in use, which\n                 stores the key externally, and either cannot or should\n                 not export it into RAM.</li>\n                 <li>A SW or HW implementation might not support a certain\n                 deduction. For example, \\p P, \\p Q from \\p N, \\p D,\n                 and \\p E if the former are not part of the\n                 implementation.</li></ul>\n\n                 If the function fails due to an unsupported operation,\n                 the RSA context stays intact and remains usable.\n\n \\param ctx      The initialized RSA context.\n \\param N        The MPI to hold the RSA modulus.\n                 This may be \\c NULL if this field need not be exported.\n \\param P        The MPI to hold the first prime factor of \\p N.\n                 This may be \\c NULL if this field need not be exported.\n \\param Q        The MPI to hold the second prime factor of \\p N.\n                 This may be \\c NULL if this field need not be exported.\n \\param D        The MPI to hold the private exponent.\n                 This may be \\c NULL if this field need not be exported.\n \\param E        The MPI to hold the public exponent.\n                 This may be \\c NULL if this field need not be exported.\n\n \\return         \\c 0 on success.\n \\return         #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED if exporting the\n                 requested parameters cannot be done due to missing\n                 functionality or because of security policies.\n \\return         A non-zero return code on any other failure.\n"]
    pub fn mbedtls_rsa_export(
        ctx: *const mbedtls_rsa_context,
        N: *mut mbedtls_mpi,
        P: *mut mbedtls_mpi,
        Q: *mut mbedtls_mpi,
        D: *mut mbedtls_mpi,
        E: *mut mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function exports core parameters of an RSA key\n                 in raw big-endian binary format.\n\n                 If this function runs successfully, the non-NULL buffers\n                 pointed to by \\p N, \\p P, \\p Q, \\p D, and \\p E are fully\n                 written, with additional unused space filled leading by\n                 zero Bytes.\n\n                 Possible reasons for returning\n                 #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED:<ul>\n                 <li>An alternative RSA implementation is in use, which\n                 stores the key externally, and either cannot or should\n                 not export it into RAM.</li>\n                 <li>A SW or HW implementation might not support a certain\n                 deduction. For example, \\p P, \\p Q from \\p N, \\p D,\n                 and \\p E if the former are not part of the\n                 implementation.</li></ul>\n                 If the function fails due to an unsupported operation,\n                 the RSA context stays intact and remains usable.\n\n \\note           The length parameters are ignored if the corresponding\n                 buffer pointers are NULL.\n\n \\param ctx      The initialized RSA context.\n \\param N        The Byte array to store the RSA modulus,\n                 or \\c NULL if this field need not be exported.\n \\param N_len    The size of the buffer for the modulus.\n \\param P        The Byte array to hold the first prime factor of \\p N,\n                 or \\c NULL if this field need not be exported.\n \\param P_len    The size of the buffer for the first prime factor.\n \\param Q        The Byte array to hold the second prime factor of \\p N,\n                 or \\c NULL if this field need not be exported.\n \\param Q_len    The size of the buffer for the second prime factor.\n \\param D        The Byte array to hold the private exponent,\n                 or \\c NULL if this field need not be exported.\n \\param D_len    The size of the buffer for the private exponent.\n \\param E        The Byte array to hold the public exponent,\n                 or \\c NULL if this field need not be exported.\n \\param E_len    The size of the buffer for the public exponent.\n\n \\return         \\c 0 on success.\n \\return         #MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED if exporting the\n                 requested parameters cannot be done due to missing\n                 functionality or because of security policies.\n \\return         A non-zero return code on any other failure."]
    pub fn mbedtls_rsa_export_raw(
        ctx: *const mbedtls_rsa_context,
        N: *mut crate::c_types::c_uchar,
        N_len: usize,
        P: *mut crate::c_types::c_uchar,
        P_len: usize,
        Q: *mut crate::c_types::c_uchar,
        Q_len: usize,
        D: *mut crate::c_types::c_uchar,
        D_len: usize,
        E: *mut crate::c_types::c_uchar,
        E_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function exports CRT parameters of a private RSA key.\n\n \\note           Alternative RSA implementations not using CRT-parameters\n                 internally can implement this function based on\n                 mbedtls_rsa_deduce_opt().\n\n \\param ctx      The initialized RSA context.\n \\param DP       The MPI to hold \\c D modulo `P-1`,\n                 or \\c NULL if it need not be exported.\n \\param DQ       The MPI to hold \\c D modulo `Q-1`,\n                 or \\c NULL if it need not be exported.\n \\param QP       The MPI to hold modular inverse of \\c Q modulo \\c P,\n                 or \\c NULL if it need not be exported.\n\n \\return         \\c 0 on success.\n \\return         A non-zero error code on failure.\n"]
    pub fn mbedtls_rsa_export_crt(
        ctx: *const mbedtls_rsa_context,
        DP: *mut mbedtls_mpi,
        DQ: *mut mbedtls_mpi,
        QP: *mut mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function retrieves the length of RSA modulus in Bytes.\n\n \\param ctx      The initialized RSA context.\n\n \\return         The length of the RSA modulus in Bytes.\n"]
    pub fn mbedtls_rsa_get_len(ctx: *const mbedtls_rsa_context) -> usize;
}
extern "C" {
    #[doc = " \\brief          This function generates an RSA keypair.\n\n \\note           mbedtls_rsa_init() must be called before this function,\n                 to set up the RSA context.\n\n \\param ctx      The initialized RSA context used to hold the key.\n \\param f_rng    The RNG function to be used for key generation.\n                 This is mandatory and must not be \\c NULL.\n \\param p_rng    The RNG context to be passed to \\p f_rng.\n                 This may be \\c NULL if \\p f_rng doesn't need a context.\n \\param nbits    The size of the public key in bits.\n \\param exponent The public exponent to use. For example, \\c 65537.\n                 This must be odd and greater than \\c 1.\n\n \\return         \\c 0 on success.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_gen_key(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        nbits: crate::c_types::c_uint,
        exponent: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function checks if a context contains at least an RSA\n                 public key.\n\n                 If the function runs successfully, it is guaranteed that\n                 enough information is present to perform an RSA public key\n                 operation using mbedtls_rsa_public().\n\n \\param ctx      The initialized RSA context to check.\n\n \\return         \\c 0 on success.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure.\n"]
    pub fn mbedtls_rsa_check_pubkey(ctx: *const mbedtls_rsa_context) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief      This function checks if a context contains an RSA private key\n             and perform basic consistency checks.\n\n \\note       The consistency checks performed by this function not only\n             ensure that mbedtls_rsa_private() can be called successfully\n             on the given context, but that the various parameters are\n             mutually consistent with high probability, in the sense that\n             mbedtls_rsa_public() and mbedtls_rsa_private() are inverses.\n\n \\warning    This function should catch accidental misconfigurations\n             like swapping of parameters, but it cannot establish full\n             trust in neither the quality nor the consistency of the key\n             material that was used to setup the given RSA context:\n             <ul><li>Consistency: Imported parameters that are irrelevant\n             for the implementation might be silently dropped. If dropped,\n             the current function does not have access to them,\n             and therefore cannot check them. See mbedtls_rsa_complete().\n             If you want to check the consistency of the entire\n             content of a PKCS1-encoded RSA private key, for example, you\n             should use mbedtls_rsa_validate_params() before setting\n             up the RSA context.\n             Additionally, if the implementation performs empirical checks,\n             these checks substantiate but do not guarantee consistency.</li>\n             <li>Quality: This function is not expected to perform\n             extended quality assessments like checking that the prime\n             factors are safe. Additionally, it is the responsibility of the\n             user to ensure the trustworthiness of the source of his RSA\n             parameters, which goes beyond what is effectively checkable\n             by the library.</li></ul>\n\n \\param ctx  The initialized RSA context to check.\n\n \\return     \\c 0 on success.\n \\return     An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_check_privkey(ctx: *const mbedtls_rsa_context) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function checks a public-private RSA key pair.\n\n                 It checks each of the contexts, and makes sure they match.\n\n \\param pub      The initialized RSA context holding the public key.\n \\param prv      The initialized RSA context holding the private key.\n\n \\return         \\c 0 on success.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_check_pub_priv(
        pub_: *const mbedtls_rsa_context,
        prv: *const mbedtls_rsa_context,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs an RSA public key operation.\n\n \\param ctx      The initialized RSA context to use.\n \\param input    The input buffer. This must be a readable buffer\n                 of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                 for an 2048-bit RSA modulus.\n \\param output   The output buffer. This must be a writable buffer\n                 of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                 for an 2048-bit RSA modulus.\n\n \\note           This function does not handle message padding.\n\n \\note           Make sure to set \\p input[0] = 0 or ensure that\n                 input is smaller than \\p N.\n\n \\return         \\c 0 on success.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_public(
        ctx: *mut mbedtls_rsa_context,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs an RSA private key operation.\n\n \\note           Blinding is used if and only if a PRNG is provided.\n\n \\note           If blinding is used, both the base of exponentiation\n                 and the exponent are blinded, providing protection\n                 against some side-channel attacks.\n\n \\warning        It is deprecated and a security risk to not provide\n                 a PRNG here and thereby prevent the use of blinding.\n                 Future versions of the library may enforce the presence\n                 of a PRNG.\n\n \\param ctx      The initialized RSA context to use.\n \\param f_rng    The RNG function, used for blinding. It is mandatory.\n \\param p_rng    The RNG context to pass to \\p f_rng. This may be \\c NULL\n                 if \\p f_rng doesn't need a context.\n \\param input    The input buffer. This must be a readable buffer\n                 of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                 for an 2048-bit RSA modulus.\n \\param output   The output buffer. This must be a writable buffer\n                 of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                 for an 2048-bit RSA modulus.\n\n \\return         \\c 0 on success.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure.\n"]
    pub fn mbedtls_rsa_private(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function adds the message padding, then performs an RSA\n                 operation.\n\n                 It is the generic wrapper for performing a PKCS#1 encryption\n                 operation.\n\n \\param ctx      The initialized RSA context to use.\n \\param f_rng    The RNG to use. It is used for padding generation\n                 and it is mandatory.\n \\param p_rng    The RNG context to be passed to \\p f_rng. May be\n                 \\c NULL if \\p f_rng doesn't need a context argument.\n \\param ilen     The length of the plaintext in Bytes.\n \\param input    The input data to encrypt. This must be a readable\n                 buffer of size \\p ilen Bytes. It may be \\c NULL if\n                 `ilen == 0`.\n \\param output   The output buffer. This must be a writable buffer\n                 of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                 for an 2048-bit RSA modulus.\n\n \\return         \\c 0 on success.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_pkcs1_encrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        ilen: usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v1.5 encryption operation\n                 (RSAES-PKCS1-v1_5-ENCRYPT).\n\n \\param ctx      The initialized RSA context to use.\n \\param f_rng    The RNG function to use. It is mandatory and used for\n                 padding generation.\n \\param p_rng    The RNG context to be passed to \\p f_rng. This may\n                 be \\c NULL if \\p f_rng doesn't need a context argument.\n \\param ilen     The length of the plaintext in Bytes.\n \\param input    The input data to encrypt. This must be a readable\n                 buffer of size \\p ilen Bytes. It may be \\c NULL if\n                 `ilen == 0`.\n \\param output   The output buffer. This must be a writable buffer\n                 of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                 for an 2048-bit RSA modulus.\n\n \\return         \\c 0 on success.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsaes_pkcs1_v15_encrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        ilen: usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief            This function performs a PKCS#1 v2.1 OAEP encryption\n                   operation (RSAES-OAEP-ENCRYPT).\n\n \\note             The output buffer must be as large as the size\n                   of ctx->N. For example, 128 Bytes if RSA-1024 is used.\n\n \\param ctx        The initialized RSA context to use.\n \\param f_rng      The RNG function to use. This is needed for padding\n                   generation and is mandatory.\n \\param p_rng      The RNG context to be passed to \\p f_rng. This may\n                   be \\c NULL if \\p f_rng doesn't need a context argument.\n \\param label      The buffer holding the custom label to use.\n                   This must be a readable buffer of length \\p label_len\n                   Bytes. It may be \\c NULL if \\p label_len is \\c 0.\n \\param label_len  The length of the label in Bytes.\n \\param ilen       The length of the plaintext buffer \\p input in Bytes.\n \\param input      The input data to encrypt. This must be a readable\n                   buffer of size \\p ilen Bytes. It may be \\c NULL if\n                   `ilen == 0`.\n \\param output     The output buffer. This must be a writable buffer\n                   of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                   for an 2048-bit RSA modulus.\n\n \\return           \\c 0 on success.\n \\return           An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsaes_oaep_encrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        label: *const crate::c_types::c_uchar,
        label_len: usize,
        ilen: usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs an RSA operation, then removes the\n                 message padding.\n\n                 It is the generic wrapper for performing a PKCS#1 decryption\n                 operation.\n\n \\note           The output buffer length \\c output_max_len should be\n                 as large as the size \\p ctx->len of \\p ctx->N (for example,\n                 128 Bytes if RSA-1024 is used) to be able to hold an\n                 arbitrary decrypted message. If it is not large enough to\n                 hold the decryption of the particular ciphertext provided,\n                 the function returns \\c MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE.\n\n \\param ctx      The initialized RSA context to use.\n \\param f_rng    The RNG function. This is used for blinding and is\n                 mandatory; see mbedtls_rsa_private() for more.\n \\param p_rng    The RNG context to be passed to \\p f_rng. This may be\n                 \\c NULL if \\p f_rng doesn't need a context.\n \\param olen     The address at which to store the length of\n                 the plaintext. This must not be \\c NULL.\n \\param input    The ciphertext buffer. This must be a readable buffer\n                 of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                 for an 2048-bit RSA modulus.\n \\param output   The buffer used to hold the plaintext. This must\n                 be a writable buffer of length \\p output_max_len Bytes.\n \\param output_max_len The length in Bytes of the output buffer \\p output.\n\n \\return         \\c 0 on success.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_pkcs1_decrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        olen: *mut usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
        output_max_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v1.5 decryption\n                 operation (RSAES-PKCS1-v1_5-DECRYPT).\n\n \\note           The output buffer length \\c output_max_len should be\n                 as large as the size \\p ctx->len of \\p ctx->N, for example,\n                 128 Bytes if RSA-1024 is used, to be able to hold an\n                 arbitrary decrypted message. If it is not large enough to\n                 hold the decryption of the particular ciphertext provided,\n                 the function returns #MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE.\n\n \\param ctx      The initialized RSA context to use.\n \\param f_rng    The RNG function. This is used for blinding and is\n                 mandatory; see mbedtls_rsa_private() for more.\n \\param p_rng    The RNG context to be passed to \\p f_rng. This may be\n                 \\c NULL if \\p f_rng doesn't need a context.\n \\param olen     The address at which to store the length of\n                 the plaintext. This must not be \\c NULL.\n \\param input    The ciphertext buffer. This must be a readable buffer\n                 of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                 for an 2048-bit RSA modulus.\n \\param output   The buffer used to hold the plaintext. This must\n                 be a writable buffer of length \\p output_max_len Bytes.\n \\param output_max_len The length in Bytes of the output buffer \\p output.\n\n \\return         \\c 0 on success.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure.\n"]
    pub fn mbedtls_rsa_rsaes_pkcs1_v15_decrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        olen: *mut usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
        output_max_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief            This function performs a PKCS#1 v2.1 OAEP decryption\n                   operation (RSAES-OAEP-DECRYPT).\n\n \\note             The output buffer length \\c output_max_len should be\n                   as large as the size \\p ctx->len of \\p ctx->N, for\n                   example, 128 Bytes if RSA-1024 is used, to be able to\n                   hold an arbitrary decrypted message. If it is not\n                   large enough to hold the decryption of the particular\n                   ciphertext provided, the function returns\n                   #MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE.\n\n \\param ctx        The initialized RSA context to use.\n \\param f_rng      The RNG function. This is used for blinding and is\n                   mandatory.\n \\param p_rng      The RNG context to be passed to \\p f_rng. This may be\n                   \\c NULL if \\p f_rng doesn't need a context.\n \\param label      The buffer holding the custom label to use.\n                   This must be a readable buffer of length \\p label_len\n                   Bytes. It may be \\c NULL if \\p label_len is \\c 0.\n \\param label_len  The length of the label in Bytes.\n \\param olen       The address at which to store the length of\n                   the plaintext. This must not be \\c NULL.\n \\param input      The ciphertext buffer. This must be a readable buffer\n                   of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                   for an 2048-bit RSA modulus.\n \\param output     The buffer used to hold the plaintext. This must\n                   be a writable buffer of length \\p output_max_len Bytes.\n \\param output_max_len The length in Bytes of the output buffer \\p output.\n\n \\return         \\c 0 on success.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsaes_oaep_decrypt(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        label: *const crate::c_types::c_uchar,
        label_len: usize,
        olen: *mut usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
        output_max_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a private RSA operation to sign\n                 a message digest using PKCS#1.\n\n                 It is the generic wrapper for performing a PKCS#1\n                 signature.\n\n \\note           The \\p sig buffer must be as large as the size\n                 of \\p ctx->N. For example, 128 Bytes if RSA-1024 is used.\n\n \\note           For PKCS#1 v2.1 encoding, see comments on\n                 mbedtls_rsa_rsassa_pss_sign() for details on\n                 \\p md_alg and \\p hash_id.\n\n \\param ctx      The initialized RSA context to use.\n \\param f_rng    The RNG function to use. This is mandatory and\n                 must not be \\c NULL.\n \\param p_rng    The RNG context to be passed to \\p f_rng. This may be \\c NULL\n                 if \\p f_rng doesn't need a context argument.\n \\param md_alg   The message-digest algorithm used to hash the original data.\n                 Use #MBEDTLS_MD_NONE for signing raw data.\n \\param hashlen  The length of the message digest or raw data in Bytes.\n                 If \\p md_alg is not #MBEDTLS_MD_NONE, this must match the\n                 output length of the corresponding hash algorithm.\n \\param hash     The buffer holding the message digest or raw data.\n                 This must be a readable buffer of at least \\p hashlen Bytes.\n \\param sig      The buffer to hold the signature. This must be a writable\n                 buffer of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                 for an 2048-bit RSA modulus. A buffer length of\n                 #MBEDTLS_MPI_MAX_SIZE is always safe.\n\n \\return         \\c 0 if the signing operation was successful.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_pkcs1_sign(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        md_alg: mbedtls_md_type_t,
        hashlen: crate::c_types::c_uint,
        hash: *const crate::c_types::c_uchar,
        sig: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v1.5 signature\n                 operation (RSASSA-PKCS1-v1_5-SIGN).\n\n \\param ctx      The initialized RSA context to use.\n \\param f_rng    The RNG function. This is used for blinding and is\n                 mandatory; see mbedtls_rsa_private() for more.\n \\param p_rng    The RNG context to be passed to \\p f_rng. This may be \\c NULL\n                 if \\p f_rng doesn't need a context argument.\n \\param md_alg   The message-digest algorithm used to hash the original data.\n                 Use #MBEDTLS_MD_NONE for signing raw data.\n \\param hashlen  The length of the message digest or raw data in Bytes.\n                 If \\p md_alg is not #MBEDTLS_MD_NONE, this must match the\n                 output length of the corresponding hash algorithm.\n \\param hash     The buffer holding the message digest or raw data.\n                 This must be a readable buffer of at least \\p hashlen Bytes.\n \\param sig      The buffer to hold the signature. This must be a writable\n                 buffer of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                 for an 2048-bit RSA modulus. A buffer length of\n                 #MBEDTLS_MPI_MAX_SIZE is always safe.\n\n \\return         \\c 0 if the signing operation was successful.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsassa_pkcs1_v15_sign(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        md_alg: mbedtls_md_type_t,
        hashlen: crate::c_types::c_uint,
        hash: *const crate::c_types::c_uchar,
        sig: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v2.1 PSS signature\n                 operation (RSASSA-PSS-SIGN).\n\n \\note           The \\c hash_id set in \\p ctx by calling\n                 mbedtls_rsa_set_padding() selects the hash used for the\n                 encoding operation and for the mask generation function\n                 (MGF1). For more details on the encoding operation and the\n                 mask generation function, consult <em>RFC-3447: Public-Key\n                 Cryptography Standards (PKCS) #1 v2.1: RSA Cryptography\n                 Specifications</em>.\n\n \\note           This function enforces that the provided salt length complies\n                 with FIPS 186-4 §5.5 (e) and RFC 8017 (PKCS#1 v2.2) §9.1.1\n                 step 3. The constraint is that the hash length plus the salt\n                 length plus 2 bytes must be at most the key length. If this\n                 constraint is not met, this function returns\n                 #MBEDTLS_ERR_RSA_BAD_INPUT_DATA.\n\n \\param ctx      The initialized RSA context to use.\n \\param f_rng    The RNG function. It is mandatory and must not be \\c NULL.\n \\param p_rng    The RNG context to be passed to \\p f_rng. This may be \\c NULL\n                 if \\p f_rng doesn't need a context argument.\n \\param md_alg   The message-digest algorithm used to hash the original data.\n                 Use #MBEDTLS_MD_NONE for signing raw data.\n \\param hashlen  The length of the message digest or raw data in Bytes.\n                 If \\p md_alg is not #MBEDTLS_MD_NONE, this must match the\n                 output length of the corresponding hash algorithm.\n \\param hash     The buffer holding the message digest or raw data.\n                 This must be a readable buffer of at least \\p hashlen Bytes.\n \\param saltlen  The length of the salt that should be used.\n                 If passed #MBEDTLS_RSA_SALT_LEN_ANY, the function will use\n                 the largest possible salt length up to the hash length,\n                 which is the largest permitted by some standards including\n                 FIPS 186-4 §5.5.\n \\param sig      The buffer to hold the signature. This must be a writable\n                 buffer of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                 for an 2048-bit RSA modulus. A buffer length of\n                 #MBEDTLS_MPI_MAX_SIZE is always safe.\n\n \\return         \\c 0 if the signing operation was successful.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsassa_pss_sign_ext(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        md_alg: mbedtls_md_type_t,
        hashlen: crate::c_types::c_uint,
        hash: *const crate::c_types::c_uchar,
        saltlen: crate::c_types::c_int,
        sig: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v2.1 PSS signature\n                 operation (RSASSA-PSS-SIGN).\n\n \\note           The \\c hash_id set in \\p ctx by calling\n                 mbedtls_rsa_set_padding() selects the hash used for the\n                 encoding operation and for the mask generation function\n                 (MGF1). For more details on the encoding operation and the\n                 mask generation function, consult <em>RFC-3447: Public-Key\n                 Cryptography Standards (PKCS) #1 v2.1: RSA Cryptography\n                 Specifications</em>.\n\n \\note           This function always uses the maximum possible salt size,\n                 up to the length of the payload hash. This choice of salt\n                 size complies with FIPS 186-4 §5.5 (e) and RFC 8017 (PKCS#1\n                 v2.2) §9.1.1 step 3. Furthermore this function enforces a\n                 minimum salt size which is the hash size minus 2 bytes. If\n                 this minimum size is too large given the key size (the salt\n                 size, plus the hash size, plus 2 bytes must be no more than\n                 the key size in bytes), this function returns\n                 #MBEDTLS_ERR_RSA_BAD_INPUT_DATA.\n\n \\param ctx      The initialized RSA context to use.\n \\param f_rng    The RNG function. It is mandatory and must not be \\c NULL.\n \\param p_rng    The RNG context to be passed to \\p f_rng. This may be \\c NULL\n                 if \\p f_rng doesn't need a context argument.\n \\param md_alg   The message-digest algorithm used to hash the original data.\n                 Use #MBEDTLS_MD_NONE for signing raw data.\n \\param hashlen  The length of the message digest or raw data in Bytes.\n                 If \\p md_alg is not #MBEDTLS_MD_NONE, this must match the\n                 output length of the corresponding hash algorithm.\n \\param hash     The buffer holding the message digest or raw data.\n                 This must be a readable buffer of at least \\p hashlen Bytes.\n \\param sig      The buffer to hold the signature. This must be a writable\n                 buffer of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                 for an 2048-bit RSA modulus. A buffer length of\n                 #MBEDTLS_MPI_MAX_SIZE is always safe.\n\n \\return         \\c 0 if the signing operation was successful.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsassa_pss_sign(
        ctx: *mut mbedtls_rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        md_alg: mbedtls_md_type_t,
        hashlen: crate::c_types::c_uint,
        hash: *const crate::c_types::c_uchar,
        sig: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a public RSA operation and checks\n                 the message digest.\n\n                 This is the generic wrapper for performing a PKCS#1\n                 verification.\n\n \\note           For PKCS#1 v2.1 encoding, see comments on\n                 mbedtls_rsa_rsassa_pss_verify() about \\p md_alg and\n                 \\p hash_id.\n\n \\param ctx      The initialized RSA public key context to use.\n \\param md_alg   The message-digest algorithm used to hash the original data.\n                 Use #MBEDTLS_MD_NONE for signing raw data.\n \\param hashlen  The length of the message digest or raw data in Bytes.\n                 If \\p md_alg is not #MBEDTLS_MD_NONE, this must match the\n                 output length of the corresponding hash algorithm.\n \\param hash     The buffer holding the message digest or raw data.\n                 This must be a readable buffer of at least \\p hashlen Bytes.\n \\param sig      The buffer holding the signature. This must be a readable\n                 buffer of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                 for an 2048-bit RSA modulus.\n\n \\return         \\c 0 if the verify operation was successful.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_pkcs1_verify(
        ctx: *mut mbedtls_rsa_context,
        md_alg: mbedtls_md_type_t,
        hashlen: crate::c_types::c_uint,
        hash: *const crate::c_types::c_uchar,
        sig: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v1.5 verification\n                 operation (RSASSA-PKCS1-v1_5-VERIFY).\n\n \\param ctx      The initialized RSA public key context to use.\n \\param md_alg   The message-digest algorithm used to hash the original data.\n                 Use #MBEDTLS_MD_NONE for signing raw data.\n \\param hashlen  The length of the message digest or raw data in Bytes.\n                 If \\p md_alg is not #MBEDTLS_MD_NONE, this must match the\n                 output length of the corresponding hash algorithm.\n \\param hash     The buffer holding the message digest or raw data.\n                 This must be a readable buffer of at least \\p hashlen Bytes.\n \\param sig      The buffer holding the signature. This must be a readable\n                 buffer of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                 for an 2048-bit RSA modulus.\n\n \\return         \\c 0 if the verify operation was successful.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsassa_pkcs1_v15_verify(
        ctx: *mut mbedtls_rsa_context,
        md_alg: mbedtls_md_type_t,
        hashlen: crate::c_types::c_uint,
        hash: *const crate::c_types::c_uchar,
        sig: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v2.1 PSS verification\n                 operation (RSASSA-PSS-VERIFY).\n\n \\note           The \\c hash_id set in \\p ctx by calling\n                 mbedtls_rsa_set_padding() selects the hash used for the\n                 encoding operation and for the mask generation function\n                 (MGF1). For more details on the encoding operation and the\n                 mask generation function, consult <em>RFC-3447: Public-Key\n                 Cryptography Standards (PKCS) #1 v2.1: RSA Cryptography\n                 Specifications</em>. If the \\c hash_id set in \\p ctx by\n                 mbedtls_rsa_set_padding() is #MBEDTLS_MD_NONE, the \\p md_alg\n                 parameter is used.\n\n \\param ctx      The initialized RSA public key context to use.\n \\param md_alg   The message-digest algorithm used to hash the original data.\n                 Use #MBEDTLS_MD_NONE for signing raw data.\n \\param hashlen  The length of the message digest or raw data in Bytes.\n                 If \\p md_alg is not #MBEDTLS_MD_NONE, this must match the\n                 output length of the corresponding hash algorithm.\n \\param hash     The buffer holding the message digest or raw data.\n                 This must be a readable buffer of at least \\p hashlen Bytes.\n \\param sig      The buffer holding the signature. This must be a readable\n                 buffer of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                 for an 2048-bit RSA modulus.\n\n \\return         \\c 0 if the verify operation was successful.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsassa_pss_verify(
        ctx: *mut mbedtls_rsa_context,
        md_alg: mbedtls_md_type_t,
        hashlen: crate::c_types::c_uint,
        hash: *const crate::c_types::c_uchar,
        sig: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs a PKCS#1 v2.1 PSS verification\n                 operation (RSASSA-PSS-VERIFY).\n\n \\note           The \\p sig buffer must be as large as the size\n                 of \\p ctx->N. For example, 128 Bytes if RSA-1024 is used.\n\n \\note           The \\c hash_id set in \\p ctx by mbedtls_rsa_set_padding() is\n                 ignored.\n\n \\param ctx      The initialized RSA public key context to use.\n \\param md_alg   The message-digest algorithm used to hash the original data.\n                 Use #MBEDTLS_MD_NONE for signing raw data.\n \\param hashlen  The length of the message digest or raw data in Bytes.\n                 If \\p md_alg is not #MBEDTLS_MD_NONE, this must match the\n                 output length of the corresponding hash algorithm.\n \\param hash     The buffer holding the message digest or raw data.\n                 This must be a readable buffer of at least \\p hashlen Bytes.\n \\param mgf1_hash_id      The message digest algorithm used for the\n                          verification operation and the mask generation\n                          function (MGF1). For more details on the encoding\n                          operation and the mask generation function, consult\n                          <em>RFC-3447: Public-Key Cryptography Standards\n                          (PKCS) #1 v2.1: RSA Cryptography\n                          Specifications</em>.\n \\param expected_salt_len The length of the salt used in padding. Use\n                          #MBEDTLS_RSA_SALT_LEN_ANY to accept any salt length.\n \\param sig      The buffer holding the signature. This must be a readable\n                 buffer of length \\c ctx->len Bytes. For example, \\c 256 Bytes\n                 for an 2048-bit RSA modulus.\n\n \\return         \\c 0 if the verify operation was successful.\n \\return         An \\c MBEDTLS_ERR_RSA_XXX error code on failure."]
    pub fn mbedtls_rsa_rsassa_pss_verify_ext(
        ctx: *mut mbedtls_rsa_context,
        md_alg: mbedtls_md_type_t,
        hashlen: crate::c_types::c_uint,
        hash: *const crate::c_types::c_uchar,
        mgf1_hash_id: mbedtls_md_type_t,
        expected_salt_len: crate::c_types::c_int,
        sig: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function copies the components of an RSA context.\n\n \\param dst      The destination context. This must be initialized.\n \\param src      The source context. This must be initialized.\n\n \\return         \\c 0 on success.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory allocation failure."]
    pub fn mbedtls_rsa_copy(
        dst: *mut mbedtls_rsa_context,
        src: *const mbedtls_rsa_context,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function frees the components of an RSA key.\n\n \\param ctx      The RSA context to free. May be \\c NULL, in which case\n                 this function is a no-op. If it is not \\c NULL, it must\n                 point to an initialized RSA context."]
    pub fn mbedtls_rsa_free(ctx: *mut mbedtls_rsa_context);
}
extern "C" {
    #[doc = " \\brief          The RSA checkup routine.\n\n \\return         \\c 0 on success.\n \\return         \\c 1 on failure."]
    pub fn mbedtls_rsa_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[doc = " \\brief           The ECDSA context structure.\n\n \\warning         Performing multiple operations concurrently on the same\n                  ECDSA context is not supported; objects of this type\n                  should not be shared between multiple threads.\n\n \\note            pk_wrap module assumes that \"ecdsa_context\" is identical\n                  to \"ecp_keypair\" (see for example structure\n                  \"mbedtls_eckey_info\" where ECDSA sign/verify functions\n                  are used also for EC key)"]
pub type mbedtls_ecdsa_context = mbedtls_ecp_keypair;
pub type mbedtls_ecdsa_restart_ctx = crate::c_types::c_void;
extern "C" {
    #[doc = " \\brief          This function checks whether a given group can be used\n                 for ECDSA.\n\n \\param gid      The ECP group ID to check.\n\n \\return         \\c 1 if the group can be used, \\c 0 otherwise"]
    pub fn mbedtls_ecdsa_can_do(gid: mbedtls_ecp_group_id) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function computes the ECDSA signature of a\n                  previously-hashed message.\n\n \\note            The deterministic version implemented in\n                  mbedtls_ecdsa_sign_det_ext() is usually preferred.\n\n \\note            If the bitlength of the message hash is larger than the\n                  bitlength of the group order, then the hash is truncated\n                  as defined in <em>Standards for Efficient Cryptography Group\n                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section\n                  4.1.3, step 5.\n\n \\see             ecp.h\n\n \\param grp       The context for the elliptic curve to use.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param r         The MPI context in which to store the first part\n                  the signature. This must be initialized.\n \\param s         The MPI context in which to store the second part\n                  the signature. This must be initialized.\n \\param d         The private signing key. This must be initialized.\n \\param buf       The content to be signed. This is usually the hash of\n                  the original data to be signed. This must be a readable\n                  buffer of length \\p blen Bytes. It may be \\c NULL if\n                  \\p blen is zero.\n \\param blen      The length of \\p buf in Bytes.\n \\param f_rng     The RNG function. This must not be \\c NULL.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may be\n                  \\c NULL if \\p f_rng doesn't need a context parameter.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX\n                  or \\c MBEDTLS_MPI_XXX error code on failure."]
    pub fn mbedtls_ecdsa_sign(
        grp: *mut mbedtls_ecp_group,
        r: *mut mbedtls_mpi,
        s: *mut mbedtls_mpi,
        d: *const mbedtls_mpi,
        buf: *const crate::c_types::c_uchar,
        blen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function computes the ECDSA signature of a\n                  previously-hashed message, deterministic version.\n\n                  For more information, see <em>RFC-6979: Deterministic\n                  Usage of the Digital Signature Algorithm (DSA) and Elliptic\n                  Curve Digital Signature Algorithm (ECDSA)</em>.\n\n \\note            If the bitlength of the message hash is larger than the\n                  bitlength of the group order, then the hash is truncated as\n                  defined in <em>Standards for Efficient Cryptography Group\n                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section\n                  4.1.3, step 5.\n\n \\see             ecp.h\n\n \\param grp           The context for the elliptic curve to use.\n                      This must be initialized and have group parameters\n                      set, for example through mbedtls_ecp_group_load().\n \\param r             The MPI context in which to store the first part\n                      the signature. This must be initialized.\n \\param s             The MPI context in which to store the second part\n                      the signature. This must be initialized.\n \\param d             The private signing key. This must be initialized\n                      and setup, for example through mbedtls_ecp_gen_privkey().\n \\param buf           The hashed content to be signed. This must be a readable\n                      buffer of length \\p blen Bytes. It may be \\c NULL if\n                      \\p blen is zero.\n \\param blen          The length of \\p buf in Bytes.\n \\param md_alg        The hash algorithm used to hash the original data.\n \\param f_rng_blind   The RNG function used for blinding. This must not be\n                      \\c NULL.\n \\param p_rng_blind   The RNG context to be passed to \\p f_rng. This may be\n                      \\c NULL if \\p f_rng doesn't need a context parameter.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX\n                  error code on failure."]
    pub fn mbedtls_ecdsa_sign_det_ext(
        grp: *mut mbedtls_ecp_group,
        r: *mut mbedtls_mpi,
        s: *mut mbedtls_mpi,
        d: *const mbedtls_mpi,
        buf: *const crate::c_types::c_uchar,
        blen: usize,
        md_alg: mbedtls_md_type_t,
        f_rng_blind: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng_blind: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function computes the ECDSA signature of a\n                      previously-hashed message, in a restartable way.\n\n \\note                The deterministic version implemented in\n                      mbedtls_ecdsa_sign_det_restartable() is usually\n                      preferred.\n\n \\note                This function is like \\c mbedtls_ecdsa_sign() but\n                      it can return early and restart according to the\n                      limit set with \\c mbedtls_ecp_set_max_ops() to\n                      reduce blocking.\n\n \\note                If the bitlength of the message hash is larger\n                      than the bitlength of the group order, then the\n                      hash is truncated as defined in <em>Standards for\n                      Efficient Cryptography Group (SECG): SEC1 Elliptic\n                      Curve Cryptography</em>, section 4.1.3, step 5.\n\n \\see                 ecp.h\n\n \\param grp           The context for the elliptic curve to use.\n                      This must be initialized and have group parameters\n                      set, for example through mbedtls_ecp_group_load().\n \\param r             The MPI context in which to store the first part\n                      the signature. This must be initialized.\n \\param s             The MPI context in which to store the second part\n                      the signature. This must be initialized.\n \\param d             The private signing key. This must be initialized\n                      and setup, for example through\n                      mbedtls_ecp_gen_privkey().\n \\param buf           The hashed content to be signed. This must be a readable\n                      buffer of length \\p blen Bytes. It may be \\c NULL if\n                      \\p blen is zero.\n \\param blen          The length of \\p buf in Bytes.\n \\param f_rng         The RNG function. This must not be \\c NULL.\n \\param p_rng         The RNG context to be passed to \\p f_rng. This may be\n                      \\c NULL if \\p f_rng doesn't need a context parameter.\n \\param f_rng_blind   The RNG function used for blinding. This must not be\n                      \\c NULL.\n \\param p_rng_blind   The RNG context to be passed to \\p f_rng. This may be\n                      \\c NULL if \\p f_rng doesn't need a context parameter.\n \\param rs_ctx        The restart context to use. This may be \\c NULL\n                      to disable restarting. If it is not \\c NULL, it\n                      must point to an initialized restart context.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of\n                      operations was reached: see \\c\n                      mbedtls_ecp_set_max_ops().\n \\return              Another \\c MBEDTLS_ERR_ECP_XXX, \\c\n                      MBEDTLS_ERR_MPI_XXX or \\c MBEDTLS_ERR_ASN1_XXX\n                      error code on failure."]
    pub fn mbedtls_ecdsa_sign_restartable(
        grp: *mut mbedtls_ecp_group,
        r: *mut mbedtls_mpi,
        s: *mut mbedtls_mpi,
        d: *const mbedtls_mpi,
        buf: *const crate::c_types::c_uchar,
        blen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        f_rng_blind: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng_blind: *mut crate::c_types::c_void,
        rs_ctx: *mut mbedtls_ecdsa_restart_ctx,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function computes the ECDSA signature of a\n                      previously-hashed message, in a restartable way.\n\n \\note                This function is like \\c\n                      mbedtls_ecdsa_sign_det_ext() but it can return\n                      early and restart according to the limit set with\n                      \\c mbedtls_ecp_set_max_ops() to reduce blocking.\n\n \\note                If the bitlength of the message hash is larger\n                      than the bitlength of the group order, then the\n                      hash is truncated as defined in <em>Standards for\n                      Efficient Cryptography Group (SECG): SEC1 Elliptic\n                      Curve Cryptography</em>, section 4.1.3, step 5.\n\n \\see                 ecp.h\n\n \\param grp           The context for the elliptic curve to use.\n                      This must be initialized and have group parameters\n                      set, for example through mbedtls_ecp_group_load().\n \\param r             The MPI context in which to store the first part\n                      the signature. This must be initialized.\n \\param s             The MPI context in which to store the second part\n                      the signature. This must be initialized.\n \\param d             The private signing key. This must be initialized\n                      and setup, for example through\n                      mbedtls_ecp_gen_privkey().\n \\param buf           The hashed content to be signed. This must be a readable\n                      buffer of length \\p blen Bytes. It may be \\c NULL if\n                      \\p blen is zero.\n \\param blen          The length of \\p buf in Bytes.\n \\param f_rng_blind   The RNG function used for blinding. This must not be\n                      \\c NULL.\n \\param p_rng_blind   The RNG context to be passed to \\p f_rng. This may be\n                      \\c NULL if \\p f_rng doesn't need a context parameter.\n \\param rs_ctx        The restart context to use. This may be \\c NULL\n                      to disable restarting. If it is not \\c NULL, it\n                      must point to an initialized restart context.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of\n                      operations was reached: see \\c\n                      mbedtls_ecp_set_max_ops().\n \\return              Another \\c MBEDTLS_ERR_ECP_XXX, \\c\n                      MBEDTLS_ERR_MPI_XXX or \\c MBEDTLS_ERR_ASN1_XXX\n                      error code on failure."]
    pub fn mbedtls_ecdsa_sign_det_restartable(
        grp: *mut mbedtls_ecp_group,
        r: *mut mbedtls_mpi,
        s: *mut mbedtls_mpi,
        d: *const mbedtls_mpi,
        buf: *const crate::c_types::c_uchar,
        blen: usize,
        md_alg: mbedtls_md_type_t,
        f_rng_blind: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng_blind: *mut crate::c_types::c_void,
        rs_ctx: *mut mbedtls_ecdsa_restart_ctx,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function verifies the ECDSA signature of a\n                  previously-hashed message.\n\n \\note            If the bitlength of the message hash is larger than the\n                  bitlength of the group order, then the hash is truncated as\n                  defined in <em>Standards for Efficient Cryptography Group\n                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section\n                  4.1.4, step 3.\n\n \\see             ecp.h\n\n \\param grp       The ECP group to use.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param buf       The hashed content that was signed. This must be a readable\n                  buffer of length \\p blen Bytes. It may be \\c NULL if\n                  \\p blen is zero.\n \\param blen      The length of \\p buf in Bytes.\n \\param Q         The public key to use for verification. This must be\n                  initialized and setup.\n \\param r         The first integer of the signature.\n                  This must be initialized.\n \\param s         The second integer of the signature.\n                  This must be initialized.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX\n                  error code on failure."]
    pub fn mbedtls_ecdsa_verify(
        grp: *mut mbedtls_ecp_group,
        buf: *const crate::c_types::c_uchar,
        blen: usize,
        Q: *const mbedtls_ecp_point,
        r: *const mbedtls_mpi,
        s: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function verifies the ECDSA signature of a\n                  previously-hashed message, in a restartable manner\n\n \\note            If the bitlength of the message hash is larger than the\n                  bitlength of the group order, then the hash is truncated as\n                  defined in <em>Standards for Efficient Cryptography Group\n                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section\n                  4.1.4, step 3.\n\n \\see             ecp.h\n\n \\param grp       The ECP group to use.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param buf       The hashed content that was signed. This must be a readable\n                  buffer of length \\p blen Bytes. It may be \\c NULL if\n                  \\p blen is zero.\n \\param blen      The length of \\p buf in Bytes.\n \\param Q         The public key to use for verification. This must be\n                  initialized and setup.\n \\param r         The first integer of the signature.\n                  This must be initialized.\n \\param s         The second integer of the signature.\n                  This must be initialized.\n \\param rs_ctx    The restart context to use. This may be \\c NULL to disable\n                  restarting. If it is not \\c NULL, it must point to an\n                  initialized restart context.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of\n                  operations was reached: see \\c mbedtls_ecp_set_max_ops().\n \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX\n                  error code on failure."]
    pub fn mbedtls_ecdsa_verify_restartable(
        grp: *mut mbedtls_ecp_group,
        buf: *const crate::c_types::c_uchar,
        blen: usize,
        Q: *const mbedtls_ecp_point,
        r: *const mbedtls_mpi,
        s: *const mbedtls_mpi,
        rs_ctx: *mut mbedtls_ecdsa_restart_ctx,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function computes the ECDSA signature and writes it\n                  to a buffer, serialized as defined in <em>RFC-4492:\n                  Elliptic Curve Cryptography (ECC) Cipher Suites for\n                  Transport Layer Security (TLS)</em>.\n\n \\warning         It is not thread-safe to use the same context in\n                  multiple threads.\n\n \\note            The deterministic version is used if\n                  #MBEDTLS_ECDSA_DETERMINISTIC is defined. For more\n                  information, see <em>RFC-6979: Deterministic Usage\n                  of the Digital Signature Algorithm (DSA) and Elliptic\n                  Curve Digital Signature Algorithm (ECDSA)</em>.\n\n \\note            If the bitlength of the message hash is larger than the\n                  bitlength of the group order, then the hash is truncated as\n                  defined in <em>Standards for Efficient Cryptography Group\n                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section\n                  4.1.3, step 5.\n\n \\see             ecp.h\n\n \\param ctx       The ECDSA context to use. This must be initialized\n                  and have a group and private key bound to it, for example\n                  via mbedtls_ecdsa_genkey() or mbedtls_ecdsa_from_keypair().\n \\param md_alg    The message digest that was used to hash the message.\n \\param hash      The message hash to be signed. This must be a readable\n                  buffer of length \\p blen Bytes.\n \\param hlen      The length of the hash \\p hash in Bytes.\n \\param sig       The buffer to which to write the signature. This must be a\n                  writable buffer of length at least twice as large as the\n                  size of the curve used, plus 9. For example, 73 Bytes if\n                  a 256-bit curve is used. A buffer length of\n                  #MBEDTLS_ECDSA_MAX_LEN is always safe.\n \\param sig_size  The size of the \\p sig buffer in bytes.\n \\param slen      The address at which to store the actual length of\n                  the signature written. Must not be \\c NULL.\n \\param f_rng     The RNG function. This must not be \\c NULL if\n                  #MBEDTLS_ECDSA_DETERMINISTIC is unset. Otherwise,\n                  it is used only for blinding and may be set to \\c NULL, but\n                  doing so is DEPRECATED.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may be\n                  \\c NULL if \\p f_rng is \\c NULL or doesn't use a context.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX, \\c MBEDTLS_ERR_MPI_XXX or\n                  \\c MBEDTLS_ERR_ASN1_XXX error code on failure."]
    pub fn mbedtls_ecdsa_write_signature(
        ctx: *mut mbedtls_ecdsa_context,
        md_alg: mbedtls_md_type_t,
        hash: *const crate::c_types::c_uchar,
        hlen: usize,
        sig: *mut crate::c_types::c_uchar,
        sig_size: usize,
        slen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function computes the ECDSA signature and writes it\n                  to a buffer, in a restartable way.\n\n \\see             \\c mbedtls_ecdsa_write_signature()\n\n \\note            This function is like \\c mbedtls_ecdsa_write_signature()\n                  but it can return early and restart according to the limit\n                  set with \\c mbedtls_ecp_set_max_ops() to reduce blocking.\n\n \\param ctx       The ECDSA context to use. This must be initialized\n                  and have a group and private key bound to it, for example\n                  via mbedtls_ecdsa_genkey() or mbedtls_ecdsa_from_keypair().\n \\param md_alg    The message digest that was used to hash the message.\n \\param hash      The message hash to be signed. This must be a readable\n                  buffer of length \\p blen Bytes.\n \\param hlen      The length of the hash \\p hash in Bytes.\n \\param sig       The buffer to which to write the signature. This must be a\n                  writable buffer of length at least twice as large as the\n                  size of the curve used, plus 9. For example, 73 Bytes if\n                  a 256-bit curve is used. A buffer length of\n                  #MBEDTLS_ECDSA_MAX_LEN is always safe.\n \\param sig_size  The size of the \\p sig buffer in bytes.\n \\param slen      The address at which to store the actual length of\n                  the signature written. Must not be \\c NULL.\n \\param f_rng     The RNG function. This must not be \\c NULL if\n                  #MBEDTLS_ECDSA_DETERMINISTIC is unset. Otherwise,\n                  it is unused and may be set to \\c NULL.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may be\n                  \\c NULL if \\p f_rng is \\c NULL or doesn't use a context.\n \\param rs_ctx    The restart context to use. This may be \\c NULL to disable\n                  restarting. If it is not \\c NULL, it must point to an\n                  initialized restart context.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of\n                  operations was reached: see \\c mbedtls_ecp_set_max_ops().\n \\return          Another \\c MBEDTLS_ERR_ECP_XXX, \\c MBEDTLS_ERR_MPI_XXX or\n                  \\c MBEDTLS_ERR_ASN1_XXX error code on failure."]
    pub fn mbedtls_ecdsa_write_signature_restartable(
        ctx: *mut mbedtls_ecdsa_context,
        md_alg: mbedtls_md_type_t,
        hash: *const crate::c_types::c_uchar,
        hlen: usize,
        sig: *mut crate::c_types::c_uchar,
        sig_size: usize,
        slen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        rs_ctx: *mut mbedtls_ecdsa_restart_ctx,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function reads and verifies an ECDSA signature.\n\n \\note            If the bitlength of the message hash is larger than the\n                  bitlength of the group order, then the hash is truncated as\n                  defined in <em>Standards for Efficient Cryptography Group\n                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section\n                  4.1.4, step 3.\n\n \\see             ecp.h\n\n \\param ctx       The ECDSA context to use. This must be initialized\n                  and have a group and public key bound to it.\n \\param hash      The message hash that was signed. This must be a readable\n                  buffer of length \\p size Bytes.\n \\param hlen      The size of the hash \\p hash.\n \\param sig       The signature to read and verify. This must be a readable\n                  buffer of length \\p slen Bytes.\n \\param slen      The size of \\p sig in Bytes.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if signature is invalid.\n \\return          #MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH if there is a valid\n                  signature in \\p sig, but its length is less than \\p siglen.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_ERR_MPI_XXX\n                  error code on failure for any other reason."]
    pub fn mbedtls_ecdsa_read_signature(
        ctx: *mut mbedtls_ecdsa_context,
        hash: *const crate::c_types::c_uchar,
        hlen: usize,
        sig: *const crate::c_types::c_uchar,
        slen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function reads and verifies an ECDSA signature,\n                  in a restartable way.\n\n \\see             \\c mbedtls_ecdsa_read_signature()\n\n \\note            This function is like \\c mbedtls_ecdsa_read_signature()\n                  but it can return early and restart according to the limit\n                  set with \\c mbedtls_ecp_set_max_ops() to reduce blocking.\n\n \\param ctx       The ECDSA context to use. This must be initialized\n                  and have a group and public key bound to it.\n \\param hash      The message hash that was signed. This must be a readable\n                  buffer of length \\p size Bytes.\n \\param hlen      The size of the hash \\p hash.\n \\param sig       The signature to read and verify. This must be a readable\n                  buffer of length \\p slen Bytes.\n \\param slen      The size of \\p sig in Bytes.\n \\param rs_ctx    The restart context to use. This may be \\c NULL to disable\n                  restarting. If it is not \\c NULL, it must point to an\n                  initialized restart context.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if signature is invalid.\n \\return          #MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH if there is a valid\n                  signature in \\p sig, but its length is less than \\p siglen.\n \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of\n                  operations was reached: see \\c mbedtls_ecp_set_max_ops().\n \\return          Another \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_ERR_MPI_XXX\n                  error code on failure for any other reason."]
    pub fn mbedtls_ecdsa_read_signature_restartable(
        ctx: *mut mbedtls_ecdsa_context,
        hash: *const crate::c_types::c_uchar,
        hlen: usize,
        sig: *const crate::c_types::c_uchar,
        slen: usize,
        rs_ctx: *mut mbedtls_ecdsa_restart_ctx,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function generates an ECDSA keypair on the given curve.\n\n \\see            ecp.h\n\n \\param ctx      The ECDSA context to store the keypair in.\n                 This must be initialized.\n \\param gid      The elliptic curve to use. One of the various\n                 \\c MBEDTLS_ECP_DP_XXX macros depending on configuration.\n \\param f_rng    The RNG function to use. This must not be \\c NULL.\n \\param p_rng    The RNG context to be passed to \\p f_rng. This may be\n                 \\c NULL if \\p f_rng doesn't need a context argument.\n\n \\return         \\c 0 on success.\n \\return         An \\c MBEDTLS_ERR_ECP_XXX code on failure."]
    pub fn mbedtls_ecdsa_genkey(
        ctx: *mut mbedtls_ecdsa_context,
        gid: mbedtls_ecp_group_id,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets up an ECDSA context from an EC key pair.\n\n \\see             ecp.h\n\n \\param ctx       The ECDSA context to setup. This must be initialized.\n \\param key       The EC key to use. This must be initialized and hold\n                  a private-public key pair or a public key. In the former\n                  case, the ECDSA context may be used for signature creation\n                  and verification after this call. In the latter case, it\n                  may be used for signature verification.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX code on failure."]
    pub fn mbedtls_ecdsa_from_keypair(
        ctx: *mut mbedtls_ecdsa_context,
        key: *const mbedtls_ecp_keypair,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function initializes an ECDSA context.\n\n \\param ctx       The ECDSA context to initialize.\n                  This must not be \\c NULL."]
    pub fn mbedtls_ecdsa_init(ctx: *mut mbedtls_ecdsa_context);
}
extern "C" {
    #[doc = " \\brief           This function frees an ECDSA context.\n\n \\param ctx       The ECDSA context to free. This may be \\c NULL,\n                  in which case this function does nothing. If it\n                  is not \\c NULL, it must be initialized."]
    pub fn mbedtls_ecdsa_free(ctx: *mut mbedtls_ecdsa_context);
}
pub const mbedtls_pk_type_t_MBEDTLS_PK_NONE: mbedtls_pk_type_t = 0;
pub const mbedtls_pk_type_t_MBEDTLS_PK_RSA: mbedtls_pk_type_t = 1;
pub const mbedtls_pk_type_t_MBEDTLS_PK_ECKEY: mbedtls_pk_type_t = 2;
pub const mbedtls_pk_type_t_MBEDTLS_PK_ECKEY_DH: mbedtls_pk_type_t = 3;
pub const mbedtls_pk_type_t_MBEDTLS_PK_ECDSA: mbedtls_pk_type_t = 4;
pub const mbedtls_pk_type_t_MBEDTLS_PK_RSA_ALT: mbedtls_pk_type_t = 5;
pub const mbedtls_pk_type_t_MBEDTLS_PK_RSASSA_PSS: mbedtls_pk_type_t = 6;
pub const mbedtls_pk_type_t_MBEDTLS_PK_OPAQUE: mbedtls_pk_type_t = 7;
#[doc = " \\brief          Public key types"]
pub type mbedtls_pk_type_t = crate::c_types::c_uint;
#[doc = " \\brief           Options for RSASSA-PSS signature verification.\n                  See \\c mbedtls_rsa_rsassa_pss_verify_ext()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_pk_rsassa_pss_options {
    #[doc = " The digest to use for MGF1 in PSS.\n\n \\note When #MBEDTLS_USE_PSA_CRYPTO is enabled and #MBEDTLS_RSA_C is\n       disabled, this must be equal to the \\c md_alg argument passed\n       to mbedtls_pk_verify_ext(). In a future version of the library,\n       this constraint may apply whenever #MBEDTLS_USE_PSA_CRYPTO is\n       enabled regardless of the status of #MBEDTLS_RSA_C."]
    pub mgf1_hash_id: mbedtls_md_type_t,
    #[doc = " The expected length of the salt, in bytes. This may be\n #MBEDTLS_RSA_SALT_LEN_ANY to accept any salt length.\n\n \\note When #MBEDTLS_USE_PSA_CRYPTO is enabled, only\n       #MBEDTLS_RSA_SALT_LEN_ANY is valid. Any other value may be\n       ignored (allowing any salt length)."]
    pub expected_salt_len: crate::c_types::c_int,
}
pub const mbedtls_pk_debug_type_MBEDTLS_PK_DEBUG_NONE: mbedtls_pk_debug_type = 0;
pub const mbedtls_pk_debug_type_MBEDTLS_PK_DEBUG_MPI: mbedtls_pk_debug_type = 1;
pub const mbedtls_pk_debug_type_MBEDTLS_PK_DEBUG_ECP: mbedtls_pk_debug_type = 2;
#[doc = " \\brief           Types for interfacing with the debug module"]
pub type mbedtls_pk_debug_type = crate::c_types::c_uint;
#[doc = " \\brief           Item to send to the debug module"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_pk_debug_item {
    pub private_type: mbedtls_pk_debug_type,
    pub private_name: *const crate::c_types::c_char,
    pub private_value: *mut crate::c_types::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_pk_info_t {
    _unused: [u8; 0],
}
#[doc = " \\brief           Public key container"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_pk_context {
    pub private_pk_info: *const mbedtls_pk_info_t,
    pub private_pk_ctx: *mut crate::c_types::c_void,
}
pub type mbedtls_pk_restart_ctx = crate::c_types::c_void;
#[doc = " \\brief           Types for RSA-alt abstraction"]
pub type mbedtls_pk_rsa_alt_decrypt_func = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::c_types::c_void,
        olen: *mut usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
        output_max_len: usize,
    ) -> crate::c_types::c_int,
>;
pub type mbedtls_pk_rsa_alt_sign_func = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::c_types::c_void,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        md_alg: mbedtls_md_type_t,
        hashlen: crate::c_types::c_uint,
        hash: *const crate::c_types::c_uchar,
        sig: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
pub type mbedtls_pk_rsa_alt_key_len_func =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut crate::c_types::c_void) -> usize>;
extern "C" {
    #[doc = " \\brief           Return information associated with the given PK type\n\n \\param pk_type   PK type to search for.\n\n \\return          The PK info associated with the type or NULL if not found."]
    pub fn mbedtls_pk_info_from_type(pk_type: mbedtls_pk_type_t) -> *const mbedtls_pk_info_t;
}
extern "C" {
    #[doc = " \\brief           Initialize a #mbedtls_pk_context (as NONE).\n\n \\param ctx       The context to initialize.\n                  This must not be \\c NULL."]
    pub fn mbedtls_pk_init(ctx: *mut mbedtls_pk_context);
}
extern "C" {
    #[doc = " \\brief           Free the components of a #mbedtls_pk_context.\n\n \\param ctx       The context to clear. It must have been initialized.\n                  If this is \\c NULL, this function does nothing.\n\n \\note            For contexts that have been set up with\n                  mbedtls_pk_setup_opaque(), this does not free the underlying\n                  PSA key and you still need to call psa_destroy_key()\n                  independently if you want to destroy that key."]
    pub fn mbedtls_pk_free(ctx: *mut mbedtls_pk_context);
}
extern "C" {
    #[doc = " \\brief           Initialize a PK context with the information given\n                  and allocates the type-specific PK subcontext.\n\n \\param ctx       Context to initialize. It must not have been set\n                  up yet (type #MBEDTLS_PK_NONE).\n \\param info      Information to use\n\n \\return          0 on success,\n                  MBEDTLS_ERR_PK_BAD_INPUT_DATA on invalid input,\n                  MBEDTLS_ERR_PK_ALLOC_FAILED on allocation failure.\n\n \\note            For contexts holding an RSA-alt key, use\n                  \\c mbedtls_pk_setup_rsa_alt() instead."]
    pub fn mbedtls_pk_setup(
        ctx: *mut mbedtls_pk_context,
        info: *const mbedtls_pk_info_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Initialize an RSA-alt context\n\n \\param ctx       Context to initialize. It must not have been set\n                  up yet (type #MBEDTLS_PK_NONE).\n \\param key       RSA key pointer\n \\param decrypt_func  Decryption function\n \\param sign_func     Signing function\n \\param key_len_func  Function returning key length in bytes\n\n \\return          0 on success, or MBEDTLS_ERR_PK_BAD_INPUT_DATA if the\n                  context wasn't already initialized as RSA_ALT.\n\n \\note            This function replaces \\c mbedtls_pk_setup() for RSA-alt."]
    pub fn mbedtls_pk_setup_rsa_alt(
        ctx: *mut mbedtls_pk_context,
        key: *mut crate::c_types::c_void,
        decrypt_func: mbedtls_pk_rsa_alt_decrypt_func,
        sign_func: mbedtls_pk_rsa_alt_sign_func,
        key_len_func: mbedtls_pk_rsa_alt_key_len_func,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Get the size in bits of the underlying key\n\n \\param ctx       The context to query. It must have been initialized.\n\n \\return          Key size in bits, or 0 on error"]
    pub fn mbedtls_pk_get_bitlen(ctx: *const mbedtls_pk_context) -> usize;
}
extern "C" {
    #[doc = " \\brief           Tell if a context can do the operation given by type\n\n \\param ctx       The context to query. It must have been initialized.\n \\param type      The desired type.\n\n \\return          1 if the context can do operations on the given type.\n \\return          0 if the context cannot do the operations on the given\n                  type. This is always the case for a context that has\n                  been initialized but not set up, or that has been\n                  cleared with mbedtls_pk_free()."]
    pub fn mbedtls_pk_can_do(
        ctx: *const mbedtls_pk_context,
        type_: mbedtls_pk_type_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Verify signature (including padding if relevant).\n\n \\param ctx       The PK context to use. It must have been set up.\n \\param md_alg    Hash algorithm used.\n                  This can be #MBEDTLS_MD_NONE if the signature algorithm\n                  does not rely on a hash algorithm (non-deterministic\n                  ECDSA, RSA PKCS#1 v1.5).\n                  For PKCS#1 v1.5, if \\p md_alg is #MBEDTLS_MD_NONE, then\n                  \\p hash is the DigestInfo structure used by RFC 8017\n                  &sect;9.2 steps 3&ndash;6. If \\p md_alg is a valid hash\n                  algorithm then \\p hash is the digest itself, and this\n                  function calculates the DigestInfo encoding internally.\n \\param hash      Hash of the message to sign\n \\param hash_len  Hash length\n \\param sig       Signature to verify\n \\param sig_len   Signature length\n\n \\return          0 on success (signature is valid),\n                  #MBEDTLS_ERR_PK_SIG_LEN_MISMATCH if there is a valid\n                  signature in sig but its length is less than \\p siglen,\n                  or a specific error code.\n\n \\note            For RSA keys, the default padding type is PKCS#1 v1.5.\n                  Use \\c mbedtls_pk_verify_ext( MBEDTLS_PK_RSASSA_PSS, ... )\n                  to verify RSASSA_PSS signatures."]
    pub fn mbedtls_pk_verify(
        ctx: *mut mbedtls_pk_context,
        md_alg: mbedtls_md_type_t,
        hash: *const crate::c_types::c_uchar,
        hash_len: usize,
        sig: *const crate::c_types::c_uchar,
        sig_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Restartable version of \\c mbedtls_pk_verify()\n\n \\note            Performs the same job as \\c mbedtls_pk_verify(), but can\n                  return early and restart according to the limit set with\n                  \\c mbedtls_ecp_set_max_ops() to reduce blocking for ECC\n                  operations. For RSA, same as \\c mbedtls_pk_verify().\n\n \\param ctx       The PK context to use. It must have been set up.\n \\param md_alg    Hash algorithm used (see notes)\n \\param hash      Hash of the message to sign\n \\param hash_len  Hash length or 0 (see notes)\n \\param sig       Signature to verify\n \\param sig_len   Signature length\n \\param rs_ctx    Restart context (NULL to disable restart)\n\n \\return          See \\c mbedtls_pk_verify(), or\n \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of\n                  operations was reached: see \\c mbedtls_ecp_set_max_ops()."]
    pub fn mbedtls_pk_verify_restartable(
        ctx: *mut mbedtls_pk_context,
        md_alg: mbedtls_md_type_t,
        hash: *const crate::c_types::c_uchar,
        hash_len: usize,
        sig: *const crate::c_types::c_uchar,
        sig_len: usize,
        rs_ctx: *mut mbedtls_pk_restart_ctx,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Verify signature, with options.\n                  (Includes verification of the padding depending on type.)\n\n \\param type      Signature type (inc. possible padding type) to verify\n \\param options   Pointer to type-specific options, or NULL\n \\param ctx       The PK context to use. It must have been set up.\n \\param md_alg    Hash algorithm used (see notes)\n \\param hash      Hash of the message to sign\n \\param hash_len  Hash length or 0 (see notes)\n \\param sig       Signature to verify\n \\param sig_len   Signature length\n\n \\return          0 on success (signature is valid),\n                  #MBEDTLS_ERR_PK_TYPE_MISMATCH if the PK context can't be\n                  used for this type of signatures,\n                  #MBEDTLS_ERR_PK_SIG_LEN_MISMATCH if there is a valid\n                  signature in sig but its length is less than \\p siglen,\n                  or a specific error code.\n\n \\note            If hash_len is 0, then the length associated with md_alg\n                  is used instead, or an error returned if it is invalid.\n\n \\note            md_alg may be MBEDTLS_MD_NONE, only if hash_len != 0\n\n \\note            If type is MBEDTLS_PK_RSASSA_PSS, then options must point\n                  to a mbedtls_pk_rsassa_pss_options structure,\n                  otherwise it must be NULL. Note that if\n                  #MBEDTLS_USE_PSA_CRYPTO is defined, the salt length is not\n                  verified as PSA_ALG_RSA_PSS_ANY_SALT is used."]
    pub fn mbedtls_pk_verify_ext(
        type_: mbedtls_pk_type_t,
        options: *const crate::c_types::c_void,
        ctx: *mut mbedtls_pk_context,
        md_alg: mbedtls_md_type_t,
        hash: *const crate::c_types::c_uchar,
        hash_len: usize,
        sig: *const crate::c_types::c_uchar,
        sig_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Make signature, including padding if relevant.\n\n \\param ctx       The PK context to use. It must have been set up\n                  with a private key.\n \\param md_alg    Hash algorithm used (see notes)\n \\param hash      Hash of the message to sign\n \\param hash_len  Hash length\n \\param sig       Place to write the signature.\n                  It must have enough room for the signature.\n                  #MBEDTLS_PK_SIGNATURE_MAX_SIZE is always enough.\n                  You may use a smaller buffer if it is large enough\n                  given the key type.\n \\param sig_size  The size of the \\p sig buffer in bytes.\n \\param sig_len   On successful return,\n                  the number of bytes written to \\p sig.\n \\param f_rng     RNG function, must not be \\c NULL.\n \\param p_rng     RNG parameter\n\n \\return          0 on success, or a specific error code.\n\n \\note            For RSA keys, the default padding type is PKCS#1 v1.5.\n                  There is no interface in the PK module to make RSASSA-PSS\n                  signatures yet.\n\n \\note            For RSA, md_alg may be MBEDTLS_MD_NONE if hash_len != 0.\n                  For ECDSA, md_alg may never be MBEDTLS_MD_NONE."]
    pub fn mbedtls_pk_sign(
        ctx: *mut mbedtls_pk_context,
        md_alg: mbedtls_md_type_t,
        hash: *const crate::c_types::c_uchar,
        hash_len: usize,
        sig: *mut crate::c_types::c_uchar,
        sig_size: usize,
        sig_len: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Make signature given a signature type.\n\n \\param pk_type   Signature type.\n \\param ctx       The PK context to use. It must have been set up\n                  with a private key.\n \\param md_alg    Hash algorithm used (see notes)\n \\param hash      Hash of the message to sign\n \\param hash_len  Hash length\n \\param sig       Place to write the signature.\n                  It must have enough room for the signature.\n                  #MBEDTLS_PK_SIGNATURE_MAX_SIZE is always enough.\n                  You may use a smaller buffer if it is large enough\n                  given the key type.\n \\param sig_size  The size of the \\p sig buffer in bytes.\n \\param sig_len   On successful return,\n                  the number of bytes written to \\p sig.\n \\param f_rng     RNG function, must not be \\c NULL.\n \\param p_rng     RNG parameter\n\n \\return          0 on success, or a specific error code.\n\n \\note            When \\p pk_type is #MBEDTLS_PK_RSASSA_PSS,\n                  see #PSA_ALG_RSA_PSS for a description of PSS options used.\n\n \\note            For RSA, md_alg may be MBEDTLS_MD_NONE if hash_len != 0.\n                  For ECDSA, md_alg may never be MBEDTLS_MD_NONE.\n"]
    pub fn mbedtls_pk_sign_ext(
        pk_type: mbedtls_pk_type_t,
        ctx: *mut mbedtls_pk_context,
        md_alg: mbedtls_md_type_t,
        hash: *const crate::c_types::c_uchar,
        hash_len: usize,
        sig: *mut crate::c_types::c_uchar,
        sig_size: usize,
        sig_len: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Restartable version of \\c mbedtls_pk_sign()\n\n \\note            Performs the same job as \\c mbedtls_pk_sign(), but can\n                  return early and restart according to the limit set with\n                  \\c mbedtls_ecp_set_max_ops() to reduce blocking for ECC\n                  operations. For RSA, same as \\c mbedtls_pk_sign().\n\n \\param ctx       The PK context to use. It must have been set up\n                  with a private key.\n \\param md_alg    Hash algorithm used (see notes for mbedtls_pk_sign())\n \\param hash      Hash of the message to sign\n \\param hash_len  Hash length\n \\param sig       Place to write the signature.\n                  It must have enough room for the signature.\n                  #MBEDTLS_PK_SIGNATURE_MAX_SIZE is always enough.\n                  You may use a smaller buffer if it is large enough\n                  given the key type.\n \\param sig_size  The size of the \\p sig buffer in bytes.\n \\param sig_len   On successful return,\n                  the number of bytes written to \\p sig.\n \\param f_rng     RNG function, must not be \\c NULL.\n \\param p_rng     RNG parameter\n \\param rs_ctx    Restart context (NULL to disable restart)\n\n \\return          See \\c mbedtls_pk_sign().\n \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of\n                  operations was reached: see \\c mbedtls_ecp_set_max_ops()."]
    pub fn mbedtls_pk_sign_restartable(
        ctx: *mut mbedtls_pk_context,
        md_alg: mbedtls_md_type_t,
        hash: *const crate::c_types::c_uchar,
        hash_len: usize,
        sig: *mut crate::c_types::c_uchar,
        sig_size: usize,
        sig_len: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
        rs_ctx: *mut mbedtls_pk_restart_ctx,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Decrypt message (including padding if relevant).\n\n \\param ctx       The PK context to use. It must have been set up\n                  with a private key.\n \\param input     Input to decrypt\n \\param ilen      Input size\n \\param output    Decrypted output\n \\param olen      Decrypted message length\n \\param osize     Size of the output buffer\n \\param f_rng     RNG function, must not be \\c NULL.\n \\param p_rng     RNG parameter\n\n \\note            For RSA keys, the default padding type is PKCS#1 v1.5.\n\n \\return          0 on success, or a specific error code."]
    pub fn mbedtls_pk_decrypt(
        ctx: *mut mbedtls_pk_context,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
        output: *mut crate::c_types::c_uchar,
        olen: *mut usize,
        osize: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Encrypt message (including padding if relevant).\n\n \\param ctx       The PK context to use. It must have been set up.\n \\param input     Message to encrypt\n \\param ilen      Message size\n \\param output    Encrypted output\n \\param olen      Encrypted output length\n \\param osize     Size of the output buffer\n \\param f_rng     RNG function, must not be \\c NULL.\n \\param p_rng     RNG parameter\n\n \\note            \\p f_rng is used for padding generation.\n\n \\note            For RSA keys, the default padding type is PKCS#1 v1.5.\n\n \\return          0 on success, or a specific error code."]
    pub fn mbedtls_pk_encrypt(
        ctx: *mut mbedtls_pk_context,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
        output: *mut crate::c_types::c_uchar,
        olen: *mut usize,
        osize: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Check if a public-private pair of keys matches.\n\n \\param pub       Context holding a public key.\n \\param prv       Context holding a private (and public) key.\n \\param f_rng     RNG function, must not be \\c NULL.\n \\param p_rng     RNG parameter\n\n \\return          \\c 0 on success (keys were checked and match each other).\n \\return          #MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE if the keys could not\n                  be checked - in that case they may or may not match.\n \\return          #MBEDTLS_ERR_PK_BAD_INPUT_DATA if a context is invalid.\n \\return          Another non-zero value if the keys do not match."]
    pub fn mbedtls_pk_check_pair(
        pub_: *const mbedtls_pk_context,
        prv: *const mbedtls_pk_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Export debug information\n\n \\param ctx       The PK context to use. It must have been initialized.\n \\param items     Place to write debug items\n\n \\return          0 on success or MBEDTLS_ERR_PK_BAD_INPUT_DATA"]
    pub fn mbedtls_pk_debug(
        ctx: *const mbedtls_pk_context,
        items: *mut mbedtls_pk_debug_item,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Access the type name\n\n \\param ctx       The PK context to use. It must have been initialized.\n\n \\return          Type name on success, or \"invalid PK\""]
    pub fn mbedtls_pk_get_name(ctx: *const mbedtls_pk_context) -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " \\brief           Get the key type\n\n \\param ctx       The PK context to use. It must have been initialized.\n\n \\return          Type on success.\n \\return          #MBEDTLS_PK_NONE for a context that has not been set up."]
    pub fn mbedtls_pk_get_type(ctx: *const mbedtls_pk_context) -> mbedtls_pk_type_t;
}
extern "C" {
    #[doc = " \\ingroup pk_module */\n/**\n \\brief           Parse a private key in PEM or DER format\n\n \\note            If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto\n                  subsystem must have been initialized by calling\n                  psa_crypto_init() before calling this function.\n\n \\param ctx       The PK context to fill. It must have been initialized\n                  but not set up.\n \\param key       Input buffer to parse.\n                  The buffer must contain the input exactly, with no\n                  extra trailing material. For PEM, the buffer must\n                  contain a null-terminated string.\n \\param keylen    Size of \\b key in bytes.\n                  For PEM data, this includes the terminating null byte,\n                  so \\p keylen must be equal to `strlen(key) + 1`.\n \\param pwd       Optional password for decryption.\n                  Pass \\c NULL if expecting a non-encrypted key.\n                  Pass a string of \\p pwdlen bytes if expecting an encrypted\n                  key; a non-encrypted key will also be accepted.\n                  The empty password is not supported.\n \\param pwdlen    Size of the password in bytes.\n                  Ignored if \\p pwd is \\c NULL.\n \\param f_rng     RNG function, must not be \\c NULL. Used for blinding.\n \\param p_rng     RNG parameter\n\n \\note            On entry, ctx must be empty, either freshly initialised\n                  with mbedtls_pk_init() or reset with mbedtls_pk_free(). If you need a\n                  specific key type, check the result with mbedtls_pk_can_do().\n\n \\note            The key is also checked for correctness.\n\n \\return          0 if successful, or a specific PK or PEM error code"]
    pub fn mbedtls_pk_parse_key(
        ctx: *mut mbedtls_pk_context,
        key: *const crate::c_types::c_uchar,
        keylen: usize,
        pwd: *const crate::c_types::c_uchar,
        pwdlen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\ingroup pk_module */\n/**\n \\brief           Parse a public key in PEM or DER format\n\n \\note            If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto\n                  subsystem must have been initialized by calling\n                  psa_crypto_init() before calling this function.\n\n \\param ctx       The PK context to fill. It must have been initialized\n                  but not set up.\n \\param key       Input buffer to parse.\n                  The buffer must contain the input exactly, with no\n                  extra trailing material. For PEM, the buffer must\n                  contain a null-terminated string.\n \\param keylen    Size of \\b key in bytes.\n                  For PEM data, this includes the terminating null byte,\n                  so \\p keylen must be equal to `strlen(key) + 1`.\n\n \\note            On entry, ctx must be empty, either freshly initialised\n                  with mbedtls_pk_init() or reset with mbedtls_pk_free(). If you need a\n                  specific key type, check the result with mbedtls_pk_can_do().\n\n \\note            For compressed points, see #MBEDTLS_ECP_PF_COMPRESSED for\n                  limitations.\n\n \\note            The key is also checked for correctness.\n\n \\return          0 if successful, or a specific PK or PEM error code"]
    pub fn mbedtls_pk_parse_public_key(
        ctx: *mut mbedtls_pk_context,
        key: *const crate::c_types::c_uchar,
        keylen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Write a private key to a PKCS#1 or SEC1 DER structure\n                  Note: data is written at the end of the buffer! Use the\n                        return value to determine where you should start\n                        using the buffer\n\n \\param ctx       PK context which must contain a valid private key.\n \\param buf       buffer to write to\n \\param size      size of the buffer\n\n \\return          length of data written if successful, or a specific\n                  error code"]
    pub fn mbedtls_pk_write_key_der(
        ctx: *const mbedtls_pk_context,
        buf: *mut crate::c_types::c_uchar,
        size: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Write a public key to a SubjectPublicKeyInfo DER structure\n                  Note: data is written at the end of the buffer! Use the\n                        return value to determine where you should start\n                        using the buffer\n\n \\param ctx       PK context which must contain a valid public or private key.\n \\param buf       buffer to write to\n \\param size      size of the buffer\n\n \\return          length of data written if successful, or a specific\n                  error code"]
    pub fn mbedtls_pk_write_pubkey_der(
        ctx: *const mbedtls_pk_context,
        buf: *mut crate::c_types::c_uchar,
        size: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Write a public key to a PEM string\n\n \\param ctx       PK context which must contain a valid public or private key.\n \\param buf       Buffer to write to. The output includes a\n                  terminating null byte.\n \\param size      Size of the buffer in bytes.\n\n \\return          0 if successful, or a specific error code"]
    pub fn mbedtls_pk_write_pubkey_pem(
        ctx: *const mbedtls_pk_context,
        buf: *mut crate::c_types::c_uchar,
        size: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Write a private key to a PKCS#1 or SEC1 PEM string\n\n \\param ctx       PK context which must contain a valid private key.\n \\param buf       Buffer to write to. The output includes a\n                  terminating null byte.\n \\param size      Size of the buffer in bytes.\n\n \\return          0 if successful, or a specific error code"]
    pub fn mbedtls_pk_write_key_pem(
        ctx: *const mbedtls_pk_context,
        buf: *mut crate::c_types::c_uchar,
        size: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Parse a SubjectPublicKeyInfo DER structure\n\n \\param p         the position in the ASN.1 data\n \\param end       end of the buffer\n \\param pk        The PK context to fill. It must have been initialized\n                  but not set up.\n\n \\return          0 if successful, or a specific PK error code"]
    pub fn mbedtls_pk_parse_subpubkey(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        pk: *mut mbedtls_pk_context,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Write a subjectPublicKey to ASN.1 data\n                  Note: function works backwards in data buffer\n\n \\param p         reference to current position pointer\n \\param start     start of the buffer (for bounds-checking)\n \\param key       PK context which must contain a valid public or private key.\n\n \\return          the length written or a negative error code"]
    pub fn mbedtls_pk_write_pubkey(
        p: *mut *mut crate::c_types::c_uchar,
        start: *mut crate::c_types::c_uchar,
        key: *const mbedtls_pk_context,
    ) -> crate::c_types::c_int;
}
#[doc = "< Placeholder to mark the end of cipher ID lists."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_NONE: mbedtls_cipher_id_t = 0;
#[doc = "< The identity cipher, treated as a stream cipher."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_NULL: mbedtls_cipher_id_t = 1;
#[doc = "< The AES cipher."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_AES: mbedtls_cipher_id_t = 2;
#[doc = "< The DES cipher. \\warning DES is considered weak."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_DES: mbedtls_cipher_id_t = 3;
#[doc = "< The Triple DES cipher. \\warning 3DES is considered weak."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_3DES: mbedtls_cipher_id_t = 4;
#[doc = "< The Camellia cipher."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_CAMELLIA: mbedtls_cipher_id_t = 5;
#[doc = "< The Aria cipher."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_ARIA: mbedtls_cipher_id_t = 6;
#[doc = "< The ChaCha20 cipher."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_CHACHA20: mbedtls_cipher_id_t = 7;
#[doc = " \\brief     Supported cipher types.\n\n \\warning   DES/3DES are considered weak ciphers and their use\n            constitutes a security risk. We recommend considering stronger\n            ciphers instead."]
pub type mbedtls_cipher_id_t = crate::c_types::c_uint;
#[doc = "< Placeholder to mark the end of cipher-pair lists."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_NONE: mbedtls_cipher_type_t = 0;
#[doc = "< The identity stream cipher."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_NULL: mbedtls_cipher_type_t = 1;
#[doc = "< AES cipher with 128-bit ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_ECB: mbedtls_cipher_type_t = 2;
#[doc = "< AES cipher with 192-bit ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_ECB: mbedtls_cipher_type_t = 3;
#[doc = "< AES cipher with 256-bit ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_ECB: mbedtls_cipher_type_t = 4;
#[doc = "< AES cipher with 128-bit CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CBC: mbedtls_cipher_type_t = 5;
#[doc = "< AES cipher with 192-bit CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CBC: mbedtls_cipher_type_t = 6;
#[doc = "< AES cipher with 256-bit CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CBC: mbedtls_cipher_type_t = 7;
#[doc = "< AES cipher with 128-bit CFB128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CFB128: mbedtls_cipher_type_t = 8;
#[doc = "< AES cipher with 192-bit CFB128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CFB128: mbedtls_cipher_type_t = 9;
#[doc = "< AES cipher with 256-bit CFB128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CFB128: mbedtls_cipher_type_t = 10;
#[doc = "< AES cipher with 128-bit CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CTR: mbedtls_cipher_type_t = 11;
#[doc = "< AES cipher with 192-bit CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CTR: mbedtls_cipher_type_t = 12;
#[doc = "< AES cipher with 256-bit CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CTR: mbedtls_cipher_type_t = 13;
#[doc = "< AES cipher with 128-bit GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_GCM: mbedtls_cipher_type_t = 14;
#[doc = "< AES cipher with 192-bit GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_GCM: mbedtls_cipher_type_t = 15;
#[doc = "< AES cipher with 256-bit GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_GCM: mbedtls_cipher_type_t = 16;
#[doc = "< Camellia cipher with 128-bit ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_ECB: mbedtls_cipher_type_t = 17;
#[doc = "< Camellia cipher with 192-bit ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_ECB: mbedtls_cipher_type_t = 18;
#[doc = "< Camellia cipher with 256-bit ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_ECB: mbedtls_cipher_type_t = 19;
#[doc = "< Camellia cipher with 128-bit CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CBC: mbedtls_cipher_type_t = 20;
#[doc = "< Camellia cipher with 192-bit CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CBC: mbedtls_cipher_type_t = 21;
#[doc = "< Camellia cipher with 256-bit CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CBC: mbedtls_cipher_type_t = 22;
#[doc = "< Camellia cipher with 128-bit CFB128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CFB128: mbedtls_cipher_type_t = 23;
#[doc = "< Camellia cipher with 192-bit CFB128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CFB128: mbedtls_cipher_type_t = 24;
#[doc = "< Camellia cipher with 256-bit CFB128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CFB128: mbedtls_cipher_type_t = 25;
#[doc = "< Camellia cipher with 128-bit CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CTR: mbedtls_cipher_type_t = 26;
#[doc = "< Camellia cipher with 192-bit CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CTR: mbedtls_cipher_type_t = 27;
#[doc = "< Camellia cipher with 256-bit CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CTR: mbedtls_cipher_type_t = 28;
#[doc = "< Camellia cipher with 128-bit GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_GCM: mbedtls_cipher_type_t = 29;
#[doc = "< Camellia cipher with 192-bit GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_GCM: mbedtls_cipher_type_t = 30;
#[doc = "< Camellia cipher with 256-bit GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_GCM: mbedtls_cipher_type_t = 31;
#[doc = "< DES cipher with ECB mode. \\warning DES is considered weak."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_ECB: mbedtls_cipher_type_t = 32;
#[doc = "< DES cipher with CBC mode. \\warning DES is considered weak."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_CBC: mbedtls_cipher_type_t = 33;
#[doc = "< DES cipher with EDE ECB mode. \\warning 3DES is considered weak."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_EDE_ECB: mbedtls_cipher_type_t = 34;
#[doc = "< DES cipher with EDE CBC mode. \\warning 3DES is considered weak."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_EDE_CBC: mbedtls_cipher_type_t = 35;
#[doc = "< DES cipher with EDE3 ECB mode. \\warning 3DES is considered weak."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_EDE3_ECB: mbedtls_cipher_type_t = 36;
#[doc = "< DES cipher with EDE3 CBC mode. \\warning 3DES is considered weak."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_EDE3_CBC: mbedtls_cipher_type_t = 37;
#[doc = "< AES cipher with 128-bit CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CCM: mbedtls_cipher_type_t = 38;
#[doc = "< AES cipher with 192-bit CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CCM: mbedtls_cipher_type_t = 39;
#[doc = "< AES cipher with 256-bit CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CCM: mbedtls_cipher_type_t = 40;
#[doc = "< AES cipher with 128-bit CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 41;
#[doc = "< AES cipher with 192-bit CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 42;
#[doc = "< AES cipher with 256-bit CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 43;
#[doc = "< Camellia cipher with 128-bit CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CCM: mbedtls_cipher_type_t = 44;
#[doc = "< Camellia cipher with 192-bit CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CCM: mbedtls_cipher_type_t = 45;
#[doc = "< Camellia cipher with 256-bit CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CCM: mbedtls_cipher_type_t = 46;
#[doc = "< Camellia cipher with 128-bit CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CCM_STAR_NO_TAG: mbedtls_cipher_type_t =
    47;
#[doc = "< Camellia cipher with 192-bit CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CCM_STAR_NO_TAG: mbedtls_cipher_type_t =
    48;
#[doc = "< Camellia cipher with 256-bit CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CCM_STAR_NO_TAG: mbedtls_cipher_type_t =
    49;
#[doc = "< Aria cipher with 128-bit key and ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_ECB: mbedtls_cipher_type_t = 50;
#[doc = "< Aria cipher with 192-bit key and ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_ECB: mbedtls_cipher_type_t = 51;
#[doc = "< Aria cipher with 256-bit key and ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_ECB: mbedtls_cipher_type_t = 52;
#[doc = "< Aria cipher with 128-bit key and CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_CBC: mbedtls_cipher_type_t = 53;
#[doc = "< Aria cipher with 192-bit key and CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_CBC: mbedtls_cipher_type_t = 54;
#[doc = "< Aria cipher with 256-bit key and CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_CBC: mbedtls_cipher_type_t = 55;
#[doc = "< Aria cipher with 128-bit key and CFB-128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_CFB128: mbedtls_cipher_type_t = 56;
#[doc = "< Aria cipher with 192-bit key and CFB-128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_CFB128: mbedtls_cipher_type_t = 57;
#[doc = "< Aria cipher with 256-bit key and CFB-128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_CFB128: mbedtls_cipher_type_t = 58;
#[doc = "< Aria cipher with 128-bit key and CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_CTR: mbedtls_cipher_type_t = 59;
#[doc = "< Aria cipher with 192-bit key and CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_CTR: mbedtls_cipher_type_t = 60;
#[doc = "< Aria cipher with 256-bit key and CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_CTR: mbedtls_cipher_type_t = 61;
#[doc = "< Aria cipher with 128-bit key and GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_GCM: mbedtls_cipher_type_t = 62;
#[doc = "< Aria cipher with 192-bit key and GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_GCM: mbedtls_cipher_type_t = 63;
#[doc = "< Aria cipher with 256-bit key and GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_GCM: mbedtls_cipher_type_t = 64;
#[doc = "< Aria cipher with 128-bit key and CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_CCM: mbedtls_cipher_type_t = 65;
#[doc = "< Aria cipher with 192-bit key and CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_CCM: mbedtls_cipher_type_t = 66;
#[doc = "< Aria cipher with 256-bit key and CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_CCM: mbedtls_cipher_type_t = 67;
#[doc = "< Aria cipher with 128-bit key and CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 68;
#[doc = "< Aria cipher with 192-bit key and CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 69;
#[doc = "< Aria cipher with 256-bit key and CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 70;
#[doc = "< AES 128-bit cipher in OFB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_OFB: mbedtls_cipher_type_t = 71;
#[doc = "< AES 192-bit cipher in OFB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_OFB: mbedtls_cipher_type_t = 72;
#[doc = "< AES 256-bit cipher in OFB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_OFB: mbedtls_cipher_type_t = 73;
#[doc = "< AES 128-bit cipher in XTS block mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_XTS: mbedtls_cipher_type_t = 74;
#[doc = "< AES 256-bit cipher in XTS block mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_XTS: mbedtls_cipher_type_t = 75;
#[doc = "< ChaCha20 stream cipher."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CHACHA20: mbedtls_cipher_type_t = 76;
#[doc = "< ChaCha20-Poly1305 AEAD cipher."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CHACHA20_POLY1305: mbedtls_cipher_type_t = 77;
#[doc = "< AES cipher with 128-bit NIST KW mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_KW: mbedtls_cipher_type_t = 78;
#[doc = "< AES cipher with 192-bit NIST KW mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_KW: mbedtls_cipher_type_t = 79;
#[doc = "< AES cipher with 256-bit NIST KW mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_KW: mbedtls_cipher_type_t = 80;
#[doc = "< AES cipher with 128-bit NIST KWP mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_KWP: mbedtls_cipher_type_t = 81;
#[doc = "< AES cipher with 192-bit NIST KWP mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_KWP: mbedtls_cipher_type_t = 82;
#[doc = "< AES cipher with 256-bit NIST KWP mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_KWP: mbedtls_cipher_type_t = 83;
#[doc = " \\brief     Supported {cipher type, cipher mode} pairs.\n\n \\warning   DES/3DES are considered weak ciphers and their use\n            constitutes a security risk. We recommend considering stronger\n            ciphers instead."]
pub type mbedtls_cipher_type_t = crate::c_types::c_uint;
#[doc = "< None."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_NONE: mbedtls_cipher_mode_t = 0;
#[doc = "< The ECB cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_ECB: mbedtls_cipher_mode_t = 1;
#[doc = "< The CBC cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CBC: mbedtls_cipher_mode_t = 2;
#[doc = "< The CFB cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CFB: mbedtls_cipher_mode_t = 3;
#[doc = "< The OFB cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_OFB: mbedtls_cipher_mode_t = 4;
#[doc = "< The CTR cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CTR: mbedtls_cipher_mode_t = 5;
#[doc = "< The GCM cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_GCM: mbedtls_cipher_mode_t = 6;
#[doc = "< The stream cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_STREAM: mbedtls_cipher_mode_t = 7;
#[doc = "< The CCM cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CCM: mbedtls_cipher_mode_t = 8;
#[doc = "< The CCM*-no-tag cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CCM_STAR_NO_TAG: mbedtls_cipher_mode_t = 9;
#[doc = "< The XTS cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_XTS: mbedtls_cipher_mode_t = 10;
#[doc = "< The ChaCha-Poly cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CHACHAPOLY: mbedtls_cipher_mode_t = 11;
#[doc = "< The SP800-38F KW mode"]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_KW: mbedtls_cipher_mode_t = 12;
#[doc = "< The SP800-38F KWP mode"]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_KWP: mbedtls_cipher_mode_t = 13;
#[doc = " Supported cipher modes."]
pub type mbedtls_cipher_mode_t = crate::c_types::c_uint;
#[doc = "< PKCS7 padding (default)."]
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_PKCS7: mbedtls_cipher_padding_t = 0;
#[doc = "< ISO/IEC 7816-4 padding."]
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_ONE_AND_ZEROS: mbedtls_cipher_padding_t = 1;
#[doc = "< ANSI X.923 padding."]
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_ZEROS_AND_LEN: mbedtls_cipher_padding_t = 2;
#[doc = "< Zero padding (not reversible)."]
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_ZEROS: mbedtls_cipher_padding_t = 3;
#[doc = "< Never pad (full blocks only)."]
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_NONE: mbedtls_cipher_padding_t = 4;
#[doc = " Supported cipher padding types."]
pub type mbedtls_cipher_padding_t = crate::c_types::c_uint;
pub const mbedtls_operation_t_MBEDTLS_OPERATION_NONE: mbedtls_operation_t = -1;
pub const mbedtls_operation_t_MBEDTLS_DECRYPT: mbedtls_operation_t = 0;
pub const mbedtls_operation_t_MBEDTLS_ENCRYPT: mbedtls_operation_t = 1;
#[doc = " Type of operation."]
pub type mbedtls_operation_t = crate::c_types::c_int;
#[doc = " Undefined key length."]
pub const MBEDTLS_KEY_LENGTH_NONE: _bindgen_ty_1 = 0;
#[doc = " Key length, in bits (including parity), for DES keys. \\warning DES is considered weak."]
pub const MBEDTLS_KEY_LENGTH_DES: _bindgen_ty_1 = 64;
#[doc = " Key length in bits, including parity, for DES in two-key EDE. \\warning 3DES is considered weak."]
pub const MBEDTLS_KEY_LENGTH_DES_EDE: _bindgen_ty_1 = 128;
#[doc = " Key length in bits, including parity, for DES in three-key EDE. \\warning 3DES is considered weak."]
pub const MBEDTLS_KEY_LENGTH_DES_EDE3: _bindgen_ty_1 = 192;
pub type _bindgen_ty_1 = crate::c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_cipher_base_t {
    _unused: [u8; 0],
}
#[doc = " Cipher information. Allows calling cipher functions\n in a generic way.\n\n \\note        The library does not support custom cipher info structures,\n              only built-in structures returned by the functions\n              mbedtls_cipher_info_from_string(),\n              mbedtls_cipher_info_from_type(),\n              mbedtls_cipher_info_from_values(),\n              mbedtls_cipher_info_from_psa()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_cipher_info_t {
    pub private_type: mbedtls_cipher_type_t,
    pub private_mode: mbedtls_cipher_mode_t,
    pub private_key_bitlen: crate::c_types::c_uint,
    pub private_name: *const crate::c_types::c_char,
    pub private_iv_size: crate::c_types::c_uint,
    pub private_flags: crate::c_types::c_int,
    pub private_block_size: crate::c_types::c_uint,
    pub private_base: *const mbedtls_cipher_base_t,
}
#[doc = " Generic cipher context."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_cipher_context_t {
    pub private_cipher_info: *const mbedtls_cipher_info_t,
    pub private_key_bitlen: crate::c_types::c_int,
    pub private_operation: mbedtls_operation_t,
    pub private_add_padding: ::core::option::Option<
        unsafe extern "C" fn(output: *mut crate::c_types::c_uchar, olen: usize, data_len: usize),
    >,
    pub private_get_padding: ::core::option::Option<
        unsafe extern "C" fn(
            input: *mut crate::c_types::c_uchar,
            ilen: usize,
            data_len: *mut usize,
        ) -> crate::c_types::c_int,
    >,
    pub private_unprocessed_data: [crate::c_types::c_uchar; 16usize],
    pub private_unprocessed_len: usize,
    pub private_iv: [crate::c_types::c_uchar; 16usize],
    pub private_iv_size: usize,
    pub private_cipher_ctx: *mut crate::c_types::c_void,
    pub private_cmac_ctx: *mut mbedtls_cmac_context_t,
}
extern "C" {
    #[doc = " \\brief This function retrieves the list of ciphers supported\n        by the generic cipher module.\n\n        For any cipher identifier in the returned list, you can\n        obtain the corresponding generic cipher information structure\n        via mbedtls_cipher_info_from_type(), which can then be used\n        to prepare a cipher context via mbedtls_cipher_setup().\n\n\n \\return      A statically-allocated array of cipher identifiers\n              of type cipher_type_t. The last entry is zero."]
    pub fn mbedtls_cipher_list() -> *const crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function retrieves the cipher-information\n                      structure associated with the given cipher name.\n\n \\param cipher_name   Name of the cipher to search for. This must not be\n                      \\c NULL.\n\n \\return              The cipher information structure associated with the\n                      given \\p cipher_name.\n \\return              \\c NULL if the associated cipher information is not found."]
    pub fn mbedtls_cipher_info_from_string(
        cipher_name: *const crate::c_types::c_char,
    ) -> *const mbedtls_cipher_info_t;
}
extern "C" {
    #[doc = " \\brief               This function retrieves the cipher-information\n                      structure associated with the given cipher type.\n\n \\param cipher_type   Type of the cipher to search for.\n\n \\return              The cipher information structure associated with the\n                      given \\p cipher_type.\n \\return              \\c NULL if the associated cipher information is not found."]
    pub fn mbedtls_cipher_info_from_type(
        cipher_type: mbedtls_cipher_type_t,
    ) -> *const mbedtls_cipher_info_t;
}
extern "C" {
    #[doc = " \\brief               This function retrieves the cipher-information\n                      structure associated with the given cipher ID,\n                      key size and mode.\n\n \\param cipher_id     The ID of the cipher to search for. For example,\n                      #MBEDTLS_CIPHER_ID_AES.\n \\param key_bitlen    The length of the key in bits.\n \\param mode          The cipher mode. For example, #MBEDTLS_MODE_CBC.\n\n \\return              The cipher information structure associated with the\n                      given \\p cipher_id.\n \\return              \\c NULL if the associated cipher information is not found."]
    pub fn mbedtls_cipher_info_from_values(
        cipher_id: mbedtls_cipher_id_t,
        key_bitlen: crate::c_types::c_int,
        mode: mbedtls_cipher_mode_t,
    ) -> *const mbedtls_cipher_info_t;
}
extern "C" {
    #[doc = " \\brief               This function initializes a \\p cipher_context as NONE.\n\n \\param ctx           The context to be initialized. This must not be \\c NULL."]
    pub fn mbedtls_cipher_init(ctx: *mut mbedtls_cipher_context_t);
}
extern "C" {
    #[doc = " \\brief               This function frees and clears the cipher-specific\n                      context of \\p ctx. Freeing \\p ctx itself remains the\n                      responsibility of the caller.\n\n \\param ctx           The context to be freed. If this is \\c NULL, the\n                      function has no effect, otherwise this must point to an\n                      initialized context."]
    pub fn mbedtls_cipher_free(ctx: *mut mbedtls_cipher_context_t);
}
extern "C" {
    #[doc = " \\brief               This function prepares a cipher context for\n                      use with the given cipher primitive.\n\n \\note                After calling this function, you should call\n                      mbedtls_cipher_setkey() and, if the mode uses padding,\n                      mbedtls_cipher_set_padding_mode(), then for each\n                      message to encrypt or decrypt with this key, either:\n                      - mbedtls_cipher_crypt() for one-shot processing with\n                      non-AEAD modes;\n                      - mbedtls_cipher_auth_encrypt_ext() or\n                      mbedtls_cipher_auth_decrypt_ext() for one-shot\n                      processing with AEAD modes or NIST_KW;\n                      - for multi-part processing, see the documentation of\n                      mbedtls_cipher_reset().\n\n \\param ctx           The context to prepare. This must be initialized by\n                      a call to mbedtls_cipher_init() first.\n \\param cipher_info   The cipher to use.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n                      parameter-verification failure.\n \\return              #MBEDTLS_ERR_CIPHER_ALLOC_FAILED if allocation of the\n                      cipher-specific context fails."]
    pub fn mbedtls_cipher_setup(
        ctx: *mut mbedtls_cipher_context_t,
        cipher_info: *const mbedtls_cipher_info_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function sets the key to use with the given context.\n\n \\param ctx           The generic cipher context. This must be initialized and\n                      bound to a cipher information structure.\n \\param key           The key to use. This must be a readable buffer of at\n                      least \\p key_bitlen Bits.\n \\param key_bitlen    The key length to use, in Bits.\n \\param operation     The operation that the key will be used for:\n                      #MBEDTLS_ENCRYPT or #MBEDTLS_DECRYPT.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n                      parameter-verification failure.\n \\return              A cipher-specific error code on failure."]
    pub fn mbedtls_cipher_setkey(
        ctx: *mut mbedtls_cipher_context_t,
        key: *const crate::c_types::c_uchar,
        key_bitlen: crate::c_types::c_int,
        operation: mbedtls_operation_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function sets the padding mode, for cipher modes\n                      that use padding.\n\n                      The default passing mode is PKCS7 padding.\n\n \\param ctx           The generic cipher context. This must be initialized and\n                      bound to a cipher information structure.\n \\param mode          The padding mode.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE\n                      if the selected padding mode is not supported.\n \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA if the cipher mode\n                      does not support padding."]
    pub fn mbedtls_cipher_set_padding_mode(
        ctx: *mut mbedtls_cipher_context_t,
        mode: mbedtls_cipher_padding_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets the initialization vector (IV)\n                  or nonce.\n\n \\note            Some ciphers do not use IVs nor nonce. For these\n                  ciphers, this function has no effect.\n\n \\note            For #MBEDTLS_CIPHER_CHACHA20, the nonce length must\n                  be 12, and the initial counter value is 0.\n\n \\note            For #MBEDTLS_CIPHER_CHACHA20_POLY1305, the nonce length\n                  must be 12.\n\n \\param ctx       The generic cipher context. This must be initialized and\n                  bound to a cipher information structure.\n \\param iv        The IV to use, or NONCE_COUNTER for CTR-mode ciphers. This\n                  must be a readable buffer of at least \\p iv_len Bytes.\n \\param iv_len    The IV length for ciphers with variable-size IV.\n                  This parameter is discarded by ciphers with fixed-size IV.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n                  parameter-verification failure."]
    pub fn mbedtls_cipher_set_iv(
        ctx: *mut mbedtls_cipher_context_t,
        iv: *const crate::c_types::c_uchar,
        iv_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief         This function resets the cipher state.\n\n \\note          With non-AEAD ciphers, the order of calls for each message\n                is as follows:\n                1. mbedtls_cipher_set_iv() if the mode uses an IV/nonce.\n                2. mbedtls_cipher_reset()\n                3. mbedtls_cipher_update() one or more times\n                4. mbedtls_cipher_finish()\n                .\n                This sequence can be repeated to encrypt or decrypt multiple\n                messages with the same key.\n\n \\note          With AEAD ciphers, the order of calls for each message\n                is as follows:\n                1. mbedtls_cipher_set_iv() if the mode uses an IV/nonce.\n                2. mbedtls_cipher_reset()\n                3. mbedtls_cipher_update_ad()\n                4. mbedtls_cipher_update() one or more times\n                5. mbedtls_cipher_finish()\n                6. mbedtls_cipher_check_tag() (for decryption) or\n                mbedtls_cipher_write_tag() (for encryption).\n                .\n                This sequence can be repeated to encrypt or decrypt multiple\n                messages with the same key.\n\n \\param ctx     The generic cipher context. This must be bound to a key.\n\n \\return        \\c 0 on success.\n \\return        #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n                parameter-verification failure."]
    pub fn mbedtls_cipher_reset(ctx: *mut mbedtls_cipher_context_t) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function adds additional data for AEAD ciphers.\n                      Currently supported with GCM and ChaCha20+Poly1305.\n\n \\param ctx           The generic cipher context. This must be initialized.\n \\param ad            The additional data to use. This must be a readable\n                      buffer of at least \\p ad_len Bytes.\n \\param ad_len        The length of \\p ad in Bytes.\n\n \\return              \\c 0 on success.\n \\return              A specific error code on failure."]
    pub fn mbedtls_cipher_update_ad(
        ctx: *mut mbedtls_cipher_context_t,
        ad: *const crate::c_types::c_uchar,
        ad_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               The generic cipher update function. It encrypts or\n                      decrypts using the given cipher context. Writes as\n                      many block-sized blocks of data as possible to output.\n                      Any data that cannot be written immediately is either\n                      added to the next block, or flushed when\n                      mbedtls_cipher_finish() is called.\n                      Exception: For MBEDTLS_MODE_ECB, expects a single block\n                      in size. For example, 16 Bytes for AES.\n\n \\param ctx           The generic cipher context. This must be initialized and\n                      bound to a key.\n \\param input         The buffer holding the input data. This must be a\n                      readable buffer of at least \\p ilen Bytes.\n \\param ilen          The length of the input data.\n \\param output        The buffer for the output data. This must be able to\n                      hold at least `ilen + block_size`. This must not be the\n                      same buffer as \\p input.\n \\param olen          The length of the output data, to be updated with the\n                      actual number of Bytes written. This must not be\n                      \\c NULL.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n                      parameter-verification failure.\n \\return              #MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE on an\n                      unsupported mode for a cipher.\n \\return              A cipher-specific error code on failure."]
    pub fn mbedtls_cipher_update(
        ctx: *mut mbedtls_cipher_context_t,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
        output: *mut crate::c_types::c_uchar,
        olen: *mut usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               The generic cipher finalization function. If data still\n                      needs to be flushed from an incomplete block, the data\n                      contained in it is padded to the size of\n                      the last block, and written to the \\p output buffer.\n\n \\param ctx           The generic cipher context. This must be initialized and\n                      bound to a key.\n \\param output        The buffer to write data to. This needs to be a writable\n                      buffer of at least \\p block_size Bytes.\n \\param olen          The length of the data written to the \\p output buffer.\n                      This may not be \\c NULL.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n                      parameter-verification failure.\n \\return              #MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED on decryption\n                      expecting a full block but not receiving one.\n \\return              #MBEDTLS_ERR_CIPHER_INVALID_PADDING on invalid padding\n                      while decrypting.\n \\return              A cipher-specific error code on failure."]
    pub fn mbedtls_cipher_finish(
        ctx: *mut mbedtls_cipher_context_t,
        output: *mut crate::c_types::c_uchar,
        olen: *mut usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function writes a tag for AEAD ciphers.\n                      Currently supported with GCM and ChaCha20+Poly1305.\n                      This must be called after mbedtls_cipher_finish().\n\n \\param ctx           The generic cipher context. This must be initialized,\n                      bound to a key, and have just completed a cipher\n                      operation through mbedtls_cipher_finish() the tag for\n                      which should be written.\n \\param tag           The buffer to write the tag to. This must be a writable\n                      buffer of at least \\p tag_len Bytes.\n \\param tag_len       The length of the tag to write.\n\n \\return              \\c 0 on success.\n \\return              A specific error code on failure."]
    pub fn mbedtls_cipher_write_tag(
        ctx: *mut mbedtls_cipher_context_t,
        tag: *mut crate::c_types::c_uchar,
        tag_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function checks the tag for AEAD ciphers.\n                      Currently supported with GCM and ChaCha20+Poly1305.\n                      This must be called after mbedtls_cipher_finish().\n\n \\param ctx           The generic cipher context. This must be initialized.\n \\param tag           The buffer holding the tag. This must be a readable\n                      buffer of at least \\p tag_len Bytes.\n \\param tag_len       The length of the tag to check.\n\n \\return              \\c 0 on success.\n \\return              A specific error code on failure."]
    pub fn mbedtls_cipher_check_tag(
        ctx: *mut mbedtls_cipher_context_t,
        tag: *const crate::c_types::c_uchar,
        tag_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               The generic all-in-one encryption/decryption function,\n                      for all ciphers except AEAD constructs.\n\n \\param ctx           The generic cipher context. This must be initialized.\n \\param iv            The IV to use, or NONCE_COUNTER for CTR-mode ciphers.\n                      This must be a readable buffer of at least \\p iv_len\n                      Bytes.\n \\param iv_len        The IV length for ciphers with variable-size IV.\n                      This parameter is discarded by ciphers with fixed-size\n                      IV.\n \\param input         The buffer holding the input data. This must be a\n                      readable buffer of at least \\p ilen Bytes.\n \\param ilen          The length of the input data in Bytes.\n \\param output        The buffer for the output data. This must be able to\n                      hold at least `ilen + block_size`. This must not be the\n                      same buffer as \\p input.\n \\param olen          The length of the output data, to be updated with the\n                      actual number of Bytes written. This must not be\n                      \\c NULL.\n\n \\note                Some ciphers do not use IVs nor nonce. For these\n                      ciphers, use \\p iv = NULL and \\p iv_len = 0.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n                      parameter-verification failure.\n \\return              #MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED on decryption\n                      expecting a full block but not receiving one.\n \\return              #MBEDTLS_ERR_CIPHER_INVALID_PADDING on invalid padding\n                      while decrypting.\n \\return              A cipher-specific error code on failure."]
    pub fn mbedtls_cipher_crypt(
        ctx: *mut mbedtls_cipher_context_t,
        iv: *const crate::c_types::c_uchar,
        iv_len: usize,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
        output: *mut crate::c_types::c_uchar,
        olen: *mut usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               The authenticated encryption (AEAD/NIST_KW) function.\n\n \\note                For AEAD modes, the tag will be appended to the\n                      ciphertext, as recommended by RFC 5116.\n                      (NIST_KW doesn't have a separate tag.)\n\n \\param ctx           The generic cipher context. This must be initialized and\n                      bound to a key, with an AEAD algorithm or NIST_KW.\n \\param iv            The nonce to use. This must be a readable buffer of\n                      at least \\p iv_len Bytes and may be \\c NULL if \\p\n                      iv_len is \\c 0.\n \\param iv_len        The length of the nonce. For AEAD ciphers, this must\n                      satisfy the constraints imposed by the cipher used.\n                      For NIST_KW, this must be \\c 0.\n \\param ad            The additional data to authenticate. This must be a\n                      readable buffer of at least \\p ad_len Bytes, and may\n                      be \\c NULL is \\p ad_len is \\c 0.\n \\param ad_len        The length of \\p ad. For NIST_KW, this must be \\c 0.\n \\param input         The buffer holding the input data. This must be a\n                      readable buffer of at least \\p ilen Bytes, and may be\n                      \\c NULL if \\p ilen is \\c 0.\n \\param ilen          The length of the input data.\n \\param output        The buffer for the output data. This must be a\n                      writable buffer of at least \\p output_len Bytes, and\n                      must not be \\c NULL.\n \\param output_len    The length of the \\p output buffer in Bytes. For AEAD\n                      ciphers, this must be at least \\p ilen + \\p tag_len.\n                      For NIST_KW, this must be at least \\p ilen + 8\n                      (rounded up to a multiple of 8 if KWP is used);\n                      \\p ilen + 15 is always a safe value.\n \\param olen          This will be filled with the actual number of Bytes\n                      written to the \\p output buffer. This must point to a\n                      writable object of type \\c size_t.\n \\param tag_len       The desired length of the authentication tag. For AEAD\n                      ciphers, this must match the constraints imposed by\n                      the cipher used, and in particular must not be \\c 0.\n                      For NIST_KW, this must be \\c 0.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n                      parameter-verification failure.\n \\return              A cipher-specific error code on failure."]
    pub fn mbedtls_cipher_auth_encrypt_ext(
        ctx: *mut mbedtls_cipher_context_t,
        iv: *const crate::c_types::c_uchar,
        iv_len: usize,
        ad: *const crate::c_types::c_uchar,
        ad_len: usize,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
        output: *mut crate::c_types::c_uchar,
        output_len: usize,
        olen: *mut usize,
        tag_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               The authenticated encryption (AEAD/NIST_KW) function.\n\n \\note                If the data is not authentic, then the output buffer\n                      is zeroed out to prevent the unauthentic plaintext being\n                      used, making this interface safer.\n\n \\note                For AEAD modes, the tag must be appended to the\n                      ciphertext, as recommended by RFC 5116.\n                      (NIST_KW doesn't have a separate tag.)\n\n \\param ctx           The generic cipher context. This must be initialized and\n                      bound to a key, with an AEAD algorithm or NIST_KW.\n \\param iv            The nonce to use. This must be a readable buffer of\n                      at least \\p iv_len Bytes and may be \\c NULL if \\p\n                      iv_len is \\c 0.\n \\param iv_len        The length of the nonce. For AEAD ciphers, this must\n                      satisfy the constraints imposed by the cipher used.\n                      For NIST_KW, this must be \\c 0.\n \\param ad            The additional data to authenticate. This must be a\n                      readable buffer of at least \\p ad_len Bytes, and may\n                      be \\c NULL is \\p ad_len is \\c 0.\n \\param ad_len        The length of \\p ad. For NIST_KW, this must be \\c 0.\n \\param input         The buffer holding the input data. This must be a\n                      readable buffer of at least \\p ilen Bytes, and may be\n                      \\c NULL if \\p ilen is \\c 0.\n \\param ilen          The length of the input data. For AEAD ciphers this\n                      must be at least \\p tag_len. For NIST_KW this must be\n                      at least \\c 8.\n \\param output        The buffer for the output data. This must be a\n                      writable buffer of at least \\p output_len Bytes, and\n                      may be \\c NULL if \\p output_len is \\c 0.\n \\param output_len    The length of the \\p output buffer in Bytes. For AEAD\n                      ciphers, this must be at least \\p ilen - \\p tag_len.\n                      For NIST_KW, this must be at least \\p ilen - 8.\n \\param olen          This will be filled with the actual number of Bytes\n                      written to the \\p output buffer. This must point to a\n                      writable object of type \\c size_t.\n \\param tag_len       The actual length of the authentication tag. For AEAD\n                      ciphers, this must match the constraints imposed by\n                      the cipher used, and in particular must not be \\c 0.\n                      For NIST_KW, this must be \\c 0.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n                      parameter-verification failure.\n \\return              #MBEDTLS_ERR_CIPHER_AUTH_FAILED if data is not authentic.\n \\return              A cipher-specific error code on failure."]
    pub fn mbedtls_cipher_auth_decrypt_ext(
        ctx: *mut mbedtls_cipher_context_t,
        iv: *const crate::c_types::c_uchar,
        iv_len: usize,
        ad: *const crate::c_types::c_uchar,
        ad_len: usize,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
        output: *mut crate::c_types::c_uchar,
        output_len: usize,
        olen: *mut usize,
        tag_len: usize,
    ) -> crate::c_types::c_int;
}
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_NONE: mbedtls_key_exchange_type_t = 0;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_RSA: mbedtls_key_exchange_type_t = 1;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_DHE_RSA: mbedtls_key_exchange_type_t = 2;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECDHE_RSA: mbedtls_key_exchange_type_t =
    3;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA:
    mbedtls_key_exchange_type_t = 4;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_PSK: mbedtls_key_exchange_type_t = 5;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_DHE_PSK: mbedtls_key_exchange_type_t = 6;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_RSA_PSK: mbedtls_key_exchange_type_t = 7;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECDHE_PSK: mbedtls_key_exchange_type_t =
    8;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECDH_RSA: mbedtls_key_exchange_type_t =
    9;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA: mbedtls_key_exchange_type_t =
    10;
pub const mbedtls_key_exchange_type_t_MBEDTLS_KEY_EXCHANGE_ECJPAKE: mbedtls_key_exchange_type_t =
    11;
pub type mbedtls_key_exchange_type_t = crate::c_types::c_uint;
#[doc = " \\brief   This structure is used for storing ciphersuite information\n\n \\note    members are defined using integral types instead of enums\n          in order to pack structure and reduce memory usage by internal\n          \\c ciphersuite_definitions[]"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_ciphersuite_t {
    pub private_id: crate::c_types::c_int,
    pub private_name: *const crate::c_types::c_char,
    pub private_cipher: u8,
    pub private_mac: u8,
    pub private_key_exchange: u8,
    pub private_flags: u8,
    pub private_min_tls_version: u16,
    pub private_max_tls_version: u16,
}
extern "C" {
    pub fn mbedtls_ssl_list_ciphersuites() -> *const crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_ciphersuite_from_string(
        ciphersuite_name: *const crate::c_types::c_char,
    ) -> *const mbedtls_ssl_ciphersuite_t;
}
extern "C" {
    pub fn mbedtls_ssl_ciphersuite_from_id(
        ciphersuite_id: crate::c_types::c_int,
    ) -> *const mbedtls_ssl_ciphersuite_t;
}
extern "C" {
    pub fn mbedtls_ssl_get_ciphersuite_sig_pk_alg(
        info: *const mbedtls_ssl_ciphersuite_t,
    ) -> mbedtls_pk_type_t;
}
extern "C" {
    pub fn mbedtls_ssl_get_ciphersuite_sig_alg(
        info: *const mbedtls_ssl_ciphersuite_t,
    ) -> mbedtls_pk_type_t;
}
extern "C" {
    pub fn mbedtls_ssl_ciphersuite_uses_ec(
        info: *const mbedtls_ssl_ciphersuite_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_ciphersuite_uses_psk(
        info: *const mbedtls_ssl_ciphersuite_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_ssl_ciphersuite_get_cipher_key_bitlen(
        info: *const mbedtls_ssl_ciphersuite_t,
    ) -> usize;
}
#[doc = " The type of the context passed to mbedtls_psa_external_get_random().\n\n Mbed TLS initializes the context to all-bits-zero before calling\n mbedtls_psa_external_get_random() for the first time.\n\n The definition of this type in the Mbed TLS source code is for\n demonstration purposes. Implementers of mbedtls_psa_external_get_random()\n are expected to replace it with a custom definition."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_external_random_context_t {
    pub private_opaque: [usize; 2usize],
}
pub type psa_status_t = i32;
#[doc = " \\brief Encoding of a key type.\n\n Values of this type are generally constructed by macros called\n `PSA_KEY_TYPE_xxx`.\n\n \\note Values of this type are encoded in the persistent key store.\n       Any changes to existing values will require bumping the storage\n       format version and providing a translation when reading the old\n       format."]
pub type psa_key_type_t = u16;
#[doc = " The type of PSA elliptic curve family identifiers.\n\n Values of this type are generally constructed by macros called\n `PSA_ECC_FAMILY_xxx`.\n\n The curve identifier is required to create an ECC key using the\n PSA_KEY_TYPE_ECC_KEY_PAIR() or PSA_KEY_TYPE_ECC_PUBLIC_KEY()\n macros.\n\n Values defined by this standard will never be in the range 0x80-0xff.\n Vendors who define additional families must use an encoding in this range.\n\n \\note Values of this type are encoded in the persistent key store.\n       Any changes to existing values will require bumping the storage\n       format version and providing a translation when reading the old\n       format."]
pub type psa_ecc_family_t = u8;
#[doc = " The type of PSA Diffie-Hellman group family identifiers.\n\n Values of this type are generally constructed by macros called\n `PSA_DH_FAMILY_xxx`.\n\n The group identifier is required to create a Diffie-Hellman key using the\n PSA_KEY_TYPE_DH_KEY_PAIR() or PSA_KEY_TYPE_DH_PUBLIC_KEY()\n macros.\n\n Values defined by this standard will never be in the range 0x80-0xff.\n Vendors who define additional families must use an encoding in this range.\n\n \\note Values of this type are encoded in the persistent key store.\n       Any changes to existing values will require bumping the storage\n       format version and providing a translation when reading the old\n       format."]
pub type psa_dh_family_t = u8;
#[doc = " \\brief Encoding of a cryptographic algorithm.\n\n Values of this type are generally constructed by macros called\n `PSA_ALG_xxx`.\n\n For algorithms that can be applied to multiple key types, this type\n does not encode the key type. For example, for symmetric ciphers\n based on a block cipher, #psa_algorithm_t encodes the block cipher\n mode and the padding mode while the block cipher itself is encoded\n via #psa_key_type_t.\n\n \\note Values of this type are encoded in the persistent key store.\n       Any changes to existing values will require bumping the storage\n       format version and providing a translation when reading the old\n       format."]
pub type psa_algorithm_t = u32;
#[doc = " Encoding of key lifetimes.\n\n The lifetime of a key indicates where it is stored and what system actions\n may create and destroy it.\n\n Lifetime values have the following structure:\n - Bits 0-7 (#PSA_KEY_LIFETIME_GET_PERSISTENCE(\\c lifetime)):\n   persistence level. This value indicates what device management\n   actions can cause it to be destroyed. In particular, it indicates\n   whether the key is _volatile_ or _persistent_.\n   See ::psa_key_persistence_t for more information.\n - Bits 8-31 (#PSA_KEY_LIFETIME_GET_LOCATION(\\c lifetime)):\n   location indicator. This value indicates which part of the system\n   has access to the key material and can perform operations using the key.\n   See ::psa_key_location_t for more information.\n\n Volatile keys are automatically destroyed when the application instance\n terminates or on a power reset of the device. Persistent keys are\n preserved until the application explicitly destroys them or until an\n integration-specific device management event occurs (for example,\n a factory reset).\n\n Persistent keys have a key identifier of type #mbedtls_svc_key_id_t.\n This identifier remains valid throughout the lifetime of the key,\n even if the application instance that created the key terminates.\n The application can call psa_open_key() to open a persistent key that\n it created previously.\n\n The default lifetime of a key is #PSA_KEY_LIFETIME_VOLATILE. The lifetime\n #PSA_KEY_LIFETIME_PERSISTENT is supported if persistent storage is\n available. Other lifetime values may be supported depending on the\n library configuration.\n\n Values of this type are generally constructed by macros called\n `PSA_KEY_LIFETIME_xxx`.\n\n \\note Values of this type are encoded in the persistent key store.\n       Any changes to existing values will require bumping the storage\n       format version and providing a translation when reading the old\n       format."]
pub type psa_key_lifetime_t = u32;
#[doc = " Encoding of key persistence levels.\n\n What distinguishes different persistence levels is what device management\n events may cause keys to be destroyed. _Volatile_ keys are destroyed\n by a power reset. Persistent keys may be destroyed by events such as\n a transfer of ownership or a factory reset. What management events\n actually affect persistent keys at different levels is outside the\n scope of the PSA Cryptography specification.\n\n The PSA Cryptography specification defines the following values of\n persistence levels:\n - \\c 0 = #PSA_KEY_PERSISTENCE_VOLATILE: volatile key.\n   A volatile key is automatically destroyed by the implementation when\n   the application instance terminates. In particular, a volatile key\n   is automatically destroyed on a power reset of the device.\n - \\c 1 = #PSA_KEY_PERSISTENCE_DEFAULT:\n   persistent key with a default lifetime.\n - \\c 2-254: currently not supported by Mbed TLS.\n - \\c 255 = #PSA_KEY_PERSISTENCE_READ_ONLY:\n   read-only or write-once key.\n   A key with this persistence level cannot be destroyed.\n   Mbed TLS does not currently offer a way to create such keys, but\n   integrations of Mbed TLS can use it for built-in keys that the\n   application cannot modify (for example, a hardware unique key (HUK)).\n\n \\note Key persistence levels are 8-bit values. Key management\n       interfaces operate on lifetimes (type ::psa_key_lifetime_t) which\n       encode the persistence as the lower 8 bits of a 32-bit value.\n\n \\note Values of this type are encoded in the persistent key store.\n       Any changes to existing values will require bumping the storage\n       format version and providing a translation when reading the old\n       format."]
pub type psa_key_persistence_t = u8;
#[doc = " Encoding of key location indicators.\n\n If an integration of Mbed TLS can make calls to external\n cryptoprocessors such as secure elements, the location of a key\n indicates which secure element performs the operations on the key.\n Depending on the design of the secure element, the key\n material may be stored either in the secure element, or\n in wrapped (encrypted) form alongside the key metadata in the\n primary local storage.\n\n The PSA Cryptography API specification defines the following values of\n location indicators:\n - \\c 0: primary local storage.\n   This location is always available.\n   The primary local storage is typically the same storage area that\n   contains the key metadata.\n - \\c 1: primary secure element.\n   Integrations of Mbed TLS should support this value if there is a secure\n   element attached to the operating environment.\n   As a guideline, secure elements may provide higher resistance against\n   side channel and physical attacks than the primary local storage, but may\n   have restrictions on supported key types, sizes, policies and operations\n   and may have different performance characteristics.\n - \\c 2-0x7fffff: other locations defined by a PSA specification.\n   The PSA Cryptography API does not currently assign any meaning to these\n   locations, but future versions of that specification or other PSA\n   specifications may do so.\n - \\c 0x800000-0xffffff: vendor-defined locations.\n   No PSA specification will assign a meaning to locations in this range.\n\n \\note Key location indicators are 24-bit values. Key management\n       interfaces operate on lifetimes (type ::psa_key_lifetime_t) which\n       encode the location as the upper 24 bits of a 32-bit value.\n\n \\note Values of this type are encoded in the persistent key store.\n       Any changes to existing values will require bumping the storage\n       format version and providing a translation when reading the old\n       format."]
pub type psa_key_location_t = u32;
#[doc = " Encoding of identifiers of persistent keys.\n\n - Applications may freely choose key identifiers in the range\n   #PSA_KEY_ID_USER_MIN to #PSA_KEY_ID_USER_MAX.\n - The implementation may define additional key identifiers in the range\n   #PSA_KEY_ID_VENDOR_MIN to #PSA_KEY_ID_VENDOR_MAX.\n - 0 is reserved as an invalid key identifier.\n - Key identifiers outside these ranges are reserved for future use.\n\n \\note Values of this type are encoded in the persistent key store.\n       Any changes to how values are allocated must require careful\n       consideration to allow backward compatibility."]
pub type psa_key_id_t = u32;
pub type mbedtls_svc_key_id_t = psa_key_id_t;
#[doc = " \\brief Encoding of permitted usage on a key.\n\n Values of this type are generally constructed as bitwise-ors of macros\n called `PSA_KEY_USAGE_xxx`.\n\n \\note Values of this type are encoded in the persistent key store.\n       Any changes to existing values will require bumping the storage\n       format version and providing a translation when reading the old\n       format."]
pub type psa_key_usage_t = u32;
#[doc = " The type of a structure containing key attributes.\n\n This is an opaque structure that can represent the metadata of a key\n object. Metadata that can be stored in attributes includes:\n - The location of the key in storage, indicated by its key identifier\n   and its lifetime.\n - The key's policy, comprising usage flags and a specification of\n   the permitted algorithm(s).\n - Information about the key itself: the key type and its size.\n - Additional implementation-defined attributes.\n\n The actual key material is not considered an attribute of a key.\n Key attributes do not contain information that is generally considered\n highly confidential.\n\n An attribute structure works like a simple data structure where each function\n `psa_set_key_xxx` sets a field and the corresponding function\n `psa_get_key_xxx` retrieves the value of the corresponding field.\n However, a future version of the library  may report values that are\n equivalent to the original one, but have a different encoding. Invalid\n values may be mapped to different, also invalid values.\n\n An attribute structure may contain references to auxiliary resources,\n for example pointers to allocated memory or indirect references to\n pre-calculated values. In order to free such resources, the application\n must call psa_reset_key_attributes(). As an exception, calling\n psa_reset_key_attributes() on an attribute structure is optional if\n the structure has only been modified by the following functions\n since it was initialized or last reset with psa_reset_key_attributes():\n - psa_set_key_id()\n - psa_set_key_lifetime()\n - psa_set_key_type()\n - psa_set_key_bits()\n - psa_set_key_usage_flags()\n - psa_set_key_algorithm()\n\n Before calling any function on a key attribute structure, the application\n must initialize it by any of the following means:\n - Set the structure to all-bits-zero, for example:\n   \\code\n   psa_key_attributes_t attributes;\n   memset(&attributes, 0, sizeof(attributes));\n   \\endcode\n - Initialize the structure to logical zero values, for example:\n   \\code\n   psa_key_attributes_t attributes = {0};\n   \\endcode\n - Initialize the structure to the initializer #PSA_KEY_ATTRIBUTES_INIT,\n   for example:\n   \\code\n   psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;\n   \\endcode\n - Assign the result of the function psa_key_attributes_init()\n   to the structure, for example:\n   \\code\n   psa_key_attributes_t attributes;\n   attributes = psa_key_attributes_init();\n   \\endcode\n\n A freshly initialized attribute structure contains the following\n values:\n\n - lifetime: #PSA_KEY_LIFETIME_VOLATILE.\n - key identifier: 0 (which is not a valid key identifier).\n - type: \\c 0 (meaning that the type is unspecified).\n - key size: \\c 0 (meaning that the size is unspecified).\n - usage flags: \\c 0 (which allows no usage except exporting a public key).\n - algorithm: \\c 0 (which allows no cryptographic usage, but allows\n   exporting).\n\n A typical sequence to create a key is as follows:\n -# Create and initialize an attribute structure.\n -# If the key is persistent, call psa_set_key_id().\n    Also call psa_set_key_lifetime() to place the key in a non-default\n    location.\n -# Set the key policy with psa_set_key_usage_flags() and\n    psa_set_key_algorithm().\n -# Set the key type with psa_set_key_type().\n    Skip this step if copying an existing key with psa_copy_key().\n -# When generating a random key with psa_generate_key() or deriving a key\n    with psa_key_derivation_output_key(), set the desired key size with\n    psa_set_key_bits().\n -# Call a key creation function: psa_import_key(), psa_generate_key(),\n    psa_key_derivation_output_key() or psa_copy_key(). This function reads\n    the attribute structure, creates a key with these attributes, and\n    outputs a key identifier to the newly created key.\n -# The attribute structure is now no longer necessary.\n    You may call psa_reset_key_attributes(), although this is optional\n    with the workflow presented here because the attributes currently\n    defined in this specification do not require any additional resources\n    beyond the structure itself.\n\n A typical sequence to query a key's attributes is as follows:\n -# Call psa_get_key_attributes().\n -# Call `psa_get_key_xxx` functions to retrieve the attribute(s) that\n    you are interested in.\n -# Call psa_reset_key_attributes() to free any resources that may be\n    used by the attribute structure.\n\n Once a key has been created, it is impossible to change its attributes."]
pub type psa_key_attributes_t = psa_key_attributes_s;
#[doc = " \\brief Encoding of the step of a key derivation.\n\n Values of this type are generally constructed by macros called\n `PSA_KEY_DERIVATION_INPUT_xxx`."]
pub type psa_key_derivation_step_t = u16;
extern "C" {
    #[doc = " \\brief Library initialization.\n\n Applications must call this function before calling any other\n function in this module.\n\n Applications may call this function more than once. Once a call\n succeeds, subsequent calls are guaranteed to succeed.\n\n If the application calls other functions before calling psa_crypto_init(),\n the behavior is undefined. Implementations are encouraged to either perform\n the operation as if the library had been initialized or to return\n #PSA_ERROR_BAD_STATE or some other applicable error. In particular,\n implementations should not return a success status if the lack of\n initialization may have security implications, for example due to improper\n seeding of the random number generator.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_STORAGE \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription"]
    pub fn psa_crypto_init() -> psa_status_t;
}
extern "C" {
    #[doc = " Retrieve the attributes of a key.\n\n This function first resets the attribute structure as with\n psa_reset_key_attributes(). It then copies the attributes of\n the given key into the given attribute structure.\n\n \\note This function may allocate memory or other resources.\n       Once you have called this function on an attribute structure,\n       you must call psa_reset_key_attributes() to free these resources.\n\n \\param[in] key               Identifier of the key to query.\n \\param[in,out] attributes    On success, the attributes of the key.\n                              On failure, equivalent to a\n                              freshly-initialized structure.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription\n \\retval #PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_get_key_attributes(
        key: mbedtls_svc_key_id_t,
        attributes: *mut psa_key_attributes_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Reset a key attribute structure to a freshly initialized state.\n\n You must initialize the attribute structure as described in the\n documentation of the type #psa_key_attributes_t before calling this\n function. Once the structure has been initialized, you may call this\n function at any time.\n\n This function frees any auxiliary resources that the structure\n may contain.\n\n \\param[in,out] attributes    The attribute structure to reset."]
    pub fn psa_reset_key_attributes(attributes: *mut psa_key_attributes_t);
}
extern "C" {
    #[doc = " Remove non-essential copies of key material from memory.\n\n If the key identifier designates a volatile key, this functions does not do\n anything and returns successfully.\n\n If the key identifier designates a persistent key, then this function will\n free all resources associated with the key in volatile memory. The key\n data in persistent storage is not affected and the key can still be used.\n\n \\param key Identifier of the key to purge.\n\n \\retval #PSA_SUCCESS\n         The key material will have been removed from memory if it is not\n         currently required.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not a valid key identifier.\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_purge_key(key: mbedtls_svc_key_id_t) -> psa_status_t;
}
extern "C" {
    #[doc = " Make a copy of a key.\n\n Copy key material from one location to another.\n\n This function is primarily useful to copy a key from one location\n to another, since it populates a key using the material from\n another key which may have a different lifetime.\n\n This function may be used to share a key with a different party,\n subject to implementation-defined restrictions on key sharing.\n\n The policy on the source key must have the usage flag\n #PSA_KEY_USAGE_COPY set.\n This flag is sufficient to permit the copy if the key has the lifetime\n #PSA_KEY_LIFETIME_VOLATILE or #PSA_KEY_LIFETIME_PERSISTENT.\n Some secure elements do not provide a way to copy a key without\n making it extractable from the secure element. If a key is located\n in such a secure element, then the key must have both usage flags\n #PSA_KEY_USAGE_COPY and #PSA_KEY_USAGE_EXPORT in order to make\n a copy of the key outside the secure element.\n\n The resulting key may only be used in a way that conforms to\n both the policy of the original key and the policy specified in\n the \\p attributes parameter:\n - The usage flags on the resulting key are the bitwise-and of the\n   usage flags on the source policy and the usage flags in \\p attributes.\n - If both allow the same algorithm or wildcard-based\n   algorithm policy, the resulting key has the same algorithm policy.\n - If either of the policies allows an algorithm and the other policy\n   allows a wildcard-based algorithm policy that includes this algorithm,\n   the resulting key allows the same algorithm.\n - If the policies do not allow any algorithm in common, this function\n   fails with the status #PSA_ERROR_INVALID_ARGUMENT.\n\n The effect of this function on implementation-defined attributes is\n implementation-defined.\n\n \\param source_key        The key to copy. It must allow the usage\n                          #PSA_KEY_USAGE_COPY. If a private or secret key is\n                          being copied outside of a secure element it must\n                          also allow #PSA_KEY_USAGE_EXPORT.\n \\param[in] attributes    The attributes for the new key.\n                          They are used as follows:\n                          - The key type and size may be 0. If either is\n                            nonzero, it must match the corresponding\n                            attribute of the source key.\n                          - The key location (the lifetime and, for\n                            persistent keys, the key identifier) is\n                            used directly.\n                          - The policy constraints (usage flags and\n                            algorithm policy) are combined from\n                            the source key and \\p attributes so that\n                            both sets of restrictions apply, as\n                            described in the documentation of this function.\n \\param[out] target_key   On success, an identifier for the newly created\n                          key. For persistent keys, this is the key\n                          identifier defined in \\p attributes.\n                          \\c 0 on failure.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_INVALID_HANDLE\n         \\p source_key is invalid.\n \\retval #PSA_ERROR_ALREADY_EXISTS\n         This is an attempt to create a persistent key, and there is\n         already a persistent key with the given identifier.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The lifetime or identifier in \\p attributes are invalid, or\n         the policy constraints on the source and specified in\n         \\p attributes are incompatible, or\n         \\p attributes specifies a key type or key size\n         which does not match the attributes of the source key.\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The source key does not have the #PSA_KEY_USAGE_COPY usage flag, or\n         the source key is not exportable and its lifetime does not\n         allow copying it to the target's lifetime.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_STORAGE \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_copy_key(
        source_key: mbedtls_svc_key_id_t,
        attributes: *const psa_key_attributes_t,
        target_key: *mut mbedtls_svc_key_id_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Destroy a key.\n\n This function destroys a key from both volatile\n memory and, if applicable, non-volatile storage. Implementations shall\n make a best effort to ensure that the key material cannot be recovered.\n\n This function also erases any metadata such as policies and frees\n resources associated with the key.\n\n If a key is currently in use in a multipart operation, then destroying the\n key will cause the multipart operation to fail.\n\n \\param key  Identifier of the key to erase. If this is \\c 0, do nothing and\n             return #PSA_SUCCESS.\n\n \\retval #PSA_SUCCESS\n         \\p key was a valid identifier and the key material that it\n         referred to has been erased. Alternatively, \\p key is \\c 0.\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The key cannot be erased because it is\n         read-only, either due to a policy or due to physical restrictions.\n \\retval #PSA_ERROR_INVALID_HANDLE\n         \\p key is not a valid identifier nor \\c 0.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n         There was a failure in communication with the cryptoprocessor.\n         The key material may still be present in the cryptoprocessor.\n \\retval #PSA_ERROR_DATA_INVALID\n         This error is typically a result of either storage corruption on a\n         cleartext storage backend, or an attempt to read data that was\n         written by an incompatible version of the library.\n \\retval #PSA_ERROR_STORAGE_FAILURE\n         The storage is corrupted. Implementations shall make a best effort\n         to erase key material even in this stage, however applications\n         should be aware that it may be impossible to guarantee that the\n         key material is not recoverable in such cases.\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n         An unexpected condition which is not a storage corruption or\n         a communication failure occurred. The cryptoprocessor may have\n         been compromised.\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_destroy_key(key: mbedtls_svc_key_id_t) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Import a key in binary format.\n\n This function supports any output from psa_export_key(). Refer to the\n documentation of psa_export_public_key() for the format of public keys\n and to the documentation of psa_export_key() for the format for\n other key types.\n\n The key data determines the key size. The attributes may optionally\n specify a key size; in this case it must match the size determined\n from the key data. A key size of 0 in \\p attributes indicates that\n the key size is solely determined by the key data.\n\n Implementations must reject an attempt to import a key of size 0.\n\n This specification supports a single format for each key type.\n Implementations may support other formats as long as the standard\n format is supported. Implementations that support other formats\n should ensure that the formats are clearly unambiguous so as to\n minimize the risk that an invalid input is accidentally interpreted\n according to a different format.\n\n \\param[in] attributes    The attributes for the new key.\n                          The key size is always determined from the\n                          \\p data buffer.\n                          If the key size in \\p attributes is nonzero,\n                          it must be equal to the size from \\p data.\n \\param[out] key          On success, an identifier to the newly created key.\n                          For persistent keys, this is the key identifier\n                          defined in \\p attributes.\n                          \\c 0 on failure.\n \\param[in] data    Buffer containing the key data. The content of this\n                    buffer is interpreted according to the type declared\n                    in \\p attributes.\n                    All implementations must support at least the format\n                    described in the documentation\n                    of psa_export_key() or psa_export_public_key() for\n                    the chosen type. Implementations may allow other\n                    formats, but should be conservative: implementations\n                    should err on the side of rejecting content if it\n                    may be erroneous (e.g. wrong type or truncated data).\n \\param data_length Size of the \\p data buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n         If the key is persistent, the key material and the key's metadata\n         have been saved to persistent storage.\n \\retval #PSA_ERROR_ALREADY_EXISTS\n         This is an attempt to create a persistent key, and there is\n         already a persistent key with the given identifier.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         The key type or key size is not supported, either by the\n         implementation in general or in this particular persistent location.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The key attributes, as a whole, are invalid, or\n         the key data is not correctly formatted, or\n         the size in \\p attributes is nonzero and does not match the size\n         of the key data.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_STORAGE \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription\n \\retval #PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_import_key(
        attributes: *const psa_key_attributes_t,
        data: *const u8,
        data_length: usize,
        key: *mut mbedtls_svc_key_id_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Export a key in binary format.\n\n The output of this function can be passed to psa_import_key() to\n create an equivalent object.\n\n If the implementation of psa_import_key() supports other formats\n beyond the format specified here, the output from psa_export_key()\n must use the representation specified here, not the original\n representation.\n\n For standard key types, the output format is as follows:\n\n - For symmetric keys (including MAC keys), the format is the\n   raw bytes of the key.\n - For DES, the key data consists of 8 bytes. The parity bits must be\n   correct.\n - For Triple-DES, the format is the concatenation of the\n   two or three DES keys.\n - For RSA key pairs (#PSA_KEY_TYPE_RSA_KEY_PAIR), the format\n   is the non-encrypted DER encoding of the representation defined by\n   PKCS\\#1 (RFC 8017) as `RSAPrivateKey`, version 0.\n   ```\n   RSAPrivateKey ::= SEQUENCE {\n       version             INTEGER,  -- must be 0\n       modulus             INTEGER,  -- n\n       publicExponent      INTEGER,  -- e\n       privateExponent     INTEGER,  -- d\n       prime1              INTEGER,  -- p\n       prime2              INTEGER,  -- q\n       exponent1           INTEGER,  -- d mod (p-1)\n       exponent2           INTEGER,  -- d mod (q-1)\n       coefficient         INTEGER,  -- (inverse of q) mod p\n   }\n   ```\n - For elliptic curve key pairs (key types for which\n   #PSA_KEY_TYPE_IS_ECC_KEY_PAIR is true), the format is\n   a representation of the private value as a `ceiling(m/8)`-byte string\n   where `m` is the bit size associated with the curve, i.e. the bit size\n   of the order of the curve's coordinate field. This byte string is\n   in little-endian order for Montgomery curves (curve types\n   `PSA_ECC_FAMILY_CURVEXXX`), and in big-endian order for Weierstrass\n   curves (curve types `PSA_ECC_FAMILY_SECTXXX`, `PSA_ECC_FAMILY_SECPXXX`\n   and `PSA_ECC_FAMILY_BRAINPOOL_PXXX`).\n   For Weierstrass curves, this is the content of the `privateKey` field of\n   the `ECPrivateKey` format defined by RFC 5915.  For Montgomery curves,\n   the format is defined by RFC 7748, and output is masked according to §5.\n   For twisted Edwards curves, the private key is as defined by RFC 8032\n   (a 32-byte string for Edwards25519, a 57-byte string for Edwards448).\n - For Diffie-Hellman key exchange key pairs (key types for which\n   #PSA_KEY_TYPE_IS_DH_KEY_PAIR is true), the\n   format is the representation of the private key `x` as a big-endian byte\n   string. The length of the byte string is the private key size in bytes\n   (leading zeroes are not stripped).\n - For public keys (key types for which #PSA_KEY_TYPE_IS_PUBLIC_KEY is\n   true), the format is the same as for psa_export_public_key().\n\n The policy on the key must have the usage flag #PSA_KEY_USAGE_EXPORT set.\n\n \\param key               Identifier of the key to export. It must allow the\n                          usage #PSA_KEY_USAGE_EXPORT, unless it is a public\n                          key.\n \\param[out] data         Buffer where the key data is to be written.\n \\param data_size         Size of the \\p data buffer in bytes.\n \\param[out] data_length  On success, the number of bytes\n                          that make up the key data.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The key does not have the #PSA_KEY_USAGE_EXPORT flag.\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p data buffer is too small. You can determine a\n         sufficient buffer size by calling\n         #PSA_EXPORT_KEY_OUTPUT_SIZE(\\c type, \\c bits)\n         where \\c type is the key type\n         and \\c bits is the key size in bits.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_export_key(
        key: mbedtls_svc_key_id_t,
        data: *mut u8,
        data_size: usize,
        data_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Export a public key or the public part of a key pair in binary format.\n\n The output of this function can be passed to psa_import_key() to\n create an object that is equivalent to the public key.\n\n This specification supports a single format for each key type.\n Implementations may support other formats as long as the standard\n format is supported. Implementations that support other formats\n should ensure that the formats are clearly unambiguous so as to\n minimize the risk that an invalid input is accidentally interpreted\n according to a different format.\n\n For standard key types, the output format is as follows:\n - For RSA public keys (#PSA_KEY_TYPE_RSA_PUBLIC_KEY), the DER encoding of\n   the representation defined by RFC 3279 &sect;2.3.1 as `RSAPublicKey`.\n   ```\n   RSAPublicKey ::= SEQUENCE {\n      modulus            INTEGER,    -- n\n      publicExponent     INTEGER  }  -- e\n   ```\n - For elliptic curve keys on a twisted Edwards curve (key types for which\n   #PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY is true and #PSA_KEY_TYPE_ECC_GET_FAMILY\n   returns #PSA_ECC_FAMILY_TWISTED_EDWARDS), the public key is as defined\n   by RFC 8032\n   (a 32-byte string for Edwards25519, a 57-byte string for Edwards448).\n - For other elliptic curve public keys (key types for which\n   #PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY is true), the format is the uncompressed\n   representation defined by SEC1 &sect;2.3.3 as the content of an ECPoint.\n   Let `m` be the bit size associated with the curve, i.e. the bit size of\n   `q` for a curve over `F_q`. The representation consists of:\n      - The byte 0x04;\n      - `x_P` as a `ceiling(m/8)`-byte string, big-endian;\n      - `y_P` as a `ceiling(m/8)`-byte string, big-endian.\n - For Diffie-Hellman key exchange public keys (key types for which\n   #PSA_KEY_TYPE_IS_DH_PUBLIC_KEY is true),\n   the format is the representation of the public key `y = g^x mod p` as a\n   big-endian byte string. The length of the byte string is the length of the\n   base prime `p` in bytes.\n\n Exporting a public key object or the public part of a key pair is\n always permitted, regardless of the key's usage flags.\n\n \\param key               Identifier of the key to export.\n \\param[out] data         Buffer where the key data is to be written.\n \\param data_size         Size of the \\p data buffer in bytes.\n \\param[out] data_length  On success, the number of bytes\n                          that make up the key data.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The key is neither a public key nor a key pair.\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p data buffer is too small. You can determine a\n         sufficient buffer size by calling\n         #PSA_EXPORT_KEY_OUTPUT_SIZE(#PSA_KEY_TYPE_PUBLIC_KEY_OF_KEY_PAIR(\\c type), \\c bits)\n         where \\c type is the key type\n         and \\c bits is the key size in bits.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_export_public_key(
        key: mbedtls_svc_key_id_t,
        data: *mut u8,
        data_size: usize,
        data_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Calculate the hash (digest) of a message.\n\n \\note To verify the hash of a message against an\n       expected value, use psa_hash_compare() instead.\n\n \\param alg               The hash algorithm to compute (\\c PSA_ALG_XXX value\n                          such that #PSA_ALG_IS_HASH(\\p alg) is true).\n \\param[in] input         Buffer containing the message to hash.\n \\param input_length      Size of the \\p input buffer in bytes.\n \\param[out] hash         Buffer where the hash is to be written.\n \\param hash_size         Size of the \\p hash buffer in bytes.\n \\param[out] hash_length  On success, the number of bytes\n                          that make up the hash value. This is always\n                          #PSA_HASH_LENGTH(\\p alg).\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not a hash algorithm.\n \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         \\p hash_size is too small\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_hash_compute(
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: usize,
        hash: *mut u8,
        hash_size: usize,
        hash_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Calculate the hash (digest) of a message and compare it with a\n reference value.\n\n \\param alg               The hash algorithm to compute (\\c PSA_ALG_XXX value\n                          such that #PSA_ALG_IS_HASH(\\p alg) is true).\n \\param[in] input         Buffer containing the message to hash.\n \\param input_length      Size of the \\p input buffer in bytes.\n \\param[out] hash         Buffer containing the expected hash value.\n \\param hash_length       Size of the \\p hash buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         The expected hash is identical to the actual hash of the input.\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The hash of the message was calculated successfully, but it\n         differs from the expected hash.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not a hash algorithm.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p input_length or \\p hash_length do not match the hash size for \\p alg\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_hash_compare(
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: usize,
        hash: *const u8,
        hash_length: usize,
    ) -> psa_status_t;
}
#[doc = " The type of the state data structure for multipart hash operations.\n\n Before calling any function on a hash operation object, the application must\n initialize it by any of the following means:\n - Set the structure to all-bits-zero, for example:\n   \\code\n   psa_hash_operation_t operation;\n   memset(&operation, 0, sizeof(operation));\n   \\endcode\n - Initialize the structure to logical zero values, for example:\n   \\code\n   psa_hash_operation_t operation = {0};\n   \\endcode\n - Initialize the structure to the initializer #PSA_HASH_OPERATION_INIT,\n   for example:\n   \\code\n   psa_hash_operation_t operation = PSA_HASH_OPERATION_INIT;\n   \\endcode\n - Assign the result of the function psa_hash_operation_init()\n   to the structure, for example:\n   \\code\n   psa_hash_operation_t operation;\n   operation = psa_hash_operation_init();\n   \\endcode\n\n This is an implementation-defined \\c struct. Applications should not\n make any assumptions about the content of this structure.\n Implementation details can change in future versions without notice."]
pub type psa_hash_operation_t = psa_hash_operation_s;
extern "C" {
    #[doc = " Set up a multipart hash operation.\n\n The sequence of operations to calculate a hash (message digest)\n is as follows:\n -# Allocate an operation object which will be passed to all the functions\n    listed here.\n -# Initialize the operation object with one of the methods described in the\n    documentation for #psa_hash_operation_t, e.g. #PSA_HASH_OPERATION_INIT.\n -# Call psa_hash_setup() to specify the algorithm.\n -# Call psa_hash_update() zero, one or more times, passing a fragment\n    of the message each time. The hash that is calculated is the hash\n    of the concatenation of these messages in order.\n -# To calculate the hash, call psa_hash_finish().\n    To compare the hash with an expected value, call psa_hash_verify().\n\n If an error occurs at any step after a call to psa_hash_setup(), the\n operation will need to be reset by a call to psa_hash_abort(). The\n application may call psa_hash_abort() at any time after the operation\n has been initialized.\n\n After a successful call to psa_hash_setup(), the application must\n eventually terminate the operation. The following events terminate an\n operation:\n - A successful call to psa_hash_finish() or psa_hash_verify().\n - A call to psa_hash_abort().\n\n \\param[in,out] operation The operation object to set up. It must have\n                          been initialized as per the documentation for\n                          #psa_hash_operation_t and not yet in use.\n \\param alg               The hash algorithm to compute (\\c PSA_ALG_XXX value\n                          such that #PSA_ALG_IS_HASH(\\p alg) is true).\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not a supported hash algorithm.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p alg is not a hash algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be inactive), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_hash_setup(
        operation: *mut psa_hash_operation_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Add a message fragment to a multipart hash operation.\n\n The application must call psa_hash_setup() before calling this function.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_hash_abort().\n\n \\param[in,out] operation Active hash operation.\n \\param[in] input         Buffer containing the message fragment to hash.\n \\param input_length      Size of the \\p input buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_hash_update(
        operation: *mut psa_hash_operation_t,
        input: *const u8,
        input_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Finish the calculation of the hash of a message.\n\n The application must call psa_hash_setup() before calling this function.\n This function calculates the hash of the message formed by concatenating\n the inputs passed to preceding calls to psa_hash_update().\n\n When this function returns successfully, the operation becomes inactive.\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_hash_abort().\n\n \\warning Applications should not call this function if they expect\n          a specific value for the hash. Call psa_hash_verify() instead.\n          Beware that comparing integrity or authenticity data such as\n          hash values with a function such as \\c memcmp is risky\n          because the time taken by the comparison may leak information\n          about the hashed data which could allow an attacker to guess\n          a valid hash and thereby bypass security controls.\n\n \\param[in,out] operation     Active hash operation.\n \\param[out] hash             Buffer where the hash is to be written.\n \\param hash_size             Size of the \\p hash buffer in bytes.\n \\param[out] hash_length      On success, the number of bytes\n                              that make up the hash value. This is always\n                              #PSA_HASH_LENGTH(\\c alg) where \\c alg is the\n                              hash algorithm that is calculated.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p hash buffer is too small. You can determine a\n         sufficient buffer size by calling #PSA_HASH_LENGTH(\\c alg)\n         where \\c alg is the hash algorithm that is calculated.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_hash_finish(
        operation: *mut psa_hash_operation_t,
        hash: *mut u8,
        hash_size: usize,
        hash_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Finish the calculation of the hash of a message and compare it with\n an expected value.\n\n The application must call psa_hash_setup() before calling this function.\n This function calculates the hash of the message formed by concatenating\n the inputs passed to preceding calls to psa_hash_update(). It then\n compares the calculated hash with the expected hash passed as a\n parameter to this function.\n\n When this function returns successfully, the operation becomes inactive.\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_hash_abort().\n\n \\note Implementations shall make the best effort to ensure that the\n comparison between the actual hash and the expected hash is performed\n in constant time.\n\n \\param[in,out] operation     Active hash operation.\n \\param[in] hash              Buffer containing the expected hash value.\n \\param hash_length           Size of the \\p hash buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         The expected hash is identical to the actual hash of the message.\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The hash of the message was calculated successfully, but it\n         differs from the expected hash.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_hash_verify(
        operation: *mut psa_hash_operation_t,
        hash: *const u8,
        hash_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Abort a hash operation.\n\n Aborting an operation frees all associated resources except for the\n \\p operation structure itself. Once aborted, the operation object\n can be reused for another operation by calling\n psa_hash_setup() again.\n\n You may call this function any time after the operation object has\n been initialized by one of the methods described in #psa_hash_operation_t.\n\n In particular, calling psa_hash_abort() after the operation has been\n terminated by a call to psa_hash_abort(), psa_hash_finish() or\n psa_hash_verify() is safe and has no effect.\n\n \\param[in,out] operation     Initialized hash operation.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_hash_abort(operation: *mut psa_hash_operation_t) -> psa_status_t;
}
extern "C" {
    #[doc = " Clone a hash operation.\n\n This function copies the state of an ongoing hash operation to\n a new operation object. In other words, this function is equivalent\n to calling psa_hash_setup() on \\p target_operation with the same\n algorithm that \\p source_operation was set up for, then\n psa_hash_update() on \\p target_operation with the same input that\n that was passed to \\p source_operation. After this function returns, the\n two objects are independent, i.e. subsequent calls involving one of\n the objects do not affect the other object.\n\n \\param[in] source_operation      The active hash operation to clone.\n \\param[in,out] target_operation  The operation object to set up.\n                                  It must be initialized but not active.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The \\p source_operation state is not valid (it must be active), or\n         the \\p target_operation state is not valid (it must be inactive), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_hash_clone(
        source_operation: *const psa_hash_operation_t,
        target_operation: *mut psa_hash_operation_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Calculate the MAC (message authentication code) of a message.\n\n \\note To verify the MAC of a message against an\n       expected value, use psa_mac_verify() instead.\n       Beware that comparing integrity or authenticity data such as\n       MAC values with a function such as \\c memcmp is risky\n       because the time taken by the comparison may leak information\n       about the MAC value which could allow an attacker to guess\n       a valid MAC and thereby bypass security controls.\n\n \\param key               Identifier of the key to use for the operation. It\n                          must allow the usage PSA_KEY_USAGE_SIGN_MESSAGE.\n \\param alg               The MAC algorithm to compute (\\c PSA_ALG_XXX value\n                          such that #PSA_ALG_IS_MAC(\\p alg) is true).\n \\param[in] input         Buffer containing the input message.\n \\param input_length      Size of the \\p input buffer in bytes.\n \\param[out] mac          Buffer where the MAC value is to be written.\n \\param mac_size          Size of the \\p mac buffer in bytes.\n \\param[out] mac_length   On success, the number of bytes\n                          that make up the MAC value.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not a MAC algorithm.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         \\p mac_size is too small\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE\n         The key could not be retrieved from storage.\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_mac_compute(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: usize,
        mac: *mut u8,
        mac_size: usize,
        mac_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Calculate the MAC of a message and compare it with a reference value.\n\n \\param key               Identifier of the key to use for the operation. It\n                          must allow the usage PSA_KEY_USAGE_VERIFY_MESSAGE.\n \\param alg               The MAC algorithm to compute (\\c PSA_ALG_XXX value\n                          such that #PSA_ALG_IS_MAC(\\p alg) is true).\n \\param[in] input         Buffer containing the input message.\n \\param input_length      Size of the \\p input buffer in bytes.\n \\param[out] mac          Buffer containing the expected MAC value.\n \\param mac_length        Size of the \\p mac buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         The expected MAC is identical to the actual MAC of the input.\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The MAC of the message was calculated successfully, but it\n         differs from the expected value.\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not a MAC algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE\n         The key could not be retrieved from storage.\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_mac_verify(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: usize,
        mac: *const u8,
        mac_length: usize,
    ) -> psa_status_t;
}
#[doc = " The type of the state data structure for multipart MAC operations.\n\n Before calling any function on a MAC operation object, the application must\n initialize it by any of the following means:\n - Set the structure to all-bits-zero, for example:\n   \\code\n   psa_mac_operation_t operation;\n   memset(&operation, 0, sizeof(operation));\n   \\endcode\n - Initialize the structure to logical zero values, for example:\n   \\code\n   psa_mac_operation_t operation = {0};\n   \\endcode\n - Initialize the structure to the initializer #PSA_MAC_OPERATION_INIT,\n   for example:\n   \\code\n   psa_mac_operation_t operation = PSA_MAC_OPERATION_INIT;\n   \\endcode\n - Assign the result of the function psa_mac_operation_init()\n   to the structure, for example:\n   \\code\n   psa_mac_operation_t operation;\n   operation = psa_mac_operation_init();\n   \\endcode\n\n\n This is an implementation-defined \\c struct. Applications should not\n make any assumptions about the content of this structure.\n Implementation details can change in future versions without notice."]
pub type psa_mac_operation_t = psa_mac_operation_s;
extern "C" {
    #[doc = " Set up a multipart MAC calculation operation.\n\n This function sets up the calculation of the MAC\n (message authentication code) of a byte string.\n To verify the MAC of a message against an\n expected value, use psa_mac_verify_setup() instead.\n\n The sequence of operations to calculate a MAC is as follows:\n -# Allocate an operation object which will be passed to all the functions\n    listed here.\n -# Initialize the operation object with one of the methods described in the\n    documentation for #psa_mac_operation_t, e.g. #PSA_MAC_OPERATION_INIT.\n -# Call psa_mac_sign_setup() to specify the algorithm and key.\n -# Call psa_mac_update() zero, one or more times, passing a fragment\n    of the message each time. The MAC that is calculated is the MAC\n    of the concatenation of these messages in order.\n -# At the end of the message, call psa_mac_sign_finish() to finish\n    calculating the MAC value and retrieve it.\n\n If an error occurs at any step after a call to psa_mac_sign_setup(), the\n operation will need to be reset by a call to psa_mac_abort(). The\n application may call psa_mac_abort() at any time after the operation\n has been initialized.\n\n After a successful call to psa_mac_sign_setup(), the application must\n eventually terminate the operation through one of the following methods:\n - A successful call to psa_mac_sign_finish().\n - A call to psa_mac_abort().\n\n \\param[in,out] operation The operation object to set up. It must have\n                          been initialized as per the documentation for\n                          #psa_mac_operation_t and not yet in use.\n \\param key               Identifier of the key to use for the operation. It\n                          must remain valid until the operation terminates.\n                          It must allow the usage PSA_KEY_USAGE_SIGN_MESSAGE.\n \\param alg               The MAC algorithm to compute (\\c PSA_ALG_XXX value\n                          such that #PSA_ALG_IS_MAC(\\p alg) is true).\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not a MAC algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE\n         The key could not be retrieved from storage.\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be inactive), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_mac_sign_setup(
        operation: *mut psa_mac_operation_t,
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set up a multipart MAC verification operation.\n\n This function sets up the verification of the MAC\n (message authentication code) of a byte string against an expected value.\n\n The sequence of operations to verify a MAC is as follows:\n -# Allocate an operation object which will be passed to all the functions\n    listed here.\n -# Initialize the operation object with one of the methods described in the\n    documentation for #psa_mac_operation_t, e.g. #PSA_MAC_OPERATION_INIT.\n -# Call psa_mac_verify_setup() to specify the algorithm and key.\n -# Call psa_mac_update() zero, one or more times, passing a fragment\n    of the message each time. The MAC that is calculated is the MAC\n    of the concatenation of these messages in order.\n -# At the end of the message, call psa_mac_verify_finish() to finish\n    calculating the actual MAC of the message and verify it against\n    the expected value.\n\n If an error occurs at any step after a call to psa_mac_verify_setup(), the\n operation will need to be reset by a call to psa_mac_abort(). The\n application may call psa_mac_abort() at any time after the operation\n has been initialized.\n\n After a successful call to psa_mac_verify_setup(), the application must\n eventually terminate the operation through one of the following methods:\n - A successful call to psa_mac_verify_finish().\n - A call to psa_mac_abort().\n\n \\param[in,out] operation The operation object to set up. It must have\n                          been initialized as per the documentation for\n                          #psa_mac_operation_t and not yet in use.\n \\param key               Identifier of the key to use for the operation. It\n                          must remain valid until the operation terminates.\n                          It must allow the usage\n                          PSA_KEY_USAGE_VERIFY_MESSAGE.\n \\param alg               The MAC algorithm to compute (\\c PSA_ALG_XXX value\n                          such that #PSA_ALG_IS_MAC(\\p alg) is true).\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\c key is not compatible with \\c alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\c alg is not supported or is not a MAC algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE\n         The key could not be retrieved from storage.\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be inactive), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_mac_verify_setup(
        operation: *mut psa_mac_operation_t,
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Add a message fragment to a multipart MAC operation.\n\n The application must call psa_mac_sign_setup() or psa_mac_verify_setup()\n before calling this function.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_mac_abort().\n\n \\param[in,out] operation Active MAC operation.\n \\param[in] input         Buffer containing the message fragment to add to\n                          the MAC calculation.\n \\param input_length      Size of the \\p input buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_mac_update(
        operation: *mut psa_mac_operation_t,
        input: *const u8,
        input_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Finish the calculation of the MAC of a message.\n\n The application must call psa_mac_sign_setup() before calling this function.\n This function calculates the MAC of the message formed by concatenating\n the inputs passed to preceding calls to psa_mac_update().\n\n When this function returns successfully, the operation becomes inactive.\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_mac_abort().\n\n \\warning Applications should not call this function if they expect\n          a specific value for the MAC. Call psa_mac_verify_finish() instead.\n          Beware that comparing integrity or authenticity data such as\n          MAC values with a function such as \\c memcmp is risky\n          because the time taken by the comparison may leak information\n          about the MAC value which could allow an attacker to guess\n          a valid MAC and thereby bypass security controls.\n\n \\param[in,out] operation Active MAC operation.\n \\param[out] mac          Buffer where the MAC value is to be written.\n \\param mac_size          Size of the \\p mac buffer in bytes.\n \\param[out] mac_length   On success, the number of bytes\n                          that make up the MAC value. This is always\n                          #PSA_MAC_LENGTH(\\c key_type, \\c key_bits, \\c alg)\n                          where \\c key_type and \\c key_bits are the type and\n                          bit-size respectively of the key and \\c alg is the\n                          MAC algorithm that is calculated.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p mac buffer is too small. You can determine a\n         sufficient buffer size by calling PSA_MAC_LENGTH().\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be an active mac sign\n         operation), or the library has not been previously initialized\n         by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_mac_sign_finish(
        operation: *mut psa_mac_operation_t,
        mac: *mut u8,
        mac_size: usize,
        mac_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Finish the calculation of the MAC of a message and compare it with\n an expected value.\n\n The application must call psa_mac_verify_setup() before calling this function.\n This function calculates the MAC of the message formed by concatenating\n the inputs passed to preceding calls to psa_mac_update(). It then\n compares the calculated MAC with the expected MAC passed as a\n parameter to this function.\n\n When this function returns successfully, the operation becomes inactive.\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_mac_abort().\n\n \\note Implementations shall make the best effort to ensure that the\n comparison between the actual MAC and the expected MAC is performed\n in constant time.\n\n \\param[in,out] operation Active MAC operation.\n \\param[in] mac           Buffer containing the expected MAC value.\n \\param mac_length        Size of the \\p mac buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         The expected MAC is identical to the actual MAC of the message.\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The MAC of the message was calculated successfully, but it\n         differs from the expected MAC.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be an active mac verify\n         operation), or the library has not been previously initialized\n         by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_mac_verify_finish(
        operation: *mut psa_mac_operation_t,
        mac: *const u8,
        mac_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Abort a MAC operation.\n\n Aborting an operation frees all associated resources except for the\n \\p operation structure itself. Once aborted, the operation object\n can be reused for another operation by calling\n psa_mac_sign_setup() or psa_mac_verify_setup() again.\n\n You may call this function any time after the operation object has\n been initialized by one of the methods described in #psa_mac_operation_t.\n\n In particular, calling psa_mac_abort() after the operation has been\n terminated by a call to psa_mac_abort(), psa_mac_sign_finish() or\n psa_mac_verify_finish() is safe and has no effect.\n\n \\param[in,out] operation Initialized MAC operation.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_mac_abort(operation: *mut psa_mac_operation_t) -> psa_status_t;
}
extern "C" {
    #[doc = " Encrypt a message using a symmetric cipher.\n\n This function encrypts a message with a random IV (initialization\n vector). Use the multipart operation interface with a\n #psa_cipher_operation_t object to provide other forms of IV.\n\n \\param key                   Identifier of the key to use for the operation.\n                              It must allow the usage #PSA_KEY_USAGE_ENCRYPT.\n \\param alg                   The cipher algorithm to compute\n                              (\\c PSA_ALG_XXX value such that\n                              #PSA_ALG_IS_CIPHER(\\p alg) is true).\n \\param[in] input             Buffer containing the message to encrypt.\n \\param input_length          Size of the \\p input buffer in bytes.\n \\param[out] output           Buffer where the output is to be written.\n                              The output contains the IV followed by\n                              the ciphertext proper.\n \\param output_size           Size of the \\p output buffer in bytes.\n \\param[out] output_length    On success, the number of bytes\n                              that make up the output.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not a cipher algorithm.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_cipher_encrypt(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: usize,
        output: *mut u8,
        output_size: usize,
        output_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Decrypt a message using a symmetric cipher.\n\n This function decrypts a message encrypted with a symmetric cipher.\n\n \\param key                   Identifier of the key to use for the operation.\n                              It must remain valid until the operation\n                              terminates. It must allow the usage\n                              #PSA_KEY_USAGE_DECRYPT.\n \\param alg                   The cipher algorithm to compute\n                              (\\c PSA_ALG_XXX value such that\n                              #PSA_ALG_IS_CIPHER(\\p alg) is true).\n \\param[in] input             Buffer containing the message to decrypt.\n                              This consists of the IV followed by the\n                              ciphertext proper.\n \\param input_length          Size of the \\p input buffer in bytes.\n \\param[out] output           Buffer where the plaintext is to be written.\n \\param output_size           Size of the \\p output buffer in bytes.\n \\param[out] output_length    On success, the number of bytes\n                              that make up the output.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not a cipher algorithm.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_cipher_decrypt(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: usize,
        output: *mut u8,
        output_size: usize,
        output_length: *mut usize,
    ) -> psa_status_t;
}
#[doc = " The type of the state data structure for multipart cipher operations.\n\n Before calling any function on a cipher operation object, the application\n must initialize it by any of the following means:\n - Set the structure to all-bits-zero, for example:\n   \\code\n   psa_cipher_operation_t operation;\n   memset(&operation, 0, sizeof(operation));\n   \\endcode\n - Initialize the structure to logical zero values, for example:\n   \\code\n   psa_cipher_operation_t operation = {0};\n   \\endcode\n - Initialize the structure to the initializer #PSA_CIPHER_OPERATION_INIT,\n   for example:\n   \\code\n   psa_cipher_operation_t operation = PSA_CIPHER_OPERATION_INIT;\n   \\endcode\n - Assign the result of the function psa_cipher_operation_init()\n   to the structure, for example:\n   \\code\n   psa_cipher_operation_t operation;\n   operation = psa_cipher_operation_init();\n   \\endcode\n\n This is an implementation-defined \\c struct. Applications should not\n make any assumptions about the content of this structure.\n Implementation details can change in future versions without notice."]
pub type psa_cipher_operation_t = psa_cipher_operation_s;
extern "C" {
    #[doc = " Set the key for a multipart symmetric encryption operation.\n\n The sequence of operations to encrypt a message with a symmetric cipher\n is as follows:\n -# Allocate an operation object which will be passed to all the functions\n    listed here.\n -# Initialize the operation object with one of the methods described in the\n    documentation for #psa_cipher_operation_t, e.g.\n    #PSA_CIPHER_OPERATION_INIT.\n -# Call psa_cipher_encrypt_setup() to specify the algorithm and key.\n -# Call either psa_cipher_generate_iv() or psa_cipher_set_iv() to\n    generate or set the IV (initialization vector). You should use\n    psa_cipher_generate_iv() unless the protocol you are implementing\n    requires a specific IV value.\n -# Call psa_cipher_update() zero, one or more times, passing a fragment\n    of the message each time.\n -# Call psa_cipher_finish().\n\n If an error occurs at any step after a call to psa_cipher_encrypt_setup(),\n the operation will need to be reset by a call to psa_cipher_abort(). The\n application may call psa_cipher_abort() at any time after the operation\n has been initialized.\n\n After a successful call to psa_cipher_encrypt_setup(), the application must\n eventually terminate the operation. The following events terminate an\n operation:\n - A successful call to psa_cipher_finish().\n - A call to psa_cipher_abort().\n\n \\param[in,out] operation     The operation object to set up. It must have\n                              been initialized as per the documentation for\n                              #psa_cipher_operation_t and not yet in use.\n \\param key                   Identifier of the key to use for the operation.\n                              It must remain valid until the operation\n                              terminates. It must allow the usage\n                              #PSA_KEY_USAGE_ENCRYPT.\n \\param alg                   The cipher algorithm to compute\n                              (\\c PSA_ALG_XXX value such that\n                              #PSA_ALG_IS_CIPHER(\\p alg) is true).\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not a cipher algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be inactive), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_cipher_encrypt_setup(
        operation: *mut psa_cipher_operation_t,
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the key for a multipart symmetric decryption operation.\n\n The sequence of operations to decrypt a message with a symmetric cipher\n is as follows:\n -# Allocate an operation object which will be passed to all the functions\n    listed here.\n -# Initialize the operation object with one of the methods described in the\n    documentation for #psa_cipher_operation_t, e.g.\n    #PSA_CIPHER_OPERATION_INIT.\n -# Call psa_cipher_decrypt_setup() to specify the algorithm and key.\n -# Call psa_cipher_set_iv() with the IV (initialization vector) for the\n    decryption. If the IV is prepended to the ciphertext, you can call\n    psa_cipher_update() on a buffer containing the IV followed by the\n    beginning of the message.\n -# Call psa_cipher_update() zero, one or more times, passing a fragment\n    of the message each time.\n -# Call psa_cipher_finish().\n\n If an error occurs at any step after a call to psa_cipher_decrypt_setup(),\n the operation will need to be reset by a call to psa_cipher_abort(). The\n application may call psa_cipher_abort() at any time after the operation\n has been initialized.\n\n After a successful call to psa_cipher_decrypt_setup(), the application must\n eventually terminate the operation. The following events terminate an\n operation:\n - A successful call to psa_cipher_finish().\n - A call to psa_cipher_abort().\n\n \\param[in,out] operation     The operation object to set up. It must have\n                              been initialized as per the documentation for\n                              #psa_cipher_operation_t and not yet in use.\n \\param key                   Identifier of the key to use for the operation.\n                              It must remain valid until the operation\n                              terminates. It must allow the usage\n                              #PSA_KEY_USAGE_DECRYPT.\n \\param alg                   The cipher algorithm to compute\n                              (\\c PSA_ALG_XXX value such that\n                              #PSA_ALG_IS_CIPHER(\\p alg) is true).\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not a cipher algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be inactive), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_cipher_decrypt_setup(
        operation: *mut psa_cipher_operation_t,
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Generate an IV for a symmetric encryption operation.\n\n This function generates a random IV (initialization vector), nonce\n or initial counter value for the encryption operation as appropriate\n for the chosen algorithm, key type and key size.\n\n The application must call psa_cipher_encrypt_setup() before\n calling this function.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_cipher_abort().\n\n \\param[in,out] operation     Active cipher operation.\n \\param[out] iv               Buffer where the generated IV is to be written.\n \\param iv_size               Size of the \\p iv buffer in bytes.\n \\param[out] iv_length        On success, the number of bytes of the\n                              generated IV.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p iv buffer is too small.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active, with no IV set),\n         or the library has not been previously initialized\n         by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_cipher_generate_iv(
        operation: *mut psa_cipher_operation_t,
        iv: *mut u8,
        iv_size: usize,
        iv_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the IV for a symmetric encryption or decryption operation.\n\n This function sets the IV (initialization vector), nonce\n or initial counter value for the encryption or decryption operation.\n\n The application must call psa_cipher_encrypt_setup() before\n calling this function.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_cipher_abort().\n\n \\note When encrypting, applications should use psa_cipher_generate_iv()\n instead of this function, unless implementing a protocol that requires\n a non-random IV.\n\n \\param[in,out] operation     Active cipher operation.\n \\param[in] iv                Buffer containing the IV to use.\n \\param iv_length             Size of the IV in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The size of \\p iv is not acceptable for the chosen algorithm,\n         or the chosen algorithm does not use an IV.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be an active cipher\n         encrypt operation, with no IV set), or the library has not been\n         previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_cipher_set_iv(
        operation: *mut psa_cipher_operation_t,
        iv: *const u8,
        iv_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Encrypt or decrypt a message fragment in an active cipher operation.\n\n Before calling this function, you must:\n 1. Call either psa_cipher_encrypt_setup() or psa_cipher_decrypt_setup().\n    The choice of setup function determines whether this function\n    encrypts or decrypts its input.\n 2. If the algorithm requires an IV, call psa_cipher_generate_iv()\n    (recommended when encrypting) or psa_cipher_set_iv().\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_cipher_abort().\n\n \\param[in,out] operation     Active cipher operation.\n \\param[in] input             Buffer containing the message fragment to\n                              encrypt or decrypt.\n \\param input_length          Size of the \\p input buffer in bytes.\n \\param[out] output           Buffer where the output is to be written.\n \\param output_size           Size of the \\p output buffer in bytes.\n \\param[out] output_length    On success, the number of bytes\n                              that make up the returned output.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p output buffer is too small.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active, with an IV set\n         if required for the algorithm), or the library has not been\n         previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_cipher_update(
        operation: *mut psa_cipher_operation_t,
        input: *const u8,
        input_length: usize,
        output: *mut u8,
        output_size: usize,
        output_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Finish encrypting or decrypting a message in a cipher operation.\n\n The application must call psa_cipher_encrypt_setup() or\n psa_cipher_decrypt_setup() before calling this function. The choice\n of setup function determines whether this function encrypts or\n decrypts its input.\n\n This function finishes the encryption or decryption of the message\n formed by concatenating the inputs passed to preceding calls to\n psa_cipher_update().\n\n When this function returns successfully, the operation becomes inactive.\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_cipher_abort().\n\n \\param[in,out] operation     Active cipher operation.\n \\param[out] output           Buffer where the output is to be written.\n \\param output_size           Size of the \\p output buffer in bytes.\n \\param[out] output_length    On success, the number of bytes\n                              that make up the returned output.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The total input size passed to this operation is not valid for\n         this particular algorithm. For example, the algorithm is a based\n         on block cipher and requires a whole number of blocks, but the\n         total input size is not a multiple of the block size.\n \\retval #PSA_ERROR_INVALID_PADDING\n         This is a decryption operation for an algorithm that includes\n         padding, and the ciphertext does not contain valid padding.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p output buffer is too small.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active, with an IV set\n         if required for the algorithm), or the library has not been\n         previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_cipher_finish(
        operation: *mut psa_cipher_operation_t,
        output: *mut u8,
        output_size: usize,
        output_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Abort a cipher operation.\n\n Aborting an operation frees all associated resources except for the\n \\p operation structure itself. Once aborted, the operation object\n can be reused for another operation by calling\n psa_cipher_encrypt_setup() or psa_cipher_decrypt_setup() again.\n\n You may call this function any time after the operation object has\n been initialized as described in #psa_cipher_operation_t.\n\n In particular, calling psa_cipher_abort() after the operation has been\n terminated by a call to psa_cipher_abort() or psa_cipher_finish()\n is safe and has no effect.\n\n \\param[in,out] operation     Initialized cipher operation.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_cipher_abort(operation: *mut psa_cipher_operation_t) -> psa_status_t;
}
extern "C" {
    #[doc = " Process an authenticated encryption operation.\n\n \\param key                     Identifier of the key to use for the\n                                operation. It must allow the usage\n                                #PSA_KEY_USAGE_ENCRYPT.\n \\param alg                     The AEAD algorithm to compute\n                                (\\c PSA_ALG_XXX value such that\n                                #PSA_ALG_IS_AEAD(\\p alg) is true).\n \\param[in] nonce               Nonce or IV to use.\n \\param nonce_length            Size of the \\p nonce buffer in bytes.\n \\param[in] additional_data     Additional data that will be authenticated\n                                but not encrypted.\n \\param additional_data_length  Size of \\p additional_data in bytes.\n \\param[in] plaintext           Data that will be authenticated and\n                                encrypted.\n \\param plaintext_length        Size of \\p plaintext in bytes.\n \\param[out] ciphertext         Output buffer for the authenticated and\n                                encrypted data. The additional data is not\n                                part of this output. For algorithms where the\n                                encrypted data and the authentication tag\n                                are defined as separate outputs, the\n                                authentication tag is appended to the\n                                encrypted data.\n \\param ciphertext_size         Size of the \\p ciphertext buffer in bytes.\n                                This must be appropriate for the selected\n                                algorithm and key:\n                                - A sufficient output size is\n                                  #PSA_AEAD_ENCRYPT_OUTPUT_SIZE(\\c key_type,\n                                  \\p alg, \\p plaintext_length) where\n                                  \\c key_type is the type of \\p key.\n                                - #PSA_AEAD_ENCRYPT_OUTPUT_MAX_SIZE(\\p\n                                  plaintext_length) evaluates to the maximum\n                                  ciphertext size of any supported AEAD\n                                  encryption.\n \\param[out] ciphertext_length  On success, the size of the output\n                                in the \\p ciphertext buffer.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not an AEAD algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         \\p ciphertext_size is too small.\n         #PSA_AEAD_ENCRYPT_OUTPUT_SIZE(\\c key_type, \\p alg,\n         \\p plaintext_length) or\n         #PSA_AEAD_ENCRYPT_OUTPUT_MAX_SIZE(\\p plaintext_length) can be used to\n         determine the required buffer size.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_aead_encrypt(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        nonce: *const u8,
        nonce_length: usize,
        additional_data: *const u8,
        additional_data_length: usize,
        plaintext: *const u8,
        plaintext_length: usize,
        ciphertext: *mut u8,
        ciphertext_size: usize,
        ciphertext_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Process an authenticated decryption operation.\n\n \\param key                     Identifier of the key to use for the\n                                operation. It must allow the usage\n                                #PSA_KEY_USAGE_DECRYPT.\n \\param alg                     The AEAD algorithm to compute\n                                (\\c PSA_ALG_XXX value such that\n                                #PSA_ALG_IS_AEAD(\\p alg) is true).\n \\param[in] nonce               Nonce or IV to use.\n \\param nonce_length            Size of the \\p nonce buffer in bytes.\n \\param[in] additional_data     Additional data that has been authenticated\n                                but not encrypted.\n \\param additional_data_length  Size of \\p additional_data in bytes.\n \\param[in] ciphertext          Data that has been authenticated and\n                                encrypted. For algorithms where the\n                                encrypted data and the authentication tag\n                                are defined as separate inputs, the buffer\n                                must contain the encrypted data followed\n                                by the authentication tag.\n \\param ciphertext_length       Size of \\p ciphertext in bytes.\n \\param[out] plaintext          Output buffer for the decrypted data.\n \\param plaintext_size          Size of the \\p plaintext buffer in bytes.\n                                This must be appropriate for the selected\n                                algorithm and key:\n                                - A sufficient output size is\n                                  #PSA_AEAD_DECRYPT_OUTPUT_SIZE(\\c key_type,\n                                  \\p alg, \\p ciphertext_length) where\n                                  \\c key_type is the type of \\p key.\n                                - #PSA_AEAD_DECRYPT_OUTPUT_MAX_SIZE(\\p\n                                  ciphertext_length) evaluates to the maximum\n                                  plaintext size of any supported AEAD\n                                  decryption.\n \\param[out] plaintext_length   On success, the size of the output\n                                in the \\p plaintext buffer.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The ciphertext is not authentic.\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not an AEAD algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         \\p plaintext_size is too small.\n         #PSA_AEAD_DECRYPT_OUTPUT_SIZE(\\c key_type, \\p alg,\n         \\p ciphertext_length) or\n         #PSA_AEAD_DECRYPT_OUTPUT_MAX_SIZE(\\p ciphertext_length) can be used\n         to determine the required buffer size.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_aead_decrypt(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        nonce: *const u8,
        nonce_length: usize,
        additional_data: *const u8,
        additional_data_length: usize,
        ciphertext: *const u8,
        ciphertext_length: usize,
        plaintext: *mut u8,
        plaintext_size: usize,
        plaintext_length: *mut usize,
    ) -> psa_status_t;
}
#[doc = " The type of the state data structure for multipart AEAD operations.\n\n Before calling any function on an AEAD operation object, the application\n must initialize it by any of the following means:\n - Set the structure to all-bits-zero, for example:\n   \\code\n   psa_aead_operation_t operation;\n   memset(&operation, 0, sizeof(operation));\n   \\endcode\n - Initialize the structure to logical zero values, for example:\n   \\code\n   psa_aead_operation_t operation = {0};\n   \\endcode\n - Initialize the structure to the initializer #PSA_AEAD_OPERATION_INIT,\n   for example:\n   \\code\n   psa_aead_operation_t operation = PSA_AEAD_OPERATION_INIT;\n   \\endcode\n - Assign the result of the function psa_aead_operation_init()\n   to the structure, for example:\n   \\code\n   psa_aead_operation_t operation;\n   operation = psa_aead_operation_init();\n   \\endcode\n\n This is an implementation-defined \\c struct. Applications should not\n make any assumptions about the content of this structure.\n Implementation details can change in future versions without notice."]
pub type psa_aead_operation_t = psa_aead_operation_s;
extern "C" {
    #[doc = " Set the key for a multipart authenticated encryption operation.\n\n The sequence of operations to encrypt a message with authentication\n is as follows:\n -# Allocate an operation object which will be passed to all the functions\n    listed here.\n -# Initialize the operation object with one of the methods described in the\n    documentation for #psa_aead_operation_t, e.g.\n    #PSA_AEAD_OPERATION_INIT.\n -# Call psa_aead_encrypt_setup() to specify the algorithm and key.\n -# If needed, call psa_aead_set_lengths() to specify the length of the\n    inputs to the subsequent calls to psa_aead_update_ad() and\n    psa_aead_update(). See the documentation of psa_aead_set_lengths()\n    for details.\n -# Call either psa_aead_generate_nonce() or psa_aead_set_nonce() to\n    generate or set the nonce. You should use\n    psa_aead_generate_nonce() unless the protocol you are implementing\n    requires a specific nonce value.\n -# Call psa_aead_update_ad() zero, one or more times, passing a fragment\n    of the non-encrypted additional authenticated data each time.\n -# Call psa_aead_update() zero, one or more times, passing a fragment\n    of the message to encrypt each time.\n -# Call psa_aead_finish().\n\n If an error occurs at any step after a call to psa_aead_encrypt_setup(),\n the operation will need to be reset by a call to psa_aead_abort(). The\n application may call psa_aead_abort() at any time after the operation\n has been initialized.\n\n After a successful call to psa_aead_encrypt_setup(), the application must\n eventually terminate the operation. The following events terminate an\n operation:\n - A successful call to psa_aead_finish().\n - A call to psa_aead_abort().\n\n \\param[in,out] operation     The operation object to set up. It must have\n                              been initialized as per the documentation for\n                              #psa_aead_operation_t and not yet in use.\n \\param key                   Identifier of the key to use for the operation.\n                              It must remain valid until the operation\n                              terminates. It must allow the usage\n                              #PSA_KEY_USAGE_ENCRYPT.\n \\param alg                   The AEAD algorithm to compute\n                              (\\c PSA_ALG_XXX value such that\n                              #PSA_ALG_IS_AEAD(\\p alg) is true).\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be inactive), or\n         the library has not been previously initialized by psa_crypto_init().\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not an AEAD algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_aead_encrypt_setup(
        operation: *mut psa_aead_operation_t,
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the key for a multipart authenticated decryption operation.\n\n The sequence of operations to decrypt a message with authentication\n is as follows:\n -# Allocate an operation object which will be passed to all the functions\n    listed here.\n -# Initialize the operation object with one of the methods described in the\n    documentation for #psa_aead_operation_t, e.g.\n    #PSA_AEAD_OPERATION_INIT.\n -# Call psa_aead_decrypt_setup() to specify the algorithm and key.\n -# If needed, call psa_aead_set_lengths() to specify the length of the\n    inputs to the subsequent calls to psa_aead_update_ad() and\n    psa_aead_update(). See the documentation of psa_aead_set_lengths()\n    for details.\n -# Call psa_aead_set_nonce() with the nonce for the decryption.\n -# Call psa_aead_update_ad() zero, one or more times, passing a fragment\n    of the non-encrypted additional authenticated data each time.\n -# Call psa_aead_update() zero, one or more times, passing a fragment\n    of the ciphertext to decrypt each time.\n -# Call psa_aead_verify().\n\n If an error occurs at any step after a call to psa_aead_decrypt_setup(),\n the operation will need to be reset by a call to psa_aead_abort(). The\n application may call psa_aead_abort() at any time after the operation\n has been initialized.\n\n After a successful call to psa_aead_decrypt_setup(), the application must\n eventually terminate the operation. The following events terminate an\n operation:\n - A successful call to psa_aead_verify().\n - A call to psa_aead_abort().\n\n \\param[in,out] operation     The operation object to set up. It must have\n                              been initialized as per the documentation for\n                              #psa_aead_operation_t and not yet in use.\n \\param key                   Identifier of the key to use for the operation.\n                              It must remain valid until the operation\n                              terminates. It must allow the usage\n                              #PSA_KEY_USAGE_DECRYPT.\n \\param alg                   The AEAD algorithm to compute\n                              (\\c PSA_ALG_XXX value such that\n                              #PSA_ALG_IS_AEAD(\\p alg) is true).\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not an AEAD algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be inactive), or the\n         library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_aead_decrypt_setup(
        operation: *mut psa_aead_operation_t,
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Generate a random nonce for an authenticated encryption operation.\n\n This function generates a random nonce for the authenticated encryption\n operation with an appropriate size for the chosen algorithm, key type\n and key size.\n\n The application must call psa_aead_encrypt_setup() before\n calling this function.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_aead_abort().\n\n \\param[in,out] operation     Active AEAD operation.\n \\param[out] nonce            Buffer where the generated nonce is to be\n                              written.\n \\param nonce_size            Size of the \\p nonce buffer in bytes.\n \\param[out] nonce_length     On success, the number of bytes of the\n                              generated nonce.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p nonce buffer is too small.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be an active aead encrypt\n         operation, with no nonce set), or the library has not been\n         previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_aead_generate_nonce(
        operation: *mut psa_aead_operation_t,
        nonce: *mut u8,
        nonce_size: usize,
        nonce_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the nonce for an authenticated encryption or decryption operation.\n\n This function sets the nonce for the authenticated\n encryption or decryption operation.\n\n The application must call psa_aead_encrypt_setup() or\n psa_aead_decrypt_setup() before calling this function.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_aead_abort().\n\n \\note When encrypting, applications should use psa_aead_generate_nonce()\n instead of this function, unless implementing a protocol that requires\n a non-random IV.\n\n \\param[in,out] operation     Active AEAD operation.\n \\param[in] nonce             Buffer containing the nonce to use.\n \\param nonce_length          Size of the nonce in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The size of \\p nonce is not acceptable for the chosen algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active, with no nonce\n         set), or the library has not been previously initialized\n         by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_aead_set_nonce(
        operation: *mut psa_aead_operation_t,
        nonce: *const u8,
        nonce_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Declare the lengths of the message and additional data for AEAD.\n\n The application must call this function before calling\n psa_aead_update_ad() or psa_aead_update() if the algorithm for\n the operation requires it. If the algorithm does not require it,\n calling this function is optional, but if this function is called\n then the implementation must enforce the lengths.\n\n You may call this function before or after setting the nonce with\n psa_aead_set_nonce() or psa_aead_generate_nonce().\n\n - For #PSA_ALG_CCM, calling this function is required.\n - For the other AEAD algorithms defined in this specification, calling\n   this function is not required.\n - For vendor-defined algorithm, refer to the vendor documentation.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_aead_abort().\n\n \\param[in,out] operation     Active AEAD operation.\n \\param ad_length             Size of the non-encrypted additional\n                              authenticated data in bytes.\n \\param plaintext_length      Size of the plaintext to encrypt in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         At least one of the lengths is not acceptable for the chosen\n         algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active, and\n         psa_aead_update_ad() and psa_aead_update() must not have been\n         called yet), or the library has not been previously initialized\n         by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_aead_set_lengths(
        operation: *mut psa_aead_operation_t,
        ad_length: usize,
        plaintext_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Pass additional data to an active AEAD operation.\n\n Additional data is authenticated, but not encrypted.\n\n You may call this function multiple times to pass successive fragments\n of the additional data. You may not call this function after passing\n data to encrypt or decrypt with psa_aead_update().\n\n Before calling this function, you must:\n 1. Call either psa_aead_encrypt_setup() or psa_aead_decrypt_setup().\n 2. Set the nonce with psa_aead_generate_nonce() or psa_aead_set_nonce().\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_aead_abort().\n\n \\warning When decrypting, until psa_aead_verify() has returned #PSA_SUCCESS,\n          there is no guarantee that the input is valid. Therefore, until\n          you have called psa_aead_verify() and it has returned #PSA_SUCCESS,\n          treat the input as untrusted and prepare to undo any action that\n          depends on the input if psa_aead_verify() returns an error status.\n\n \\param[in,out] operation     Active AEAD operation.\n \\param[in] input             Buffer containing the fragment of\n                              additional data.\n \\param input_length          Size of the \\p input buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The total input length overflows the additional data length that\n         was previously specified with psa_aead_set_lengths().\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active, have a nonce\n         set, have lengths set if required by the algorithm, and\n         psa_aead_update() must not have been called yet), or the library\n         has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_aead_update_ad(
        operation: *mut psa_aead_operation_t,
        input: *const u8,
        input_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Encrypt or decrypt a message fragment in an active AEAD operation.\n\n Before calling this function, you must:\n 1. Call either psa_aead_encrypt_setup() or psa_aead_decrypt_setup().\n    The choice of setup function determines whether this function\n    encrypts or decrypts its input.\n 2. Set the nonce with psa_aead_generate_nonce() or psa_aead_set_nonce().\n 3. Call psa_aead_update_ad() to pass all the additional data.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_aead_abort().\n\n \\warning When decrypting, until psa_aead_verify() has returned #PSA_SUCCESS,\n          there is no guarantee that the input is valid. Therefore, until\n          you have called psa_aead_verify() and it has returned #PSA_SUCCESS:\n          - Do not use the output in any way other than storing it in a\n            confidential location. If you take any action that depends\n            on the tentative decrypted data, this action will need to be\n            undone if the input turns out not to be valid. Furthermore,\n            if an adversary can observe that this action took place\n            (for example through timing), they may be able to use this\n            fact as an oracle to decrypt any message encrypted with the\n            same key.\n          - In particular, do not copy the output anywhere but to a\n            memory or storage space that you have exclusive access to.\n\n This function does not require the input to be aligned to any\n particular block boundary. If the implementation can only process\n a whole block at a time, it must consume all the input provided, but\n it may delay the end of the corresponding output until a subsequent\n call to psa_aead_update(), psa_aead_finish() or psa_aead_verify()\n provides sufficient input. The amount of data that can be delayed\n in this way is bounded by #PSA_AEAD_UPDATE_OUTPUT_SIZE.\n\n \\param[in,out] operation     Active AEAD operation.\n \\param[in] input             Buffer containing the message fragment to\n                              encrypt or decrypt.\n \\param input_length          Size of the \\p input buffer in bytes.\n \\param[out] output           Buffer where the output is to be written.\n \\param output_size           Size of the \\p output buffer in bytes.\n                              This must be appropriate for the selected\n                                algorithm and key:\n                                - A sufficient output size is\n                                  #PSA_AEAD_UPDATE_OUTPUT_SIZE(\\c key_type,\n                                  \\c alg, \\p input_length) where\n                                  \\c key_type is the type of key and \\c alg is\n                                  the algorithm that were used to set up the\n                                  operation.\n                                - #PSA_AEAD_UPDATE_OUTPUT_MAX_SIZE(\\p\n                                  input_length) evaluates to the maximum\n                                  output size of any supported AEAD\n                                  algorithm.\n \\param[out] output_length    On success, the number of bytes\n                              that make up the returned output.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p output buffer is too small.\n         #PSA_AEAD_UPDATE_OUTPUT_SIZE(\\c key_type, \\c alg, \\p input_length) or\n         #PSA_AEAD_UPDATE_OUTPUT_MAX_SIZE(\\p input_length) can be used to\n         determine the required buffer size.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The total length of input to psa_aead_update_ad() so far is\n         less than the additional data length that was previously\n         specified with psa_aead_set_lengths(), or\n         the total input length overflows the plaintext length that\n         was previously specified with psa_aead_set_lengths().\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active, have a nonce\n         set, and have lengths set if required by the algorithm), or the\n         library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_aead_update(
        operation: *mut psa_aead_operation_t,
        input: *const u8,
        input_length: usize,
        output: *mut u8,
        output_size: usize,
        output_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Finish encrypting a message in an AEAD operation.\n\n The operation must have been set up with psa_aead_encrypt_setup().\n\n This function finishes the authentication of the additional data\n formed by concatenating the inputs passed to preceding calls to\n psa_aead_update_ad() with the plaintext formed by concatenating the\n inputs passed to preceding calls to psa_aead_update().\n\n This function has two output buffers:\n - \\p ciphertext contains trailing ciphertext that was buffered from\n   preceding calls to psa_aead_update().\n - \\p tag contains the authentication tag.\n\n When this function returns successfully, the operation becomes inactive.\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_aead_abort().\n\n \\param[in,out] operation     Active AEAD operation.\n \\param[out] ciphertext       Buffer where the last part of the ciphertext\n                              is to be written.\n \\param ciphertext_size       Size of the \\p ciphertext buffer in bytes.\n                              This must be appropriate for the selected\n                              algorithm and key:\n                              - A sufficient output size is\n                                #PSA_AEAD_FINISH_OUTPUT_SIZE(\\c key_type,\n                                \\c alg) where \\c key_type is the type of key\n                                and \\c alg is the algorithm that were used to\n                                set up the operation.\n                              - #PSA_AEAD_FINISH_OUTPUT_MAX_SIZE evaluates to\n                                the maximum output size of any supported AEAD\n                                algorithm.\n \\param[out] ciphertext_length On success, the number of bytes of\n                              returned ciphertext.\n \\param[out] tag              Buffer where the authentication tag is\n                              to be written.\n \\param tag_size              Size of the \\p tag buffer in bytes.\n                              This must be appropriate for the selected\n                              algorithm and key:\n                              - The exact tag size is #PSA_AEAD_TAG_LENGTH(\\c\n                                key_type, \\c key_bits, \\c alg) where\n                                \\c key_type and \\c key_bits are the type and\n                                bit-size of the key, and \\c alg is the\n                                algorithm that were used in the call to\n                                psa_aead_encrypt_setup().\n                              - #PSA_AEAD_TAG_MAX_SIZE evaluates to the\n                                maximum tag size of any supported AEAD\n                                algorithm.\n \\param[out] tag_length       On success, the number of bytes\n                              that make up the returned tag.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p ciphertext or \\p tag buffer is too small.\n         #PSA_AEAD_FINISH_OUTPUT_SIZE(\\c key_type, \\c alg) or\n         #PSA_AEAD_FINISH_OUTPUT_MAX_SIZE can be used to determine the\n         required \\p ciphertext buffer size. #PSA_AEAD_TAG_LENGTH(\\c key_type,\n         \\c key_bits, \\c alg) or #PSA_AEAD_TAG_MAX_SIZE can be used to\n         determine the required \\p tag buffer size.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The total length of input to psa_aead_update_ad() so far is\n         less than the additional data length that was previously\n         specified with psa_aead_set_lengths(), or\n         the total length of input to psa_aead_update() so far is\n         less than the plaintext length that was previously\n         specified with psa_aead_set_lengths().\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be an active encryption\n         operation with a nonce set), or the library has not been previously\n         initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_aead_finish(
        operation: *mut psa_aead_operation_t,
        ciphertext: *mut u8,
        ciphertext_size: usize,
        ciphertext_length: *mut usize,
        tag: *mut u8,
        tag_size: usize,
        tag_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Finish authenticating and decrypting a message in an AEAD operation.\n\n The operation must have been set up with psa_aead_decrypt_setup().\n\n This function finishes the authenticated decryption of the message\n components:\n\n -  The additional data consisting of the concatenation of the inputs\n    passed to preceding calls to psa_aead_update_ad().\n -  The ciphertext consisting of the concatenation of the inputs passed to\n    preceding calls to psa_aead_update().\n -  The tag passed to this function call.\n\n If the authentication tag is correct, this function outputs any remaining\n plaintext and reports success. If the authentication tag is not correct,\n this function returns #PSA_ERROR_INVALID_SIGNATURE.\n\n When this function returns successfully, the operation becomes inactive.\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_aead_abort().\n\n \\note Implementations shall make the best effort to ensure that the\n comparison between the actual tag and the expected tag is performed\n in constant time.\n\n \\param[in,out] operation     Active AEAD operation.\n \\param[out] plaintext        Buffer where the last part of the plaintext\n                              is to be written. This is the remaining data\n                              from previous calls to psa_aead_update()\n                              that could not be processed until the end\n                              of the input.\n \\param plaintext_size        Size of the \\p plaintext buffer in bytes.\n                              This must be appropriate for the selected algorithm and key:\n                              - A sufficient output size is\n                                #PSA_AEAD_VERIFY_OUTPUT_SIZE(\\c key_type,\n                                \\c alg) where \\c key_type is the type of key\n                                and \\c alg is the algorithm that were used to\n                                set up the operation.\n                              - #PSA_AEAD_VERIFY_OUTPUT_MAX_SIZE evaluates to\n                                the maximum output size of any supported AEAD\n                                algorithm.\n \\param[out] plaintext_length On success, the number of bytes of\n                              returned plaintext.\n \\param[in] tag               Buffer containing the authentication tag.\n \\param tag_length            Size of the \\p tag buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The calculations were successful, but the authentication tag is\n         not correct.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p plaintext buffer is too small.\n         #PSA_AEAD_VERIFY_OUTPUT_SIZE(\\c key_type, \\c alg) or\n         #PSA_AEAD_VERIFY_OUTPUT_MAX_SIZE can be used to determine the\n         required buffer size.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The total length of input to psa_aead_update_ad() so far is\n         less than the additional data length that was previously\n         specified with psa_aead_set_lengths(), or\n         the total length of input to psa_aead_update() so far is\n         less than the plaintext length that was previously\n         specified with psa_aead_set_lengths().\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be an active decryption\n         operation with a nonce set), or the library has not been previously\n         initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_aead_verify(
        operation: *mut psa_aead_operation_t,
        plaintext: *mut u8,
        plaintext_size: usize,
        plaintext_length: *mut usize,
        tag: *const u8,
        tag_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Abort an AEAD operation.\n\n Aborting an operation frees all associated resources except for the\n \\p operation structure itself. Once aborted, the operation object\n can be reused for another operation by calling\n psa_aead_encrypt_setup() or psa_aead_decrypt_setup() again.\n\n You may call this function any time after the operation object has\n been initialized as described in #psa_aead_operation_t.\n\n In particular, calling psa_aead_abort() after the operation has been\n terminated by a call to psa_aead_abort(), psa_aead_finish() or\n psa_aead_verify() is safe and has no effect.\n\n \\param[in,out] operation     Initialized AEAD operation.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_aead_abort(operation: *mut psa_aead_operation_t) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Sign a message with a private key. For hash-and-sign algorithms,\n        this includes the hashing step.\n\n \\note To perform a multi-part hash-and-sign signature algorithm, first use\n       a multi-part hash operation and then pass the resulting hash to\n       psa_sign_hash(). PSA_ALG_GET_HASH(\\p alg) can be used to determine the\n       hash algorithm to use.\n\n \\param[in]  key              Identifier of the key to use for the operation.\n                              It must be an asymmetric key pair. The key must\n                              allow the usage #PSA_KEY_USAGE_SIGN_MESSAGE.\n \\param[in]  alg              An asymmetric signature algorithm (PSA_ALG_XXX\n                              value such that #PSA_ALG_IS_SIGN_MESSAGE(\\p alg)\n                              is true), that is compatible with the type of\n                              \\p key.\n \\param[in]  input            The input message to sign.\n \\param[in]  input_length     Size of the \\p input buffer in bytes.\n \\param[out] signature        Buffer where the signature is to be written.\n \\param[in]  signature_size   Size of the \\p signature buffer in bytes. This\n                              must be appropriate for the selected\n                              algorithm and key:\n                              - The required signature size is\n                                #PSA_SIGN_OUTPUT_SIZE(\\c key_type, \\c key_bits, \\p alg)\n                                where \\c key_type and \\c key_bits are the type and\n                                bit-size respectively of key.\n                              - #PSA_SIGNATURE_MAX_SIZE evaluates to the\n                                maximum signature size of any supported\n                                signature algorithm.\n \\param[out] signature_length On success, the number of bytes that make up\n                              the returned signature value.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The key does not have the #PSA_KEY_USAGE_SIGN_MESSAGE flag,\n         or it does not permit the requested algorithm.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p signature buffer is too small. You can\n         determine a sufficient buffer size by calling\n         #PSA_SIGN_OUTPUT_SIZE(\\c key_type, \\c key_bits, \\p alg)\n         where \\c key_type and \\c key_bits are the type and bit-size\n         respectively of \\p key.\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription\n \\retval #PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_sign_message(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: usize,
        signature: *mut u8,
        signature_size: usize,
        signature_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Verify the signature of a message with a public key, using\n         a hash-and-sign verification algorithm.\n\n \\note To perform a multi-part hash-and-sign signature verification\n       algorithm, first use a multi-part hash operation to hash the message\n       and then pass the resulting hash to psa_verify_hash().\n       PSA_ALG_GET_HASH(\\p alg) can be used to determine the hash algorithm\n       to use.\n\n \\param[in]  key              Identifier of the key to use for the operation.\n                              It must be a public key or an asymmetric key\n                              pair. The key must allow the usage\n                              #PSA_KEY_USAGE_VERIFY_MESSAGE.\n \\param[in]  alg              An asymmetric signature algorithm (PSA_ALG_XXX\n                              value such that #PSA_ALG_IS_SIGN_MESSAGE(\\p alg)\n                              is true), that is compatible with the type of\n                              \\p key.\n \\param[in]  input            The message whose signature is to be verified.\n \\param[in]  input_length     Size of the \\p input buffer in bytes.\n \\param[out] signature        Buffer containing the signature to verify.\n \\param[in]  signature_length Size of the \\p signature buffer in bytes.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The key does not have the #PSA_KEY_USAGE_SIGN_MESSAGE flag,\n         or it does not permit the requested algorithm.\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The calculation was performed successfully, but the passed signature\n         is not a valid signature.\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription\n \\retval #PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_verify_message(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: usize,
        signature: *const u8,
        signature_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Sign a hash or short message with a private key.\n\n Note that to perform a hash-and-sign signature algorithm, you must\n first calculate the hash by calling psa_hash_setup(), psa_hash_update()\n and psa_hash_finish(), or alternatively by calling psa_hash_compute().\n Then pass the resulting hash as the \\p hash\n parameter to this function. You can use #PSA_ALG_SIGN_GET_HASH(\\p alg)\n to determine the hash algorithm to use.\n\n \\param key                   Identifier of the key to use for the operation.\n                              It must be an asymmetric key pair. The key must\n                              allow the usage #PSA_KEY_USAGE_SIGN_HASH.\n \\param alg                   A signature algorithm (PSA_ALG_XXX\n                              value such that #PSA_ALG_IS_SIGN_HASH(\\p alg)\n                              is true), that is compatible with\n                              the type of \\p key.\n \\param[in] hash              The hash or message to sign.\n \\param hash_length           Size of the \\p hash buffer in bytes.\n \\param[out] signature        Buffer where the signature is to be written.\n \\param signature_size        Size of the \\p signature buffer in bytes.\n \\param[out] signature_length On success, the number of bytes\n                              that make up the returned signature value.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p signature buffer is too small. You can\n         determine a sufficient buffer size by calling\n         #PSA_SIGN_OUTPUT_SIZE(\\c key_type, \\c key_bits, \\p alg)\n         where \\c key_type and \\c key_bits are the type and bit-size\n         respectively of \\p key.\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_sign_hash(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        hash: *const u8,
        hash_length: usize,
        signature: *mut u8,
        signature_size: usize,
        signature_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Verify the signature of a hash or short message using a public key.\n\n Note that to perform a hash-and-sign signature algorithm, you must\n first calculate the hash by calling psa_hash_setup(), psa_hash_update()\n and psa_hash_finish(), or alternatively by calling psa_hash_compute().\n Then pass the resulting hash as the \\p hash\n parameter to this function. You can use #PSA_ALG_SIGN_GET_HASH(\\p alg)\n to determine the hash algorithm to use.\n\n \\param key               Identifier of the key to use for the operation. It\n                          must be a public key or an asymmetric key pair. The\n                          key must allow the usage\n                          #PSA_KEY_USAGE_VERIFY_HASH.\n \\param alg               A signature algorithm (PSA_ALG_XXX\n                          value such that #PSA_ALG_IS_SIGN_HASH(\\p alg)\n                          is true), that is compatible with\n                          the type of \\p key.\n \\param[in] hash          The hash or message whose signature is to be\n                          verified.\n \\param hash_length       Size of the \\p hash buffer in bytes.\n \\param[in] signature     Buffer containing the signature to verify.\n \\param signature_length  Size of the \\p signature buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         The signature is valid.\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The calculation was performed successfully, but the passed\n         signature is not a valid signature.\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_verify_hash(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        hash: *const u8,
        hash_length: usize,
        signature: *const u8,
        signature_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Encrypt a short message with a public key.\n\n \\param key                   Identifier of the key to use for the operation.\n                              It must be a public key or an asymmetric key\n                              pair. It must allow the usage\n                              #PSA_KEY_USAGE_ENCRYPT.\n \\param alg                   An asymmetric encryption algorithm that is\n                              compatible with the type of \\p key.\n \\param[in] input             The message to encrypt.\n \\param input_length          Size of the \\p input buffer in bytes.\n \\param[in] salt              A salt or label, if supported by the\n                              encryption algorithm.\n                              If the algorithm does not support a\n                              salt, pass \\c NULL.\n                              If the algorithm supports an optional\n                              salt and you do not want to pass a salt,\n                              pass \\c NULL.\n\n                              - For #PSA_ALG_RSA_PKCS1V15_CRYPT, no salt is\n                                supported.\n \\param salt_length           Size of the \\p salt buffer in bytes.\n                              If \\p salt is \\c NULL, pass 0.\n \\param[out] output           Buffer where the encrypted message is to\n                              be written.\n \\param output_size           Size of the \\p output buffer in bytes.\n \\param[out] output_length    On success, the number of bytes\n                              that make up the returned output.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p output buffer is too small. You can\n         determine a sufficient buffer size by calling\n         #PSA_ASYMMETRIC_ENCRYPT_OUTPUT_SIZE(\\c key_type, \\c key_bits, \\p alg)\n         where \\c key_type and \\c key_bits are the type and bit-size\n         respectively of \\p key.\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_asymmetric_encrypt(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: usize,
        salt: *const u8,
        salt_length: usize,
        output: *mut u8,
        output_size: usize,
        output_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Decrypt a short message with a private key.\n\n \\param key                   Identifier of the key to use for the operation.\n                              It must be an asymmetric key pair. It must\n                              allow the usage #PSA_KEY_USAGE_DECRYPT.\n \\param alg                   An asymmetric encryption algorithm that is\n                              compatible with the type of \\p key.\n \\param[in] input             The message to decrypt.\n \\param input_length          Size of the \\p input buffer in bytes.\n \\param[in] salt              A salt or label, if supported by the\n                              encryption algorithm.\n                              If the algorithm does not support a\n                              salt, pass \\c NULL.\n                              If the algorithm supports an optional\n                              salt and you do not want to pass a salt,\n                              pass \\c NULL.\n\n                              - For #PSA_ALG_RSA_PKCS1V15_CRYPT, no salt is\n                                supported.\n \\param salt_length           Size of the \\p salt buffer in bytes.\n                              If \\p salt is \\c NULL, pass 0.\n \\param[out] output           Buffer where the decrypted message is to\n                              be written.\n \\param output_size           Size of the \\c output buffer in bytes.\n \\param[out] output_length    On success, the number of bytes\n                              that make up the returned output.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p output buffer is too small. You can\n         determine a sufficient buffer size by calling\n         #PSA_ASYMMETRIC_DECRYPT_OUTPUT_SIZE(\\c key_type, \\c key_bits, \\p alg)\n         where \\c key_type and \\c key_bits are the type and bit-size\n         respectively of \\p key.\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription\n \\retval #PSA_ERROR_INVALID_PADDING \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_asymmetric_decrypt(
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        input: *const u8,
        input_length: usize,
        salt: *const u8,
        salt_length: usize,
        output: *mut u8,
        output_size: usize,
        output_length: *mut usize,
    ) -> psa_status_t;
}
#[doc = " The type of the state data structure for key derivation operations.\n\n Before calling any function on a key derivation operation object, the\n application must initialize it by any of the following means:\n - Set the structure to all-bits-zero, for example:\n   \\code\n   psa_key_derivation_operation_t operation;\n   memset(&operation, 0, sizeof(operation));\n   \\endcode\n - Initialize the structure to logical zero values, for example:\n   \\code\n   psa_key_derivation_operation_t operation = {0};\n   \\endcode\n - Initialize the structure to the initializer #PSA_KEY_DERIVATION_OPERATION_INIT,\n   for example:\n   \\code\n   psa_key_derivation_operation_t operation = PSA_KEY_DERIVATION_OPERATION_INIT;\n   \\endcode\n - Assign the result of the function psa_key_derivation_operation_init()\n   to the structure, for example:\n   \\code\n   psa_key_derivation_operation_t operation;\n   operation = psa_key_derivation_operation_init();\n   \\endcode\n\n This is an implementation-defined \\c struct. Applications should not\n make any assumptions about the content of this structure.\n Implementation details can change in future versions without notice."]
pub type psa_key_derivation_operation_t = psa_key_derivation_s;
extern "C" {
    #[doc = " Set up a key derivation operation.\n\n A key derivation algorithm takes some inputs and uses them to generate\n a byte stream in a deterministic way.\n This byte stream can be used to produce keys and other\n cryptographic material.\n\n To derive a key:\n -# Start with an initialized object of type #psa_key_derivation_operation_t.\n -# Call psa_key_derivation_setup() to select the algorithm.\n -# Provide the inputs for the key derivation by calling\n    psa_key_derivation_input_bytes() or psa_key_derivation_input_key()\n    as appropriate. Which inputs are needed, in what order, and whether\n    they may be keys and if so of what type depends on the algorithm.\n -# Optionally set the operation's maximum capacity with\n    psa_key_derivation_set_capacity(). You may do this before, in the middle\n    of or after providing inputs. For some algorithms, this step is mandatory\n    because the output depends on the maximum capacity.\n -# To derive a key, call psa_key_derivation_output_key().\n    To derive a byte string for a different purpose, call\n    psa_key_derivation_output_bytes().\n    Successive calls to these functions use successive output bytes\n    calculated by the key derivation algorithm.\n -# Clean up the key derivation operation object with\n    psa_key_derivation_abort().\n\n If this function returns an error, the key derivation operation object is\n not changed.\n\n If an error occurs at any step after a call to psa_key_derivation_setup(),\n the operation will need to be reset by a call to psa_key_derivation_abort().\n\n Implementations must reject an attempt to derive a key of size 0.\n\n \\param[in,out] operation       The key derivation operation object\n                                to set up. It must\n                                have been initialized but not set up yet.\n \\param alg                     The key derivation algorithm to compute\n                                (\\c PSA_ALG_XXX value such that\n                                #PSA_ALG_IS_KEY_DERIVATION(\\p alg) is true).\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\c alg is not a key derivation algorithm.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\c alg is not supported or is not a key derivation algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be inactive), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_key_derivation_setup(
        operation: *mut psa_key_derivation_operation_t,
        alg: psa_algorithm_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Retrieve the current capacity of a key derivation operation.\n\n The capacity of a key derivation is the maximum number of bytes that it can\n return. When you get *N* bytes of output from a key derivation operation,\n this reduces its capacity by *N*.\n\n \\param[in] operation     The operation to query.\n \\param[out] capacity     On success, the capacity of the operation.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_key_derivation_get_capacity(
        operation: *const psa_key_derivation_operation_t,
        capacity: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the maximum capacity of a key derivation operation.\n\n The capacity of a key derivation operation is the maximum number of bytes\n that the key derivation operation can return from this point onwards.\n\n \\param[in,out] operation The key derivation operation object to modify.\n \\param capacity          The new capacity of the operation.\n                          It must be less or equal to the operation's\n                          current capacity.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p capacity is larger than the operation's current capacity.\n         In this case, the operation object remains valid and its capacity\n         remains unchanged.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active), or the\n         library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_key_derivation_set_capacity(
        operation: *mut psa_key_derivation_operation_t,
        capacity: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Provide an input for key derivation or key agreement.\n\n Which inputs are required and in what order depends on the algorithm.\n Refer to the documentation of each key derivation or key agreement\n algorithm for information.\n\n This function passes direct inputs, which is usually correct for\n non-secret inputs. To pass a secret input, which should be in a key\n object, call psa_key_derivation_input_key() instead of this function.\n Refer to the documentation of individual step types\n (`PSA_KEY_DERIVATION_INPUT_xxx` values of type ::psa_key_derivation_step_t)\n for more information.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_key_derivation_abort().\n\n \\param[in,out] operation       The key derivation operation object to use.\n                                It must have been set up with\n                                psa_key_derivation_setup() and must not\n                                have produced any output yet.\n \\param step                    Which step the input data is for.\n \\param[in] data                Input data to use.\n \\param data_length             Size of the \\p data buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\c step is not compatible with the operation's algorithm, or\n         \\c step does not allow direct inputs.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid for this input \\p step, or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_key_derivation_input_bytes(
        operation: *mut psa_key_derivation_operation_t,
        step: psa_key_derivation_step_t,
        data: *const u8,
        data_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Provide a numeric input for key derivation or key agreement.\n\n Which inputs are required and in what order depends on the algorithm.\n However, when an algorithm requires a particular order, numeric inputs\n usually come first as they tend to be configuration parameters.\n Refer to the documentation of each key derivation or key agreement\n algorithm for information.\n\n This function is used for inputs which are fixed-size non-negative\n integers.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_key_derivation_abort().\n\n \\param[in,out] operation       The key derivation operation object to use.\n                                It must have been set up with\n                                psa_key_derivation_setup() and must not\n                                have produced any output yet.\n \\param step                    Which step the input data is for.\n \\param[in] value               The value of the numeric input.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\c step is not compatible with the operation's algorithm, or\n         \\c step does not allow numeric inputs.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid for this input \\p step, or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_key_derivation_input_integer(
        operation: *mut psa_key_derivation_operation_t,
        step: psa_key_derivation_step_t,
        value: u64,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Provide an input for key derivation in the form of a key.\n\n Which inputs are required and in what order depends on the algorithm.\n Refer to the documentation of each key derivation or key agreement\n algorithm for information.\n\n This function obtains input from a key object, which is usually correct for\n secret inputs or for non-secret personalization strings kept in the key\n store. To pass a non-secret parameter which is not in the key store,\n call psa_key_derivation_input_bytes() instead of this function.\n Refer to the documentation of individual step types\n (`PSA_KEY_DERIVATION_INPUT_xxx` values of type ::psa_key_derivation_step_t)\n for more information.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_key_derivation_abort().\n\n \\param[in,out] operation       The key derivation operation object to use.\n                                It must have been set up with\n                                psa_key_derivation_setup() and must not\n                                have produced any output yet.\n \\param step                    Which step the input data is for.\n \\param key                     Identifier of the key. It must have an\n                                appropriate type for step and must allow the\n                                usage #PSA_KEY_USAGE_DERIVE or\n                                #PSA_KEY_USAGE_VERIFY_DERIVATION (see note)\n                                and the algorithm used by the operation.\n\n \\note Once all inputs steps are completed, the operations will allow:\n - psa_key_derivation_output_bytes() if each input was either a direct input\n   or  a key with #PSA_KEY_USAGE_DERIVE set;\n - psa_key_derivation_output_key() if the input for step\n   #PSA_KEY_DERIVATION_INPUT_SECRET or #PSA_KEY_DERIVATION_INPUT_PASSWORD\n   was from a key slot with #PSA_KEY_USAGE_DERIVE and each other input was\n   either a direct input or a key with #PSA_KEY_USAGE_DERIVE set;\n - psa_key_derivation_verify_bytes() if each input was either a direct input\n   or  a key with #PSA_KEY_USAGE_VERIFY_DERIVATION set;\n - psa_key_derivation_verify_key() under the same conditions as\n   psa_key_derivation_verify_bytes().\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The key allows neither #PSA_KEY_USAGE_DERIVE nor\n         #PSA_KEY_USAGE_VERIFY_DERIVATION, or it doesn't allow this\n         algorithm.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\c step is not compatible with the operation's algorithm, or\n         \\c step does not allow key inputs of the given type\n         or does not allow key inputs at all.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid for this input \\p step, or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_key_derivation_input_key(
        operation: *mut psa_key_derivation_operation_t,
        step: psa_key_derivation_step_t,
        key: mbedtls_svc_key_id_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Perform a key agreement and use the shared secret as input to a key\n derivation.\n\n A key agreement algorithm takes two inputs: a private key \\p private_key\n a public key \\p peer_key.\n The result of this function is passed as input to a key derivation.\n The output of this key derivation can be extracted by reading from the\n resulting operation to produce keys and other cryptographic material.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_key_derivation_abort().\n\n \\param[in,out] operation       The key derivation operation object to use.\n                                It must have been set up with\n                                psa_key_derivation_setup() with a\n                                key agreement and derivation algorithm\n                                \\c alg (\\c PSA_ALG_XXX value such that\n                                #PSA_ALG_IS_KEY_AGREEMENT(\\c alg) is true\n                                and #PSA_ALG_IS_RAW_KEY_AGREEMENT(\\c alg)\n                                is false).\n                                The operation must be ready for an\n                                input of the type given by \\p step.\n \\param step                    Which step the input data is for.\n \\param private_key             Identifier of the private key to use. It must\n                                allow the usage #PSA_KEY_USAGE_DERIVE.\n \\param[in] peer_key      Public key of the peer. The peer key must be in the\n                          same format that psa_import_key() accepts for the\n                          public key type corresponding to the type of\n                          private_key. That is, this function performs the\n                          equivalent of\n                          #psa_import_key(...,\n                          `peer_key`, `peer_key_length`) where\n                          with key attributes indicating the public key\n                          type corresponding to the type of `private_key`.\n                          For example, for EC keys, this means that peer_key\n                          is interpreted as a point on the curve that the\n                          private key is on. The standard formats for public\n                          keys are documented in the documentation of\n                          psa_export_public_key().\n \\param peer_key_length         Size of \\p peer_key in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\c private_key is not compatible with \\c alg,\n         or \\p peer_key is not valid for \\c alg or not compatible with\n         \\c private_key, or \\c step does not allow an input resulting\n         from a key agreement.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\c alg is not supported or is not a key derivation algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid for this key agreement \\p step,\n         or the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_key_derivation_key_agreement(
        operation: *mut psa_key_derivation_operation_t,
        step: psa_key_derivation_step_t,
        private_key: mbedtls_svc_key_id_t,
        peer_key: *const u8,
        peer_key_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Read some data from a key derivation operation.\n\n This function calculates output bytes from a key derivation algorithm and\n return those bytes.\n If you view the key derivation's output as a stream of bytes, this\n function destructively reads the requested number of bytes from the\n stream.\n The operation's capacity decreases by the number of bytes read.\n\n If this function returns an error status other than\n #PSA_ERROR_INSUFFICIENT_DATA, the operation enters an error\n state and must be aborted by calling psa_key_derivation_abort().\n\n \\param[in,out] operation The key derivation operation object to read from.\n \\param[out] output       Buffer where the output will be written.\n \\param output_length     Number of bytes to output.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED\n         One of the inputs was a key whose policy didn't allow\n         #PSA_KEY_USAGE_DERIVE.\n \\retval #PSA_ERROR_INSUFFICIENT_DATA\n                          The operation's capacity was less than\n                          \\p output_length bytes. Note that in this case,\n                          no output is written to the output buffer.\n                          The operation's capacity is set to 0, thus\n                          subsequent calls to this function will not\n                          succeed, even with a smaller output buffer.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active and completed\n         all required input steps), or the library has not been previously\n         initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_key_derivation_output_bytes(
        operation: *mut psa_key_derivation_operation_t,
        output: *mut u8,
        output_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Derive a key from an ongoing key derivation operation.\n\n This function calculates output bytes from a key derivation algorithm\n and uses those bytes to generate a key deterministically.\n The key's location, usage policy, type and size are taken from\n \\p attributes.\n\n If you view the key derivation's output as a stream of bytes, this\n function destructively reads as many bytes as required from the\n stream.\n The operation's capacity decreases by the number of bytes read.\n\n If this function returns an error status other than\n #PSA_ERROR_INSUFFICIENT_DATA, the operation enters an error\n state and must be aborted by calling psa_key_derivation_abort().\n\n How much output is produced and consumed from the operation, and how\n the key is derived, depends on the key type and on the key size\n (denoted \\c bits below):\n\n - For key types for which the key is an arbitrary sequence of bytes\n   of a given size, this function is functionally equivalent to\n   calling #psa_key_derivation_output_bytes\n   and passing the resulting output to #psa_import_key.\n   However, this function has a security benefit:\n   if the implementation provides an isolation boundary then\n   the key material is not exposed outside the isolation boundary.\n   As a consequence, for these key types, this function always consumes\n   exactly (\\c bits / 8) bytes from the operation.\n   The following key types defined in this specification follow this scheme:\n\n     - #PSA_KEY_TYPE_AES;\n     - #PSA_KEY_TYPE_ARIA;\n     - #PSA_KEY_TYPE_CAMELLIA;\n     - #PSA_KEY_TYPE_DERIVE;\n     - #PSA_KEY_TYPE_HMAC;\n     - #PSA_KEY_TYPE_PASSWORD_HASH.\n\n - For ECC keys on a Montgomery elliptic curve\n   (#PSA_KEY_TYPE_ECC_KEY_PAIR(\\c curve) where \\c curve designates a\n   Montgomery curve), this function always draws a byte string whose\n   length is determined by the curve, and sets the mandatory bits\n   accordingly. That is:\n\n     - Curve25519 (#PSA_ECC_FAMILY_MONTGOMERY, 255 bits): draw a 32-byte\n       string and process it as specified in RFC 7748 &sect;5.\n     - Curve448 (#PSA_ECC_FAMILY_MONTGOMERY, 448 bits): draw a 56-byte\n       string and process it as specified in RFC 7748 &sect;5.\n\n - For key types for which the key is represented by a single sequence of\n   \\c bits bits with constraints as to which bit sequences are acceptable,\n   this function draws a byte string of length (\\c bits / 8) bytes rounded\n   up to the nearest whole number of bytes. If the resulting byte string\n   is acceptable, it becomes the key, otherwise the drawn bytes are discarded.\n   This process is repeated until an acceptable byte string is drawn.\n   The byte string drawn from the operation is interpreted as specified\n   for the output produced by psa_export_key().\n   The following key types defined in this specification follow this scheme:\n\n     - #PSA_KEY_TYPE_DES.\n       Force-set the parity bits, but discard forbidden weak keys.\n       For 2-key and 3-key triple-DES, the three keys are generated\n       successively (for example, for 3-key triple-DES,\n       if the first 8 bytes specify a weak key and the next 8 bytes do not,\n       discard the first 8 bytes, use the next 8 bytes as the first key,\n       and continue reading output from the operation to derive the other\n       two keys).\n     - Finite-field Diffie-Hellman keys (#PSA_KEY_TYPE_DH_KEY_PAIR(\\c group)\n       where \\c group designates any Diffie-Hellman group) and\n       ECC keys on a Weierstrass elliptic curve\n       (#PSA_KEY_TYPE_ECC_KEY_PAIR(\\c curve) where \\c curve designates a\n       Weierstrass curve).\n       For these key types, interpret the byte string as integer\n       in big-endian order. Discard it if it is not in the range\n       [0, *N* - 2] where *N* is the boundary of the private key domain\n       (the prime *p* for Diffie-Hellman, the subprime *q* for DSA,\n       or the order of the curve's base point for ECC).\n       Add 1 to the resulting integer and use this as the private key *x*.\n       This method allows compliance to NIST standards, specifically\n       the methods titled \"key-pair generation by testing candidates\"\n       in NIST SP 800-56A &sect;5.6.1.1.4 for Diffie-Hellman,\n       in FIPS 186-4 &sect;B.1.2 for DSA, and\n       in NIST SP 800-56A &sect;5.6.1.2.2 or\n       FIPS 186-4 &sect;B.4.2 for elliptic curve keys.\n\n - For other key types, including #PSA_KEY_TYPE_RSA_KEY_PAIR,\n   the way in which the operation output is consumed is\n   implementation-defined.\n\n In all cases, the data that is read is discarded from the operation.\n The operation's capacity is decreased by the number of bytes read.\n\n For algorithms that take an input step #PSA_KEY_DERIVATION_INPUT_SECRET,\n the input to that step must be provided with psa_key_derivation_input_key().\n Future versions of this specification may include additional restrictions\n on the derived key based on the attributes and strength of the secret key.\n\n \\param[in] attributes    The attributes for the new key.\n                          If the key type to be created is\n                          #PSA_KEY_TYPE_PASSWORD_HASH then the algorithm in\n                          the policy must be the same as in the current\n                          operation.\n \\param[in,out] operation The key derivation operation object to read from.\n \\param[out] key          On success, an identifier for the newly created\n                          key. For persistent keys, this is the key\n                          identifier defined in \\p attributes.\n                          \\c 0 on failure.\n\n \\retval #PSA_SUCCESS\n         Success.\n         If the key is persistent, the key material and the key's metadata\n         have been saved to persistent storage.\n \\retval #PSA_ERROR_ALREADY_EXISTS\n         This is an attempt to create a persistent key, and there is\n         already a persistent key with the given identifier.\n \\retval #PSA_ERROR_INSUFFICIENT_DATA\n         There was not enough data to create the desired key.\n         Note that in this case, no output is written to the output buffer.\n         The operation's capacity is set to 0, thus subsequent calls to\n         this function will not succeed, even with a smaller output buffer.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         The key type or key size is not supported, either by the\n         implementation in general or in this particular location.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The provided key attributes are not valid for the operation.\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The #PSA_KEY_DERIVATION_INPUT_SECRET or\n         #PSA_KEY_DERIVATION_INPUT_PASSWORD input was not provided through a\n         key; or one of the inputs was a key whose policy didn't allow\n         #PSA_KEY_USAGE_DERIVE.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_STORAGE \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active and completed\n         all required input steps), or the library has not been previously\n         initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_key_derivation_output_key(
        attributes: *const psa_key_attributes_t,
        operation: *mut psa_key_derivation_operation_t,
        key: *mut mbedtls_svc_key_id_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Compare output data from a key derivation operation to an expected value.\n\n This function calculates output bytes from a key derivation algorithm and\n compares those bytes to an expected value in constant time.\n If you view the key derivation's output as a stream of bytes, this\n function destructively reads the expected number of bytes from the\n stream before comparing them.\n The operation's capacity decreases by the number of bytes read.\n\n This is functionally equivalent to the following code:\n \\code\n psa_key_derivation_output_bytes(operation, tmp, output_length);\n if (memcmp(output, tmp, output_length) != 0)\n     return PSA_ERROR_INVALID_SIGNATURE;\n \\endcode\n except (1) it works even if the key's policy does not allow outputting the\n bytes, and (2) the comparison will be done in constant time.\n\n If this function returns an error status other than\n #PSA_ERROR_INSUFFICIENT_DATA or #PSA_ERROR_INVALID_SIGNATURE,\n the operation enters an error state and must be aborted by calling\n psa_key_derivation_abort().\n\n \\param[in,out] operation The key derivation operation object to read from.\n \\param[in] expected_output Buffer containing the expected derivation output.\n \\param output_length     Length of the expected output; this is also the\n                          number of bytes that will be read.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The output was read successfully, but it differs from the expected\n         output.\n \\retval #PSA_ERROR_NOT_PERMITTED\n         One of the inputs was a key whose policy didn't allow\n         #PSA_KEY_USAGE_VERIFY_DERIVATION.\n \\retval #PSA_ERROR_INSUFFICIENT_DATA\n                          The operation's capacity was less than\n                          \\p output_length bytes. Note that in this case,\n                          the operation's capacity is set to 0, thus\n                          subsequent calls to this function will not\n                          succeed, even with a smaller expected output.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active and completed\n         all required input steps), or the library has not been previously\n         initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_key_derivation_verify_bytes(
        operation: *mut psa_key_derivation_operation_t,
        expected_output: *const u8,
        output_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Compare output data from a key derivation operation to an expected value\n stored in a key object.\n\n This function calculates output bytes from a key derivation algorithm and\n compares those bytes to an expected value, provided as key of type\n #PSA_KEY_TYPE_PASSWORD_HASH.\n If you view the key derivation's output as a stream of bytes, this\n function destructively reads the number of bytes corresponding to the\n length of the expected value from the stream before comparing them.\n The operation's capacity decreases by the number of bytes read.\n\n This is functionally equivalent to exporting the key and calling\n psa_key_derivation_verify_bytes() on the result, except that it\n works even if the key cannot be exported.\n\n If this function returns an error status other than\n #PSA_ERROR_INSUFFICIENT_DATA or #PSA_ERROR_INVALID_SIGNATURE,\n the operation enters an error state and must be aborted by calling\n psa_key_derivation_abort().\n\n \\param[in,out] operation The key derivation operation object to read from.\n \\param[in] expected      A key of type #PSA_KEY_TYPE_PASSWORD_HASH\n                          containing the expected output. Its policy must\n                          include the #PSA_KEY_USAGE_VERIFY_DERIVATION flag\n                          and the permitted algorithm must match the\n                          operation. The value of this key was likely\n                          computed by a previous call to\n                          psa_key_derivation_output_key().\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The output was read successfully, but if differs from the expected\n         output.\n \\retval #PSA_ERROR_INVALID_HANDLE\n         The key passed as the expected value does not exist.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The key passed as the expected value has an invalid type.\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The key passed as the expected value does not allow this usage or\n         this algorithm; or one of the inputs was a key whose policy didn't\n         allow #PSA_KEY_USAGE_VERIFY_DERIVATION.\n \\retval #PSA_ERROR_INSUFFICIENT_DATA\n                          The operation's capacity was less than\n                          the length of the expected value. In this case,\n                          the operation's capacity is set to 0, thus\n                          subsequent calls to this function will not\n                          succeed, even with a smaller expected output.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active and completed\n         all required input steps), or the library has not been previously\n         initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_key_derivation_verify_key(
        operation: *mut psa_key_derivation_operation_t,
        expected: psa_key_id_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Abort a key derivation operation.\n\n Aborting an operation frees all associated resources except for the \\c\n operation structure itself. Once aborted, the operation object can be reused\n for another operation by calling psa_key_derivation_setup() again.\n\n This function may be called at any time after the operation\n object has been initialized as described in #psa_key_derivation_operation_t.\n\n In particular, it is valid to call psa_key_derivation_abort() twice, or to\n call psa_key_derivation_abort() on an operation that has not been set up.\n\n \\param[in,out] operation    The operation to abort.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_key_derivation_abort(operation: *mut psa_key_derivation_operation_t)
        -> psa_status_t;
}
extern "C" {
    #[doc = " Perform a key agreement and return the raw shared secret.\n\n \\warning The raw result of a key agreement algorithm such as finite-field\n Diffie-Hellman or elliptic curve Diffie-Hellman has biases and should\n not be used directly as key material. It should instead be passed as\n input to a key derivation algorithm. To chain a key agreement with\n a key derivation, use psa_key_derivation_key_agreement() and other\n functions from the key derivation interface.\n\n \\param alg                     The key agreement algorithm to compute\n                                (\\c PSA_ALG_XXX value such that\n                                #PSA_ALG_IS_RAW_KEY_AGREEMENT(\\p alg)\n                                is true).\n \\param private_key             Identifier of the private key to use. It must\n                                allow the usage #PSA_KEY_USAGE_DERIVE.\n \\param[in] peer_key            Public key of the peer. It must be\n                                in the same format that psa_import_key()\n                                accepts. The standard formats for public\n                                keys are documented in the documentation\n                                of psa_export_public_key().\n \\param peer_key_length         Size of \\p peer_key in bytes.\n \\param[out] output             Buffer where the decrypted message is to\n                                be written.\n \\param output_size             Size of the \\c output buffer in bytes.\n \\param[out] output_length      On success, the number of bytes\n                                that make up the returned output.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p alg is not a key agreement algorithm, or\n         \\p private_key is not compatible with \\p alg,\n         or \\p peer_key is not valid for \\p alg or not compatible with\n         \\p private_key.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         \\p output_size is too small\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not a supported key agreement algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_raw_key_agreement(
        alg: psa_algorithm_t,
        private_key: mbedtls_svc_key_id_t,
        peer_key: *const u8,
        peer_key_length: usize,
        output: *mut u8,
        output_size: usize,
        output_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Generate random bytes.\n\n \\warning This function **can** fail! Callers MUST check the return status\n          and MUST NOT use the content of the output buffer if the return\n          status is not #PSA_SUCCESS.\n\n \\note    To generate a key, use psa_generate_key() instead.\n\n \\param[out] output       Output buffer for the generated data.\n \\param output_size       Number of bytes to generate and output.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_generate_random(output: *mut u8, output_size: usize) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Generate a key or key pair.\n\n The key is generated randomly.\n Its location, usage policy, type and size are taken from \\p attributes.\n\n Implementations must reject an attempt to generate a key of size 0.\n\n The following type-specific considerations apply:\n - For RSA keys (#PSA_KEY_TYPE_RSA_KEY_PAIR),\n   the public exponent is 65537.\n   The modulus is a product of two probabilistic primes\n   between 2^{n-1} and 2^n where n is the bit size specified in the\n   attributes.\n\n \\param[in] attributes    The attributes for the new key.\n \\param[out] key          On success, an identifier for the newly created\n                          key. For persistent keys, this is the key\n                          identifier defined in \\p attributes.\n                          \\c 0 on failure.\n\n \\retval #PSA_SUCCESS\n         Success.\n         If the key is persistent, the key material and the key's metadata\n         have been saved to persistent storage.\n \\retval #PSA_ERROR_ALREADY_EXISTS\n         This is an attempt to create a persistent key, and there is\n         already a persistent key with the given identifier.\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_STORAGE \\emptydescription\n \\retval #PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_generate_key(
        attributes: *const psa_key_attributes_t,
        key: *mut mbedtls_svc_key_id_t,
    ) -> psa_status_t;
}
#[doc = " The type of the state data structure for interruptible hash\n  signing operations.\n\n Before calling any function on a sign hash operation object, the\n application must initialize it by any of the following means:\n - Set the structure to all-bits-zero, for example:\n   \\code\n   psa_sign_hash_interruptible_operation_t operation;\n   memset(&operation, 0, sizeof(operation));\n   \\endcode\n - Initialize the structure to logical zero values, for example:\n   \\code\n   psa_sign_hash_interruptible_operation_t operation = {0};\n   \\endcode\n - Initialize the structure to the initializer\n   #PSA_SIGN_HASH_INTERRUPTIBLE_OPERATION_INIT, for example:\n   \\code\n   psa_sign_hash_interruptible_operation_t operation =\n   PSA_SIGN_HASH_INTERRUPTIBLE_OPERATION_INIT;\n   \\endcode\n - Assign the result of the function\n   psa_sign_hash_interruptible_operation_init() to the structure, for\n   example:\n   \\code\n   psa_sign_hash_interruptible_operation_t operation;\n   operation = psa_sign_hash_interruptible_operation_init();\n   \\endcode\n\n This is an implementation-defined \\c struct. Applications should not\n make any assumptions about the content of this structure.\n Implementation details can change in future versions without notice."]
pub type psa_sign_hash_interruptible_operation_t = psa_sign_hash_interruptible_operation_s;
#[doc = " The type of the state data structure for interruptible hash\n  verification operations.\n\n Before calling any function on a sign hash operation object, the\n application must initialize it by any of the following means:\n - Set the structure to all-bits-zero, for example:\n   \\code\n   psa_verify_hash_interruptible_operation_t operation;\n   memset(&operation, 0, sizeof(operation));\n   \\endcode\n - Initialize the structure to logical zero values, for example:\n   \\code\n   psa_verify_hash_interruptible_operation_t operation = {0};\n   \\endcode\n - Initialize the structure to the initializer\n   #PSA_VERIFY_HASH_INTERRUPTIBLE_OPERATION_INIT, for example:\n   \\code\n   psa_verify_hash_interruptible_operation_t operation =\n   PSA_VERIFY_HASH_INTERRUPTIBLE_OPERATION_INIT;\n   \\endcode\n - Assign the result of the function\n   psa_verify_hash_interruptible_operation_init() to the structure, for\n   example:\n   \\code\n   psa_verify_hash_interruptible_operation_t operation;\n   operation = psa_verify_hash_interruptible_operation_init();\n   \\endcode\n\n This is an implementation-defined \\c struct. Applications should not\n make any assumptions about the content of this structure.\n Implementation details can change in future versions without notice."]
pub type psa_verify_hash_interruptible_operation_t = psa_verify_hash_interruptible_operation_s;
extern "C" {
    #[doc = " \\brief                       Set the maximum number of ops allowed to be\n                              executed by an interruptible function in a\n                              single call.\n\n \\warning                     This is a beta API, and thus subject to change\n                              at any point. It is not bound by the usual\n                              interface stability promises.\n\n \\note                        The time taken to execute a single op is\n                              implementation specific and depends on\n                              software, hardware, the algorithm, key type and\n                              curve chosen. Even within a single operation,\n                              successive ops can take differing amounts of\n                              time. The only guarantee is that lower values\n                              for \\p max_ops means functions will block for a\n                              lesser maximum amount of time. The functions\n                              \\c psa_sign_interruptible_get_num_ops() and\n                              \\c psa_verify_interruptible_get_num_ops() are\n                              provided to help with tuning this value.\n\n \\note                        This value defaults to\n                              #PSA_INTERRUPTIBLE_MAX_OPS_UNLIMITED, which\n                              means the whole operation will be done in one\n                              go, regardless of the number of ops required.\n\n \\note                        If more ops are needed to complete a\n                              computation, #PSA_OPERATION_INCOMPLETE will be\n                              returned by the function performing the\n                              computation. It is then the caller's\n                              responsibility to either call again with the\n                              same operation context until it returns 0 or an\n                              error code; or to call the relevant abort\n                              function if the answer is no longer required.\n\n \\note                        The interpretation of \\p max_ops is also\n                              implementation defined. On a hard real time\n                              system, this can indicate a hard deadline, as a\n                              real-time system needs a guarantee of not\n                              spending more than X time, however care must be\n                              taken in such an implementation to avoid the\n                              situation whereby calls just return, not being\n                              able to do any actual work within the allotted\n                              time.  On a non-real-time system, the\n                              implementation can be more relaxed, but again\n                              whether this number should be interpreted as as\n                              hard or soft limit or even whether a less than\n                              or equals as regards to ops executed in a\n                              single call is implementation defined.\n\n \\note                        For keys in local storage when no accelerator\n                              driver applies, please see also the\n                              documentation for \\c mbedtls_ecp_set_max_ops(),\n                              which is the internal implementation in these\n                              cases.\n\n \\warning                     With implementations that interpret this number\n                              as a hard limit, setting this number too small\n                              may result in an infinite loop, whereby each\n                              call results in immediate return with no ops\n                              done (as there is not enough time to execute\n                              any), and thus no result will ever be achieved.\n\n \\note                        This only applies to functions whose\n                              documentation mentions they may return\n                              #PSA_OPERATION_INCOMPLETE.\n\n \\param max_ops               The maximum number of ops to be executed in a\n                              single call. This can be a number from 0 to\n                              #PSA_INTERRUPTIBLE_MAX_OPS_UNLIMITED, where 0\n                              is the least amount of work done per call."]
    pub fn psa_interruptible_set_max_ops(max_ops: u32);
}
extern "C" {
    #[doc = " \\brief                       Get the maximum number of ops allowed to be\n                              executed by an interruptible function in a\n                              single call. This will return the last\n                              value set by\n                              \\c psa_interruptible_set_max_ops() or\n                              #PSA_INTERRUPTIBLE_MAX_OPS_UNLIMITED if\n                              that function has never been called.\n\n \\warning                     This is a beta API, and thus subject to change\n                              at any point. It is not bound by the usual\n                              interface stability promises.\n\n \\return                      Maximum number of ops allowed to be\n                              executed by an interruptible function in a\n                              single call."]
    pub fn psa_interruptible_get_max_ops() -> u32;
}
extern "C" {
    #[doc = " \\brief                       Get the number of ops that a hash signing\n                              operation has taken so far. If the operation\n                              has completed, then this will represent the\n                              number of ops required for the entire\n                              operation. After initialization or calling\n                              \\c psa_sign_hash_interruptible_abort() on\n                              the operation, a value of 0 will be returned.\n\n \\note                        This interface is guaranteed re-entrant and\n                              thus may be called from driver code.\n\n \\warning                     This is a beta API, and thus subject to change\n                              at any point. It is not bound by the usual\n                              interface stability promises.\n\n                              This is a helper provided to help you tune the\n                              value passed to \\c\n                              psa_interruptible_set_max_ops().\n\n \\param operation             The \\c psa_sign_hash_interruptible_operation_t\n                              to use. This must be initialized first.\n\n \\return                      Number of ops that the operation has taken so\n                              far."]
    pub fn psa_sign_hash_get_num_ops(
        operation: *const psa_sign_hash_interruptible_operation_t,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief                       Get the number of ops that a hash verification\n                              operation has taken so far. If the operation\n                              has completed, then this will represent the\n                              number of ops required for the entire\n                              operation. After initialization or calling \\c\n                              psa_verify_hash_interruptible_abort() on the\n                              operation, a value of 0 will be returned.\n\n \\warning                     This is a beta API, and thus subject to change\n                              at any point. It is not bound by the usual\n                              interface stability promises.\n\n                              This is a helper provided to help you tune the\n                              value passed to \\c\n                              psa_interruptible_set_max_ops().\n\n \\param operation             The \\c\n                              psa_verify_hash_interruptible_operation_t to\n                              use. This must be initialized first.\n\n \\return                      Number of ops that the operation has taken so\n                              far."]
    pub fn psa_verify_hash_get_num_ops(
        operation: *const psa_verify_hash_interruptible_operation_t,
    ) -> u32;
}
extern "C" {
    #[doc = " \\brief                       Start signing a hash or short message with a\n                              private key, in an interruptible manner.\n\n \\see                         \\c psa_sign_hash_complete()\n\n \\warning                     This is a beta API, and thus subject to change\n                              at any point. It is not bound by the usual\n                              interface stability promises.\n\n \\note                        This function combined with \\c\n                              psa_sign_hash_complete() is equivalent to\n                              \\c psa_sign_hash() but\n                              \\c psa_sign_hash_complete() can return early and\n                              resume according to the limit set with \\c\n                              psa_interruptible_set_max_ops() to reduce the\n                              maximum time spent in a function call.\n\n \\note                        Users should call \\c psa_sign_hash_complete()\n                              repeatedly on the same context after a\n                              successful call to this function until \\c\n                              psa_sign_hash_complete() either returns 0 or an\n                              error. \\c psa_sign_hash_complete() will return\n                              #PSA_OPERATION_INCOMPLETE if there is more work\n                              to do. Alternatively users can call\n                              \\c psa_sign_hash_abort() at any point if they no\n                              longer want the result.\n\n \\note                        If this function returns an error status, the\n                              operation enters an error state and must be\n                              aborted by calling \\c psa_sign_hash_abort().\n\n \\param[in, out] operation    The \\c psa_sign_hash_interruptible_operation_t\n                              to use. This must be initialized first.\n\n \\param key                   Identifier of the key to use for the operation.\n                              It must be an asymmetric key pair. The key must\n                              allow the usage #PSA_KEY_USAGE_SIGN_HASH.\n \\param alg                   A signature algorithm (\\c PSA_ALG_XXX\n                              value such that #PSA_ALG_IS_SIGN_HASH(\\p alg)\n                              is true), that is compatible with\n                              the type of \\p key.\n \\param[in] hash              The hash or message to sign.\n \\param hash_length           Size of the \\p hash buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         The operation started successfully - call \\c psa_sign_hash_complete()\n         with the same context to complete the operation\n\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The key does not have the #PSA_KEY_USAGE_SIGN_HASH flag, or it does\n         not permit the requested algorithm.\n \\retval #PSA_ERROR_BAD_STATE\n         An operation has previously been started on this context, and is\n         still in progress.\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription\n \\retval #PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_sign_hash_start(
        operation: *mut psa_sign_hash_interruptible_operation_t,
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        hash: *const u8,
        hash_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief                       Continue and eventually complete the action of\n                              signing a hash or short message with a private\n                              key, in an interruptible manner.\n\n \\see                         \\c psa_sign_hash_start()\n\n \\warning                     This is a beta API, and thus subject to change\n                              at any point. It is not bound by the usual\n                              interface stability promises.\n\n \\note                        This function combined with \\c\n                              psa_sign_hash_start() is equivalent to\n                              \\c psa_sign_hash() but this function can return\n                              early and resume according to the limit set with\n                              \\c psa_interruptible_set_max_ops() to reduce the\n                              maximum time spent in a function call.\n\n \\note                        Users should call this function on the same\n                              operation object repeatedly until it either\n                              returns 0 or an error. This function will return\n                              #PSA_OPERATION_INCOMPLETE if there is more work\n                              to do. Alternatively users can call\n                              \\c psa_sign_hash_abort() at any point if they no\n                              longer want the result.\n\n \\note                        When this function returns successfully, the\n                              operation becomes inactive. If this function\n                              returns an error status, the operation enters an\n                              error state and must be aborted by calling\n                              \\c psa_sign_hash_abort().\n\n \\param[in, out] operation    The \\c psa_sign_hash_interruptible_operation_t\n                              to use. This must be initialized first, and have\n                              had \\c psa_sign_hash_start() called with it\n                              first.\n\n \\param[out] signature        Buffer where the signature is to be written.\n \\param signature_size        Size of the \\p signature buffer in bytes. This\n                              must be appropriate for the selected\n                              algorithm and key:\n                              - The required signature size is\n                                #PSA_SIGN_OUTPUT_SIZE(\\c key_type, \\c\n                                key_bits, \\c alg) where \\c key_type and \\c\n                                key_bits are the type and bit-size\n                                respectively of key.\n                              - #PSA_SIGNATURE_MAX_SIZE evaluates to the\n                                maximum signature size of any supported\n                                signature algorithm.\n \\param[out] signature_length On success, the number of bytes that make up\n                              the returned signature value.\n\n \\retval #PSA_SUCCESS\n         Operation completed successfully\n\n \\retval #PSA_OPERATION_INCOMPLETE\n         Operation was interrupted due to the setting of \\c\n         psa_interruptible_set_max_ops(). There is still work to be done.\n         Call this function again with the same operation object.\n\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p signature buffer is too small. You can\n         determine a sufficient buffer size by calling\n         #PSA_SIGN_OUTPUT_SIZE(\\c key_type, \\c key_bits, \\p alg)\n         where \\c key_type and \\c key_bits are the type and bit-size\n         respectively of \\p key.\n\n \\retval #PSA_ERROR_BAD_STATE\n         An operation was not previously started on this context via\n         \\c psa_sign_hash_start().\n\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription\n \\retval #PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has either not been previously initialized by\n         psa_crypto_init() or you did not previously call\n         psa_sign_hash_start() with this operation object. It is\n         implementation-dependent whether a failure to initialize results in\n         this error code."]
    pub fn psa_sign_hash_complete(
        operation: *mut psa_sign_hash_interruptible_operation_t,
        signature: *mut u8,
        signature_size: usize,
        signature_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief                       Abort a sign hash operation.\n\n \\warning                     This is a beta API, and thus subject to change\n                              at any point. It is not bound by the usual\n                              interface stability promises.\n\n \\note                        This function is the only function that clears\n                              the number of ops completed as part of the\n                              operation. Please ensure you copy this value via\n                              \\c psa_sign_hash_get_num_ops() if required\n                              before calling.\n\n \\note                        Aborting an operation frees all associated\n                              resources except for the \\p operation structure\n                              itself. Once aborted, the operation object can\n                              be reused for another operation by calling \\c\n                              psa_sign_hash_start() again.\n\n \\note                        You may call this function any time after the\n                              operation object has been initialized. In\n                              particular, calling \\c psa_sign_hash_abort()\n                              after the operation has already been terminated\n                              by a call to \\c psa_sign_hash_abort() or\n                              psa_sign_hash_complete() is safe.\n\n \\param[in,out] operation     Initialized sign hash operation.\n\n \\retval #PSA_SUCCESS\n         The operation was aborted successfully.\n\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_sign_hash_abort(
        operation: *mut psa_sign_hash_interruptible_operation_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief                       Start reading and verifying a hash or short\n                              message, in an interruptible manner.\n\n \\see                         \\c psa_verify_hash_complete()\n\n \\warning                     This is a beta API, and thus subject to change\n                              at any point. It is not bound by the usual\n                              interface stability promises.\n\n \\note                        This function combined with \\c\n                              psa_verify_hash_complete() is equivalent to\n                              \\c psa_verify_hash() but \\c\n                              psa_verify_hash_complete() can return early and\n                              resume according to the limit set with \\c\n                              psa_interruptible_set_max_ops() to reduce the\n                              maximum time spent in a function.\n\n \\note                        Users should call \\c psa_verify_hash_complete()\n                              repeatedly on the same operation object after a\n                              successful call to this function until \\c\n                              psa_verify_hash_complete() either returns 0 or\n                              an error. \\c psa_verify_hash_complete() will\n                              return #PSA_OPERATION_INCOMPLETE if there is\n                              more work to do. Alternatively users can call\n                              \\c psa_verify_hash_abort() at any point if they\n                              no longer want the result.\n\n \\note                        If this function returns an error status, the\n                              operation enters an error state and must be\n                              aborted by calling \\c psa_verify_hash_abort().\n\n \\param[in, out] operation    The \\c psa_verify_hash_interruptible_operation_t\n                              to use. This must be initialized first.\n\n \\param key                   Identifier of the key to use for the operation.\n                              The key must allow the usage\n                              #PSA_KEY_USAGE_VERIFY_HASH.\n \\param alg                   A signature algorithm (\\c PSA_ALG_XXX\n                              value such that #PSA_ALG_IS_SIGN_HASH(\\p alg)\n                              is true), that is compatible with\n                              the type of \\p key.\n \\param[in] hash              The hash whose signature is to be verified.\n \\param hash_length           Size of the \\p hash buffer in bytes.\n \\param[in] signature         Buffer containing the signature to verify.\n \\param signature_length      Size of the \\p signature buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         The operation started successfully - please call \\c\n         psa_verify_hash_complete() with the same context to complete the\n         operation.\n\n \\retval #PSA_ERROR_BAD_STATE\n         Another operation has already been started on this context, and is\n         still in progress.\n\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The key does not have the #PSA_KEY_USAGE_VERIFY_HASH flag, or it does\n         not permit the requested algorithm.\n\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval PSA_ERROR_DATA_CORRUPT \\emptydescription\n \\retval PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_verify_hash_start(
        operation: *mut psa_verify_hash_interruptible_operation_t,
        key: mbedtls_svc_key_id_t,
        alg: psa_algorithm_t,
        hash: *const u8,
        hash_length: usize,
        signature: *const u8,
        signature_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief                       Continue and eventually complete the action of\n                              reading and verifying a hash or short message\n                              signed with a private key, in an interruptible\n                              manner.\n\n \\see                         \\c psa_verify_hash_start()\n\n \\warning                     This is a beta API, and thus subject to change\n                              at any point. It is not bound by the usual\n                              interface stability promises.\n\n \\note                        This function combined with \\c\n                              psa_verify_hash_start() is equivalent to\n                              \\c psa_verify_hash() but this function can\n                              return early and resume according to the limit\n                              set with \\c psa_interruptible_set_max_ops() to\n                              reduce the maximum time spent in a function\n                              call.\n\n \\note                        Users should call this function on the same\n                              operation object repeatedly until it either\n                              returns 0 or an error. This function will return\n                              #PSA_OPERATION_INCOMPLETE if there is more work\n                              to do. Alternatively users can call\n                              \\c psa_verify_hash_abort() at any point if they\n                              no longer want the result.\n\n \\note                        When this function returns successfully, the\n                              operation becomes inactive. If this function\n                              returns an error status, the operation enters an\n                              error state and must be aborted by calling\n                              \\c psa_verify_hash_abort().\n\n \\param[in, out] operation    The \\c psa_verify_hash_interruptible_operation_t\n                              to use. This must be initialized first, and have\n                              had \\c psa_verify_hash_start() called with it\n                              first.\n\n \\retval #PSA_SUCCESS\n         Operation completed successfully, and the passed signature is valid.\n\n \\retval #PSA_OPERATION_INCOMPLETE\n         Operation was interrupted due to the setting of \\c\n         psa_interruptible_set_max_ops(). There is still work to be done.\n         Call this function again with the same operation object.\n\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The calculation was performed successfully, but the passed\n         signature is not a valid signature.\n \\retval #PSA_ERROR_BAD_STATE\n         An operation was not previously started on this context via\n         \\c psa_verify_hash_start().\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription\n \\retval #PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has either not been previously initialized by\n         psa_crypto_init() or you did not previously call\n         psa_verify_hash_start() on this object. It is\n         implementation-dependent whether a failure to initialize results in\n         this error code."]
    pub fn psa_verify_hash_complete(
        operation: *mut psa_verify_hash_interruptible_operation_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief                     Abort a verify hash operation.\n\n \\warning                   This is a beta API, and thus subject to change at\n                            any point. It is not bound by the usual interface\n                            stability promises.\n\n \\note                      This function is the only function that clears the\n                            number of ops completed as part of the operation.\n                            Please ensure you copy this value via\n                            \\c psa_verify_hash_get_num_ops() if required\n                            before calling.\n\n \\note                      Aborting an operation frees all associated\n                            resources except for the operation structure\n                            itself. Once aborted, the operation object can be\n                            reused for another operation by calling \\c\n                            psa_verify_hash_start() again.\n\n \\note                      You may call this function any time after the\n                            operation object has been initialized.\n                            In particular, calling \\c psa_verify_hash_abort()\n                            after the operation has already been terminated by\n                            a call to \\c psa_verify_hash_abort() or\n                            psa_verify_hash_complete() is safe.\n\n \\param[in,out] operation   Initialized verify hash operation.\n\n \\retval #PSA_SUCCESS\n         The operation was aborted successfully.\n\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_verify_hash_abort(
        operation: *mut psa_verify_hash_interruptible_operation_t,
    ) -> psa_status_t;
}
#[doc = " The CMAC context structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_cmac_context_t {
    pub private_state: [crate::c_types::c_uchar; 16usize],
    pub private_unprocessed_block: [crate::c_types::c_uchar; 16usize],
    pub private_unprocessed_len: usize,
}
extern "C" {
    #[doc = " \\brief               This function starts a new CMAC computation\n                      by setting the CMAC key, and preparing to authenticate\n                      the input data.\n                      It must be called with an initialized cipher context.\n\n                      Once this function has completed, data can be supplied\n                      to the CMAC computation by calling\n                      mbedtls_cipher_cmac_update().\n\n                      To start a CMAC computation using the same key as a previous\n                      CMAC computation, use mbedtls_cipher_cmac_finish().\n\n \\note                When the CMAC implementation is supplied by an alternate\n                      implementation (through #MBEDTLS_CMAC_ALT), some ciphers\n                      may not be supported by that implementation, and thus\n                      return an error. Alternate implementations must support\n                      AES-128 and AES-256, and may support AES-192 and 3DES.\n\n \\param ctx           The cipher context used for the CMAC operation, initialized\n                      as one of the following types: MBEDTLS_CIPHER_AES_128_ECB,\n                      MBEDTLS_CIPHER_AES_192_ECB, MBEDTLS_CIPHER_AES_256_ECB,\n                      or MBEDTLS_CIPHER_DES_EDE3_ECB.\n \\param key           The CMAC key.\n \\param keybits       The length of the CMAC key in bits.\n                      Must be supported by the cipher.\n\n \\return              \\c 0 on success.\n \\return              A cipher-specific error code on failure."]
    pub fn mbedtls_cipher_cmac_starts(
        ctx: *mut mbedtls_cipher_context_t,
        key: *const crate::c_types::c_uchar,
        keybits: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function feeds an input buffer into an ongoing CMAC\n                      computation.\n\n                      The CMAC computation must have previously been started\n                      by calling mbedtls_cipher_cmac_starts() or\n                      mbedtls_cipher_cmac_reset().\n\n                      Call this function as many times as needed to input the\n                      data to be authenticated.\n                      Once all of the required data has been input,\n                      call mbedtls_cipher_cmac_finish() to obtain the result\n                      of the CMAC operation.\n\n \\param ctx           The cipher context used for the CMAC operation.\n \\param input         The buffer holding the input data.\n \\param ilen          The length of the input data.\n\n \\return             \\c 0 on success.\n \\return             #MBEDTLS_ERR_MD_BAD_INPUT_DATA\n                     if parameter verification fails."]
    pub fn mbedtls_cipher_cmac_update(
        ctx: *mut mbedtls_cipher_context_t,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function finishes an ongoing CMAC operation, and\n                      writes the result to the output buffer.\n\n                      It should be followed either by\n                      mbedtls_cipher_cmac_reset(), which starts another CMAC\n                      operation with the same key, or mbedtls_cipher_free(),\n                      which clears the cipher context.\n\n \\param ctx           The cipher context used for the CMAC operation.\n \\param output        The output buffer for the CMAC checksum result.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_MD_BAD_INPUT_DATA\n                      if parameter verification fails."]
    pub fn mbedtls_cipher_cmac_finish(
        ctx: *mut mbedtls_cipher_context_t,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function starts a new CMAC operation with the same\n                      key as the previous one.\n\n                      It should be called after finishing the previous CMAC\n                      operation with mbedtls_cipher_cmac_finish().\n                      After calling this function,\n                      call mbedtls_cipher_cmac_update() to supply the new\n                      CMAC operation with data.\n\n \\param ctx           The cipher context used for the CMAC operation.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_MD_BAD_INPUT_DATA\n                      if parameter verification fails."]
    pub fn mbedtls_cipher_cmac_reset(ctx: *mut mbedtls_cipher_context_t) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function calculates the full generic CMAC\n                      on the input buffer with the provided key.\n\n                      The function allocates the context, performs the\n                      calculation, and frees the context.\n\n                      The CMAC result is calculated as\n                      output = generic CMAC(cmac key, input buffer).\n\n \\note                When the CMAC implementation is supplied by an alternate\n                      implementation (through #MBEDTLS_CMAC_ALT), some ciphers\n                      may not be supported by that implementation, and thus\n                      return an error. Alternate implementations must support\n                      AES-128 and AES-256, and may support AES-192 and 3DES.\n\n \\param cipher_info   The cipher information.\n \\param key           The CMAC key.\n \\param keylen        The length of the CMAC key in bits.\n \\param input         The buffer holding the input data.\n \\param ilen          The length of the input data.\n \\param output        The buffer for the generic CMAC result.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_MD_BAD_INPUT_DATA\n                      if parameter verification fails."]
    pub fn mbedtls_cipher_cmac(
        cipher_info: *const mbedtls_cipher_info_t,
        key: *const crate::c_types::c_uchar,
        keylen: usize,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function implements the AES-CMAC-PRF-128 pseudorandom\n                  function, as defined in\n                  <em>RFC-4615: The Advanced Encryption Standard-Cipher-based\n                  Message Authentication Code-Pseudo-Random Function-128\n                  (AES-CMAC-PRF-128) Algorithm for the Internet Key\n                  Exchange Protocol (IKE).</em>\n\n \\param key       The key to use.\n \\param key_len   The key length in Bytes.\n \\param input     The buffer holding the input data.\n \\param in_len    The length of the input data in Bytes.\n \\param output    The buffer holding the generated 16 Bytes of\n                  pseudorandom output.\n\n \\return          \\c 0 on success."]
    pub fn mbedtls_aes_cmac_prf_128(
        key: *const crate::c_types::c_uchar,
        key_len: usize,
        input: *const crate::c_types::c_uchar,
        in_len: usize,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          The CMAC checkup routine.\n\n \\note           In case the CMAC routines are provided by an alternative\n                 implementation (i.e. #MBEDTLS_CMAC_ALT is defined), the\n                 checkup routine will succeed even if the implementation does\n                 not support the less widely used AES-192 or 3DES primitives.\n                 The self-test requires at least AES-128 and AES-256 to be\n                 supported by the underlying implementation.\n\n \\return         \\c 0 on success.\n \\return         \\c 1 on failure."]
    pub fn mbedtls_cmac_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[doc = " \\brief          The GCM context structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_gcm_context {
    pub private_cipher_ctx: mbedtls_cipher_context_t,
    pub private_HL: [u64; 16usize],
    pub private_HH: [u64; 16usize],
    pub private_len: u64,
    pub private_add_len: u64,
    pub private_base_ectr: [crate::c_types::c_uchar; 16usize],
    pub private_y: [crate::c_types::c_uchar; 16usize],
    pub private_buf: [crate::c_types::c_uchar; 16usize],
    pub private_mode: crate::c_types::c_int,
}
extern "C" {
    #[doc = " \\brief           This function initializes the specified GCM context,\n                  to make references valid, and prepares the context\n                  for mbedtls_gcm_setkey() or mbedtls_gcm_free().\n\n                  The function does not bind the GCM context to a particular\n                  cipher, nor set the key. For this purpose, use\n                  mbedtls_gcm_setkey().\n\n \\param ctx       The GCM context to initialize. This must not be \\c NULL."]
    pub fn mbedtls_gcm_init(ctx: *mut mbedtls_gcm_context);
}
extern "C" {
    #[doc = " \\brief           This function associates a GCM context with a\n                  cipher algorithm and a key.\n\n \\param ctx       The GCM context. This must be initialized.\n \\param cipher    The 128-bit block cipher to use.\n \\param key       The encryption key. This must be a readable buffer of at\n                  least \\p keybits bits.\n \\param keybits   The key size in bits. Valid options are:\n                  <ul><li>128 bits</li>\n                  <li>192 bits</li>\n                  <li>256 bits</li></ul>\n\n \\return          \\c 0 on success.\n \\return          A cipher-specific error code on failure."]
    pub fn mbedtls_gcm_setkey(
        ctx: *mut mbedtls_gcm_context,
        cipher: mbedtls_cipher_id_t,
        key: *const crate::c_types::c_uchar,
        keybits: crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs GCM encryption or decryption of a buffer.\n\n \\note            For encryption, the output buffer can be the same as the\n                  input buffer. For decryption, the output buffer cannot be\n                  the same as input buffer. If the buffers overlap, the output\n                  buffer must trail at least 8 Bytes behind the input buffer.\n\n \\warning         When this function performs a decryption, it outputs the\n                  authentication tag and does not verify that the data is\n                  authentic. You should use this function to perform encryption\n                  only. For decryption, use mbedtls_gcm_auth_decrypt() instead.\n\n \\param ctx       The GCM context to use for encryption or decryption. This\n                  must be initialized.\n \\param mode      The operation to perform:\n                  - #MBEDTLS_GCM_ENCRYPT to perform authenticated encryption.\n                    The ciphertext is written to \\p output and the\n                    authentication tag is written to \\p tag.\n                  - #MBEDTLS_GCM_DECRYPT to perform decryption.\n                    The plaintext is written to \\p output and the\n                    authentication tag is written to \\p tag.\n                    Note that this mode is not recommended, because it does\n                    not verify the authenticity of the data. For this reason,\n                    you should use mbedtls_gcm_auth_decrypt() instead of\n                    calling this function in decryption mode.\n \\param length    The length of the input data, which is equal to the length\n                  of the output data.\n \\param iv        The initialization vector. This must be a readable buffer of\n                  at least \\p iv_len Bytes.\n \\param iv_len    The length of the IV.\n \\param add       The buffer holding the additional data. This must be of at\n                  least that size in Bytes.\n \\param add_len   The length of the additional data.\n \\param input     The buffer holding the input data. If \\p length is greater\n                  than zero, this must be a readable buffer of at least that\n                  size in Bytes.\n \\param output    The buffer for holding the output data. If \\p length is greater\n                  than zero, this must be a writable buffer of at least that\n                  size in Bytes.\n \\param tag_len   The length of the tag to generate.\n \\param tag       The buffer for holding the tag. This must be a writable\n                  buffer of at least \\p tag_len Bytes.\n\n \\return          \\c 0 if the encryption or decryption was performed\n                  successfully. Note that in #MBEDTLS_GCM_DECRYPT mode,\n                  this does not indicate that the data is authentic.\n \\return          #MBEDTLS_ERR_GCM_BAD_INPUT if the lengths or pointers are\n                  not valid or a cipher-specific error code if the encryption\n                  or decryption failed."]
    pub fn mbedtls_gcm_crypt_and_tag(
        ctx: *mut mbedtls_gcm_context,
        mode: crate::c_types::c_int,
        length: usize,
        iv: *const crate::c_types::c_uchar,
        iv_len: usize,
        add: *const crate::c_types::c_uchar,
        add_len: usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
        tag_len: usize,
        tag: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs a GCM authenticated decryption of a\n                  buffer.\n\n \\note            For decryption, the output buffer cannot be the same as\n                  input buffer. If the buffers overlap, the output buffer\n                  must trail at least 8 Bytes behind the input buffer.\n\n \\param ctx       The GCM context. This must be initialized.\n \\param length    The length of the ciphertext to decrypt, which is also\n                  the length of the decrypted plaintext.\n \\param iv        The initialization vector. This must be a readable buffer\n                  of at least \\p iv_len Bytes.\n \\param iv_len    The length of the IV.\n \\param add       The buffer holding the additional data. This must be of at\n                  least that size in Bytes.\n \\param add_len   The length of the additional data.\n \\param tag       The buffer holding the tag to verify. This must be a\n                  readable buffer of at least \\p tag_len Bytes.\n \\param tag_len   The length of the tag to verify.\n \\param input     The buffer holding the ciphertext. If \\p length is greater\n                  than zero, this must be a readable buffer of at least that\n                  size.\n \\param output    The buffer for holding the decrypted plaintext. If \\p length\n                  is greater than zero, this must be a writable buffer of at\n                  least that size.\n\n \\return          \\c 0 if successful and authenticated.\n \\return          #MBEDTLS_ERR_GCM_AUTH_FAILED if the tag does not match.\n \\return          #MBEDTLS_ERR_GCM_BAD_INPUT if the lengths or pointers are\n                  not valid or a cipher-specific error code if the decryption\n                  failed."]
    pub fn mbedtls_gcm_auth_decrypt(
        ctx: *mut mbedtls_gcm_context,
        length: usize,
        iv: *const crate::c_types::c_uchar,
        iv_len: usize,
        add: *const crate::c_types::c_uchar,
        add_len: usize,
        tag: *const crate::c_types::c_uchar,
        tag_len: usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function starts a GCM encryption or decryption\n                  operation.\n\n \\param ctx       The GCM context. This must be initialized.\n \\param mode      The operation to perform: #MBEDTLS_GCM_ENCRYPT or\n                  #MBEDTLS_GCM_DECRYPT.\n \\param iv        The initialization vector. This must be a readable buffer of\n                  at least \\p iv_len Bytes.\n \\param iv_len    The length of the IV.\n\n \\return          \\c 0 on success."]
    pub fn mbedtls_gcm_starts(
        ctx: *mut mbedtls_gcm_context,
        mode: crate::c_types::c_int,
        iv: *const crate::c_types::c_uchar,
        iv_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function feeds an input buffer as associated data\n                  (authenticated but not encrypted data) in a GCM\n                  encryption or decryption operation.\n\n                  Call this function after mbedtls_gcm_starts() to pass\n                  the associated data. If the associated data is empty,\n                  you do not need to call this function. You may not\n                  call this function after calling mbedtls_cipher_update().\n\n \\param ctx       The GCM context. This must have been started with\n                  mbedtls_gcm_starts() and must not have yet received\n                  any input with mbedtls_gcm_update().\n \\param add       The buffer holding the additional data, or \\c NULL\n                  if \\p add_len is \\c 0.\n \\param add_len   The length of the additional data. If \\c 0,\n                  \\p add may be \\c NULL.\n\n \\return          \\c 0 on success."]
    pub fn mbedtls_gcm_update_ad(
        ctx: *mut mbedtls_gcm_context,
        add: *const crate::c_types::c_uchar,
        add_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function feeds an input buffer into an ongoing GCM\n                  encryption or decryption operation.\n\n                  You may call this function zero, one or more times\n                  to pass successive parts of the input: the plaintext to\n                  encrypt, or the ciphertext (not including the tag) to\n                  decrypt. After the last part of the input, call\n                  mbedtls_gcm_finish().\n\n                  This function may produce output in one of the following\n                  ways:\n                  - Immediate output: the output length is always equal\n                    to the input length.\n                  - Buffered output: the output consists of a whole number\n                    of 16-byte blocks. If the total input length so far\n                    (not including associated data) is 16 \\* *B* + *A*\n                    with *A* < 16 then the total output length is 16 \\* *B*.\n\n                  In particular:\n                  - It is always correct to call this function with\n                    \\p output_size >= \\p input_length + 15.\n                  - If \\p input_length is a multiple of 16 for all the calls\n                    to this function during an operation, then it is\n                    correct to use \\p output_size = \\p input_length.\n\n \\note            For decryption, the output buffer cannot be the same as\n                  input buffer. If the buffers overlap, the output buffer\n                  must trail at least 8 Bytes behind the input buffer.\n\n \\param ctx           The GCM context. This must be initialized.\n \\param input         The buffer holding the input data. If \\p input_length\n                      is greater than zero, this must be a readable buffer\n                      of at least \\p input_length bytes.\n \\param input_length  The length of the input data in bytes.\n \\param output        The buffer for the output data. If \\p output_size\n                      is greater than zero, this must be a writable buffer of\n                      of at least \\p output_size bytes.\n \\param output_size   The size of the output buffer in bytes.\n                      See the function description regarding the output size.\n \\param output_length On success, \\p *output_length contains the actual\n                      length of the output written in \\p output.\n                      On failure, the content of \\p *output_length is\n                      unspecified.\n\n \\return         \\c 0 on success.\n \\return         #MBEDTLS_ERR_GCM_BAD_INPUT on failure:\n                 total input length too long,\n                 unsupported input/output buffer overlap detected,\n                 or \\p output_size too small."]
    pub fn mbedtls_gcm_update(
        ctx: *mut mbedtls_gcm_context,
        input: *const crate::c_types::c_uchar,
        input_length: usize,
        output: *mut crate::c_types::c_uchar,
        output_size: usize,
        output_length: *mut usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function finishes the GCM operation and generates\n                  the authentication tag.\n\n                  It wraps up the GCM stream, and generates the\n                  tag. The tag can have a maximum length of 16 Bytes.\n\n \\param ctx       The GCM context. This must be initialized.\n \\param tag       The buffer for holding the tag. This must be a writable\n                  buffer of at least \\p tag_len Bytes.\n \\param tag_len   The length of the tag to generate. This must be at least\n                  four.\n \\param output    The buffer for the final output.\n                  If \\p output_size is nonzero, this must be a writable\n                  buffer of at least \\p output_size bytes.\n \\param output_size  The size of the \\p output buffer in bytes.\n                  This must be large enough for the output that\n                  mbedtls_gcm_update() has not produced. In particular:\n                  - If mbedtls_gcm_update() produces immediate output,\n                    or if the total input size is a multiple of \\c 16,\n                    then mbedtls_gcm_finish() never produces any output,\n                    so \\p output_size can be \\c 0.\n                  - \\p output_size never needs to be more than \\c 15.\n \\param output_length On success, \\p *output_length contains the actual\n                      length of the output written in \\p output.\n                      On failure, the content of \\p *output_length is\n                      unspecified.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_GCM_BAD_INPUT on failure:\n                  invalid value of \\p tag_len,\n                  or \\p output_size too small."]
    pub fn mbedtls_gcm_finish(
        ctx: *mut mbedtls_gcm_context,
        output: *mut crate::c_types::c_uchar,
        output_size: usize,
        output_length: *mut usize,
        tag: *mut crate::c_types::c_uchar,
        tag_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function clears a GCM context and the underlying\n                  cipher sub-context.\n\n \\param ctx       The GCM context to clear. If this is \\c NULL, the call has\n                  no effect. Otherwise, this must be initialized."]
    pub fn mbedtls_gcm_free(ctx: *mut mbedtls_gcm_context);
}
extern "C" {
    #[doc = " \\brief          The GCM checkup routine.\n\n \\return         \\c 0 on success.\n \\return         \\c 1 on failure."]
    pub fn mbedtls_gcm_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[doc = " \\brief    The CCM context-type definition. The CCM context is passed\n           to the APIs called."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ccm_context {
    pub private_y: [crate::c_types::c_uchar; 16usize],
    pub private_ctr: [crate::c_types::c_uchar; 16usize],
    pub private_cipher_ctx: mbedtls_cipher_context_t,
    pub private_plaintext_len: usize,
    pub private_add_len: usize,
    pub private_tag_len: usize,
    pub private_processed: usize,
    pub private_q: crate::c_types::c_uchar,
    pub private_mode: crate::c_types::c_uchar,
    pub private_state: crate::c_types::c_int,
}
extern "C" {
    #[doc = " \\brief           This function initializes the specified CCM context,\n                  to make references valid, and prepare the context\n                  for mbedtls_ccm_setkey() or mbedtls_ccm_free().\n\n \\param ctx       The CCM context to initialize. This must not be \\c NULL."]
    pub fn mbedtls_ccm_init(ctx: *mut mbedtls_ccm_context);
}
extern "C" {
    #[doc = " \\brief           This function initializes the CCM context set in the\n                  \\p ctx parameter and sets the encryption key.\n\n \\param ctx       The CCM context to initialize. This must be an initialized\n                  context.\n \\param cipher    The 128-bit block cipher to use.\n \\param key       The encryption key. This must not be \\c NULL.\n \\param keybits   The key size in bits. This must be acceptable by the cipher.\n\n \\return          \\c 0 on success.\n \\return          A CCM or cipher-specific error code on failure."]
    pub fn mbedtls_ccm_setkey(
        ctx: *mut mbedtls_ccm_context,
        cipher: mbedtls_cipher_id_t,
        key: *const crate::c_types::c_uchar,
        keybits: crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief   This function releases and clears the specified CCM context\n          and underlying cipher sub-context.\n\n \\param ctx       The CCM context to clear. If this is \\c NULL, the function\n                  has no effect. Otherwise, this must be initialized."]
    pub fn mbedtls_ccm_free(ctx: *mut mbedtls_ccm_context);
}
extern "C" {
    #[doc = " \\brief           This function encrypts a buffer using CCM.\n\n \\note            The tag is written to a separate buffer. To concatenate\n                  the \\p tag with the \\p output, as done in <em>RFC-3610:\n                  Counter with CBC-MAC (CCM)</em>, use\n                  \\p tag = \\p output + \\p length, and make sure that the\n                  output buffer is at least \\p length + \\p tag_len wide.\n\n \\param ctx       The CCM context to use for encryption. This must be\n                  initialized and bound to a key.\n \\param length    The length of the input data in Bytes.\n \\param iv        The initialization vector (nonce). This must be a readable\n                  buffer of at least \\p iv_len Bytes.\n \\param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,\n                  or 13. The length L of the message length field is\n                  15 - \\p iv_len.\n \\param ad        The additional data field. If \\p ad_len is greater than\n                  zero, \\p ad must be a readable buffer of at least that\n                  length.\n \\param ad_len    The length of additional data in Bytes.\n                  This must be less than `2^16 - 2^8`.\n \\param input     The buffer holding the input data. If \\p length is greater\n                  than zero, \\p input must be a readable buffer of at least\n                  that length.\n \\param output    The buffer holding the output data. If \\p length is greater\n                  than zero, \\p output must be a writable buffer of at least\n                  that length.\n \\param tag       The buffer holding the authentication field. This must be a\n                  writable buffer of at least \\p tag_len Bytes.\n \\param tag_len   The length of the authentication field to generate in Bytes:\n                  4, 6, 8, 10, 12, 14 or 16.\n\n \\return          \\c 0 on success.\n \\return          A CCM or cipher-specific error code on failure."]
    pub fn mbedtls_ccm_encrypt_and_tag(
        ctx: *mut mbedtls_ccm_context,
        length: usize,
        iv: *const crate::c_types::c_uchar,
        iv_len: usize,
        ad: *const crate::c_types::c_uchar,
        ad_len: usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
        tag: *mut crate::c_types::c_uchar,
        tag_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function encrypts a buffer using CCM*.\n\n \\note            The tag is written to a separate buffer. To concatenate\n                  the \\p tag with the \\p output, as done in <em>RFC-3610:\n                  Counter with CBC-MAC (CCM)</em>, use\n                  \\p tag = \\p output + \\p length, and make sure that the\n                  output buffer is at least \\p length + \\p tag_len wide.\n\n \\note            When using this function in a variable tag length context,\n                  the tag length has to be encoded into the \\p iv passed to\n                  this function.\n\n \\param ctx       The CCM context to use for encryption. This must be\n                  initialized and bound to a key.\n \\param length    The length of the input data in Bytes.\n                  For tag length = 0, input length is ignored.\n \\param iv        The initialization vector (nonce). This must be a readable\n                  buffer of at least \\p iv_len Bytes.\n \\param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,\n                  or 13. The length L of the message length field is\n                  15 - \\p iv_len.\n \\param ad        The additional data field. This must be a readable buffer of\n                  at least \\p ad_len Bytes.\n \\param ad_len    The length of additional data in Bytes.\n                  This must be less than 2^16 - 2^8.\n \\param input     The buffer holding the input data. If \\p length is greater\n                  than zero, \\p input must be a readable buffer of at least\n                  that length.\n \\param output    The buffer holding the output data. If \\p length is greater\n                  than zero, \\p output must be a writable buffer of at least\n                  that length.\n \\param tag       The buffer holding the authentication field. This must be a\n                  writable buffer of at least \\p tag_len Bytes.\n \\param tag_len   The length of the authentication field to generate in Bytes:\n                  0, 4, 6, 8, 10, 12, 14 or 16.\n\n \\warning         Passing \\c 0 as \\p tag_len means that the message is no\n                  longer authenticated.\n\n \\return          \\c 0 on success.\n \\return          A CCM or cipher-specific error code on failure."]
    pub fn mbedtls_ccm_star_encrypt_and_tag(
        ctx: *mut mbedtls_ccm_context,
        length: usize,
        iv: *const crate::c_types::c_uchar,
        iv_len: usize,
        ad: *const crate::c_types::c_uchar,
        ad_len: usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
        tag: *mut crate::c_types::c_uchar,
        tag_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs a CCM authenticated decryption of a\n                  buffer.\n\n \\param ctx       The CCM context to use for decryption. This must be\n                  initialized and bound to a key.\n \\param length    The length of the input data in Bytes.\n \\param iv        The initialization vector (nonce). This must be a readable\n                  buffer of at least \\p iv_len Bytes.\n \\param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,\n                  or 13. The length L of the message length field is\n                  15 - \\p iv_len.\n \\param ad        The additional data field. This must be a readable buffer\n                  of at least that \\p ad_len Bytes..\n \\param ad_len    The length of additional data in Bytes.\n                  This must be less than 2^16 - 2^8.\n \\param input     The buffer holding the input data. If \\p length is greater\n                  than zero, \\p input must be a readable buffer of at least\n                  that length.\n \\param output    The buffer holding the output data. If \\p length is greater\n                  than zero, \\p output must be a writable buffer of at least\n                  that length.\n \\param tag       The buffer holding the authentication field. This must be a\n                  readable buffer of at least \\p tag_len Bytes.\n \\param tag_len   The length of the authentication field to generate in Bytes:\n                  4, 6, 8, 10, 12, 14 or 16.\n\n \\return          \\c 0 on success. This indicates that the message is authentic.\n \\return          #MBEDTLS_ERR_CCM_AUTH_FAILED if the tag does not match.\n \\return          A cipher-specific error code on calculation failure."]
    pub fn mbedtls_ccm_auth_decrypt(
        ctx: *mut mbedtls_ccm_context,
        length: usize,
        iv: *const crate::c_types::c_uchar,
        iv_len: usize,
        ad: *const crate::c_types::c_uchar,
        ad_len: usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
        tag: *const crate::c_types::c_uchar,
        tag_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs a CCM* authenticated decryption of a\n                  buffer.\n\n \\note            When using this function in a variable tag length context,\n                  the tag length has to be decoded from \\p iv and passed to\n                  this function as \\p tag_len. (\\p tag needs to be adjusted\n                  accordingly.)\n\n \\param ctx       The CCM context to use for decryption. This must be\n                  initialized and bound to a key.\n \\param length    The length of the input data in Bytes.\n                  For tag length = 0, input length is ignored.\n \\param iv        The initialization vector (nonce). This must be a readable\n                  buffer of at least \\p iv_len Bytes.\n \\param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,\n                  or 13. The length L of the message length field is\n                  15 - \\p iv_len.\n \\param ad        The additional data field. This must be a readable buffer of\n                  at least that \\p ad_len Bytes.\n \\param ad_len    The length of additional data in Bytes.\n                  This must be less than 2^16 - 2^8.\n \\param input     The buffer holding the input data. If \\p length is greater\n                  than zero, \\p input must be a readable buffer of at least\n                  that length.\n \\param output    The buffer holding the output data. If \\p length is greater\n                  than zero, \\p output must be a writable buffer of at least\n                  that length.\n \\param tag       The buffer holding the authentication field. This must be a\n                  readable buffer of at least \\p tag_len Bytes.\n \\param tag_len   The length of the authentication field in Bytes.\n                  0, 4, 6, 8, 10, 12, 14 or 16.\n\n \\warning         Passing \\c 0 as \\p tag_len means that the message is nos\n                  longer authenticated.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CCM_AUTH_FAILED if the tag does not match.\n \\return          A cipher-specific error code on calculation failure."]
    pub fn mbedtls_ccm_star_auth_decrypt(
        ctx: *mut mbedtls_ccm_context,
        length: usize,
        iv: *const crate::c_types::c_uchar,
        iv_len: usize,
        ad: *const crate::c_types::c_uchar,
        ad_len: usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
        tag: *const crate::c_types::c_uchar,
        tag_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function starts a CCM encryption or decryption\n                  operation.\n\n                  This function and mbedtls_ccm_set_lengths() must be called\n                  before calling mbedtls_ccm_update_ad() or\n                  mbedtls_ccm_update(). This function can be called before\n                  or after mbedtls_ccm_set_lengths().\n\n \\note            This function is not implemented in Mbed TLS yet.\n\n \\param ctx       The CCM context. This must be initialized.\n \\param mode      The operation to perform: #MBEDTLS_CCM_ENCRYPT or\n                  #MBEDTLS_CCM_DECRYPT or #MBEDTLS_CCM_STAR_ENCRYPT or\n                  #MBEDTLS_CCM_STAR_DECRYPT.\n \\param iv        The initialization vector. This must be a readable buffer\n                  of at least \\p iv_len Bytes.\n \\param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,\n                  or 13. The length L of the message length field is\n                  15 - \\p iv_len.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CCM_BAD_INPUT on failure:\n                  \\p ctx is in an invalid state,\n                  \\p mode is invalid,\n                  \\p iv_len is invalid (lower than \\c 7 or greater than\n                  \\c 13)."]
    pub fn mbedtls_ccm_starts(
        ctx: *mut mbedtls_ccm_context,
        mode: crate::c_types::c_int,
        iv: *const crate::c_types::c_uchar,
        iv_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function declares the lengths of the message\n                  and additional data for a CCM encryption or decryption\n                  operation.\n\n                  This function and mbedtls_ccm_starts() must be called\n                  before calling mbedtls_ccm_update_ad() or\n                  mbedtls_ccm_update(). This function can be called before\n                  or after mbedtls_ccm_starts().\n\n \\note            This function is not implemented in Mbed TLS yet.\n\n \\param ctx       The CCM context. This must be initialized.\n \\param total_ad_len   The total length of additional data in bytes.\n                       This must be less than `2^16 - 2^8`.\n \\param plaintext_len  The length in bytes of the plaintext to encrypt or\n                       result of the decryption (thus not encompassing the\n                       additional data that are not encrypted).\n \\param tag_len   The length of the tag to generate in Bytes:\n                  4, 6, 8, 10, 12, 14 or 16.\n                  For CCM*, zero is also valid.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CCM_BAD_INPUT on failure:\n                  \\p ctx is in an invalid state,\n                  \\p total_ad_len is greater than \\c 0xFF00."]
    pub fn mbedtls_ccm_set_lengths(
        ctx: *mut mbedtls_ccm_context,
        total_ad_len: usize,
        plaintext_len: usize,
        tag_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function feeds an input buffer as associated data\n                  (authenticated but not encrypted data) in a CCM\n                  encryption or decryption operation.\n\n                  You may call this function zero, one or more times\n                  to pass successive parts of the additional data. The\n                  lengths \\p ad_len of the data parts should eventually add\n                  up exactly to the total length of additional data\n                  \\c total_ad_len passed to mbedtls_ccm_set_lengths(). You\n                  may not call this function after calling\n                  mbedtls_ccm_update().\n\n \\note            This function is not implemented in Mbed TLS yet.\n\n \\param ctx       The CCM context. This must have been started with\n                  mbedtls_ccm_starts(), the lengths of the message and\n                  additional data must have been declared with\n                  mbedtls_ccm_set_lengths() and this must not have yet\n                  received any input with mbedtls_ccm_update().\n \\param ad        The buffer holding the additional data, or \\c NULL\n                  if \\p ad_len is \\c 0.\n \\param ad_len    The length of the additional data. If \\c 0,\n                  \\p ad may be \\c NULL.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CCM_BAD_INPUT on failure:\n                  \\p ctx is in an invalid state,\n                  total input length too long."]
    pub fn mbedtls_ccm_update_ad(
        ctx: *mut mbedtls_ccm_context,
        ad: *const crate::c_types::c_uchar,
        ad_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function feeds an input buffer into an ongoing CCM\n                  encryption or decryption operation.\n\n                  You may call this function zero, one or more times\n                  to pass successive parts of the input: the plaintext to\n                  encrypt, or the ciphertext (not including the tag) to\n                  decrypt. After the last part of the input, call\n                  mbedtls_ccm_finish(). The lengths \\p input_len of the\n                  data parts should eventually add up exactly to the\n                  plaintext length \\c plaintext_len passed to\n                  mbedtls_ccm_set_lengths().\n\n                  This function may produce output in one of the following\n                  ways:\n                  - Immediate output: the output length is always equal\n                    to the input length.\n                  - Buffered output: except for the last part of input data,\n                    the output consists of a whole number of 16-byte blocks.\n                    If the total input length so far (not including\n                    associated data) is 16 \\* *B* + *A* with *A* < 16 then\n                    the total output length is 16 \\* *B*.\n                    For the last part of input data, the output length is\n                    equal to the input length plus the number of bytes (*A*)\n                    buffered in the previous call to the function (if any).\n                    The function uses the plaintext length\n                    \\c plaintext_len passed to mbedtls_ccm_set_lengths()\n                    to detect the last part of input data.\n\n                  In particular:\n                  - It is always correct to call this function with\n                    \\p output_size >= \\p input_len + 15.\n                  - If \\p input_len is a multiple of 16 for all the calls\n                    to this function during an operation (not necessary for\n                    the last one) then it is correct to use \\p output_size\n                    =\\p input_len.\n\n \\note            This function is not implemented in Mbed TLS yet.\n\n \\param ctx           The CCM context. This must have been started with\n                      mbedtls_ccm_starts() and the lengths of the message and\n                      additional data must have been declared with\n                      mbedtls_ccm_set_lengths().\n \\param input         The buffer holding the input data. If \\p input_len\n                      is greater than zero, this must be a readable buffer\n                      of at least \\p input_len bytes.\n \\param input_len     The length of the input data in bytes.\n \\param output        The buffer for the output data. If \\p output_size\n                      is greater than zero, this must be a writable buffer of\n                      at least \\p output_size bytes.\n \\param output_size   The size of the output buffer in bytes.\n                      See the function description regarding the output size.\n \\param output_len    On success, \\p *output_len contains the actual\n                      length of the output written in \\p output.\n                      On failure, the content of \\p *output_len is\n                      unspecified.\n\n \\return         \\c 0 on success.\n \\return         #MBEDTLS_ERR_CCM_BAD_INPUT on failure:\n                 \\p ctx is in an invalid state,\n                 total input length too long,\n                 or \\p output_size too small."]
    pub fn mbedtls_ccm_update(
        ctx: *mut mbedtls_ccm_context,
        input: *const crate::c_types::c_uchar,
        input_len: usize,
        output: *mut crate::c_types::c_uchar,
        output_size: usize,
        output_len: *mut usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function finishes the CCM operation and generates\n                  the authentication tag.\n\n                  It wraps up the CCM stream, and generates the\n                  tag. The tag can have a maximum length of 16 Bytes.\n\n \\note            This function is not implemented in Mbed TLS yet.\n\n \\param ctx       The CCM context. This must have been started with\n                  mbedtls_ccm_starts() and the lengths of the message and\n                  additional data must have been declared with\n                  mbedtls_ccm_set_lengths().\n \\param tag       The buffer for holding the tag. If \\p tag_len is greater\n                  than zero, this must be a writable buffer of at least \\p\n                  tag_len Bytes.\n \\param tag_len   The length of the tag. Must match the tag length passed to\n                  mbedtls_ccm_set_lengths() function.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CCM_BAD_INPUT on failure:\n                  \\p ctx is in an invalid state,\n                  invalid value of \\p tag_len,\n                  the total amount of additional data passed to\n                  mbedtls_ccm_update_ad() was lower than the total length of\n                  additional data \\c total_ad_len passed to\n                  mbedtls_ccm_set_lengths(),\n                  the total amount of input data passed to\n                  mbedtls_ccm_update() was lower than the plaintext length\n                  \\c plaintext_len passed to mbedtls_ccm_set_lengths()."]
    pub fn mbedtls_ccm_finish(
        ctx: *mut mbedtls_ccm_context,
        tag: *mut crate::c_types::c_uchar,
        tag_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          The CCM checkup routine.\n\n \\return         \\c 0 on success.\n \\return         \\c 1 on failure."]
    pub fn mbedtls_ccm_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_poly1305_context {
    pub private_r: [u32; 4usize],
    pub private_s: [u32; 4usize],
    pub private_acc: [u32; 5usize],
    pub private_queue: [u8; 16usize],
    pub private_queue_len: usize,
}
extern "C" {
    #[doc = " \\brief           This function initializes the specified Poly1305 context.\n\n                  It must be the first API called before using\n                  the context.\n\n                  It is usually followed by a call to\n                  \\c mbedtls_poly1305_starts(), then one or more calls to\n                  \\c mbedtls_poly1305_update(), then one call to\n                  \\c mbedtls_poly1305_finish(), then finally\n                  \\c mbedtls_poly1305_free().\n\n \\param ctx       The Poly1305 context to initialize. This must\n                  not be \\c NULL."]
    pub fn mbedtls_poly1305_init(ctx: *mut mbedtls_poly1305_context);
}
extern "C" {
    #[doc = " \\brief           This function releases and clears the specified\n                  Poly1305 context.\n\n \\param ctx       The Poly1305 context to clear. This may be \\c NULL, in which\n                  case this function is a no-op. If it is not \\c NULL, it must\n                  point to an initialized Poly1305 context."]
    pub fn mbedtls_poly1305_free(ctx: *mut mbedtls_poly1305_context);
}
extern "C" {
    #[doc = " \\brief           This function sets the one-time authentication key.\n\n \\warning         The key must be unique and unpredictable for each\n                  invocation of Poly1305.\n\n \\param ctx       The Poly1305 context to which the key should be bound.\n                  This must be initialized.\n \\param key       The buffer containing the \\c 32 Byte (\\c 256 Bit) key.\n\n \\return          \\c 0 on success.\n \\return          A negative error code on failure."]
    pub fn mbedtls_poly1305_starts(
        ctx: *mut mbedtls_poly1305_context,
        key: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This functions feeds an input buffer into an ongoing\n                  Poly1305 computation.\n\n                  It is called between \\c mbedtls_cipher_poly1305_starts() and\n                  \\c mbedtls_cipher_poly1305_finish().\n                  It can be called repeatedly to process a stream of data.\n\n \\param ctx       The Poly1305 context to use for the Poly1305 operation.\n                  This must be initialized and bound to a key.\n \\param ilen      The length of the input data in Bytes.\n                  Any value is accepted.\n \\param input     The buffer holding the input data.\n                  This pointer can be \\c NULL if `ilen == 0`.\n\n \\return          \\c 0 on success.\n \\return          A negative error code on failure."]
    pub fn mbedtls_poly1305_update(
        ctx: *mut mbedtls_poly1305_context,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function generates the Poly1305 Message\n                  Authentication Code (MAC).\n\n \\param ctx       The Poly1305 context to use for the Poly1305 operation.\n                  This must be initialized and bound to a key.\n \\param mac       The buffer to where the MAC is written. This must\n                  be a writable buffer of length \\c 16 Bytes.\n\n \\return          \\c 0 on success.\n \\return          A negative error code on failure."]
    pub fn mbedtls_poly1305_finish(
        ctx: *mut mbedtls_poly1305_context,
        mac: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function calculates the Poly1305 MAC of the input\n                  buffer with the provided key.\n\n \\warning         The key must be unique and unpredictable for each\n                  invocation of Poly1305.\n\n \\param key       The buffer containing the \\c 32 Byte (\\c 256 Bit) key.\n \\param ilen      The length of the input data in Bytes.\n                  Any value is accepted.\n \\param input     The buffer holding the input data.\n                  This pointer can be \\c NULL if `ilen == 0`.\n \\param mac       The buffer to where the MAC is written. This must be\n                  a writable buffer of length \\c 16 Bytes.\n\n \\return          \\c 0 on success.\n \\return          A negative error code on failure."]
    pub fn mbedtls_poly1305_mac(
        key: *const crate::c_types::c_uchar,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
        mac: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           The Poly1305 checkup routine.\n\n \\return          \\c 0 on success.\n \\return          \\c 1 on failure."]
    pub fn mbedtls_poly1305_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[doc = "< The mode value for performing encryption."]
pub const mbedtls_chachapoly_mode_t_MBEDTLS_CHACHAPOLY_ENCRYPT: mbedtls_chachapoly_mode_t = 0;
#[doc = "< The mode value for performing decryption."]
pub const mbedtls_chachapoly_mode_t_MBEDTLS_CHACHAPOLY_DECRYPT: mbedtls_chachapoly_mode_t = 1;
pub type mbedtls_chachapoly_mode_t = crate::c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_chacha20_context {
    pub private_state: [u32; 16usize],
    pub private_keystream8: [u8; 64usize],
    pub private_keystream_bytes_used: usize,
}
extern "C" {
    #[doc = " \\brief           This function initializes the specified ChaCha20 context.\n\n                  It must be the first API called before using\n                  the context.\n\n                  It is usually followed by calls to\n                  \\c mbedtls_chacha20_setkey() and\n                  \\c mbedtls_chacha20_starts(), then one or more calls to\n                  to \\c mbedtls_chacha20_update(), and finally to\n                  \\c mbedtls_chacha20_free().\n\n \\param ctx       The ChaCha20 context to initialize.\n                  This must not be \\c NULL."]
    pub fn mbedtls_chacha20_init(ctx: *mut mbedtls_chacha20_context);
}
extern "C" {
    #[doc = " \\brief           This function releases and clears the specified\n                  ChaCha20 context.\n\n \\param ctx       The ChaCha20 context to clear. This may be \\c NULL,\n                  in which case this function is a no-op. If it is not\n                  \\c NULL, it must point to an initialized context.\n"]
    pub fn mbedtls_chacha20_free(ctx: *mut mbedtls_chacha20_context);
}
extern "C" {
    #[doc = " \\brief           This function sets the encryption/decryption key.\n\n \\note            After using this function, you must also call\n                  \\c mbedtls_chacha20_starts() to set a nonce before you\n                  start encrypting/decrypting data with\n                  \\c mbedtls_chacha_update().\n\n \\param ctx       The ChaCha20 context to which the key should be bound.\n                  It must be initialized.\n \\param key       The encryption/decryption key. This must be \\c 32 Bytes\n                  in length.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CHACHA20_BAD_INPUT_DATA if ctx or key is NULL."]
    pub fn mbedtls_chacha20_setkey(
        ctx: *mut mbedtls_chacha20_context,
        key: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets the nonce and initial counter value.\n\n \\note            A ChaCha20 context can be re-used with the same key by\n                  calling this function to change the nonce.\n\n \\warning         You must never use the same nonce twice with the same key.\n                  This would void any confidentiality guarantees for the\n                  messages encrypted with the same nonce and key.\n\n \\param ctx       The ChaCha20 context to which the nonce should be bound.\n                  It must be initialized and bound to a key.\n \\param nonce     The nonce. This must be \\c 12 Bytes in size.\n \\param counter   The initial counter value. This is usually \\c 0.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CHACHA20_BAD_INPUT_DATA if ctx or nonce is\n                  NULL."]
    pub fn mbedtls_chacha20_starts(
        ctx: *mut mbedtls_chacha20_context,
        nonce: *const crate::c_types::c_uchar,
        counter: u32,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function encrypts or decrypts data.\n\n                  Since ChaCha20 is a stream cipher, the same operation is\n                  used for encrypting and decrypting data.\n\n \\note            The \\p input and \\p output pointers must either be equal or\n                  point to non-overlapping buffers.\n\n \\note            \\c mbedtls_chacha20_setkey() and\n                  \\c mbedtls_chacha20_starts() must be called at least once\n                  to setup the context before this function can be called.\n\n \\note            This function can be called multiple times in a row in\n                  order to encrypt of decrypt data piecewise with the same\n                  key and nonce.\n\n \\param ctx       The ChaCha20 context to use for encryption or decryption.\n                  It must be initialized and bound to a key and nonce.\n \\param size      The length of the input data in Bytes.\n \\param input     The buffer holding the input data.\n                  This pointer can be \\c NULL if `size == 0`.\n \\param output    The buffer holding the output data.\n                  This must be able to hold \\p size Bytes.\n                  This pointer can be \\c NULL if `size == 0`.\n\n \\return          \\c 0 on success.\n \\return          A negative error code on failure."]
    pub fn mbedtls_chacha20_update(
        ctx: *mut mbedtls_chacha20_context,
        size: usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function encrypts or decrypts data with ChaCha20 and\n                  the given key and nonce.\n\n                  Since ChaCha20 is a stream cipher, the same operation is\n                  used for encrypting and decrypting data.\n\n \\warning         You must never use the same (key, nonce) pair more than\n                  once. This would void any confidentiality guarantees for\n                  the messages encrypted with the same nonce and key.\n\n \\note            The \\p input and \\p output pointers must either be equal or\n                  point to non-overlapping buffers.\n\n \\param key       The encryption/decryption key.\n                  This must be \\c 32 Bytes in length.\n \\param nonce     The nonce. This must be \\c 12 Bytes in size.\n \\param counter   The initial counter value. This is usually \\c 0.\n \\param size      The length of the input data in Bytes.\n \\param input     The buffer holding the input data.\n                  This pointer can be \\c NULL if `size == 0`.\n \\param output    The buffer holding the output data.\n                  This must be able to hold \\p size Bytes.\n                  This pointer can be \\c NULL if `size == 0`.\n\n \\return          \\c 0 on success.\n \\return          A negative error code on failure."]
    pub fn mbedtls_chacha20_crypt(
        key: *const crate::c_types::c_uchar,
        nonce: *const crate::c_types::c_uchar,
        counter: u32,
        size: usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           The ChaCha20 checkup routine.\n\n \\return          \\c 0 on success.\n \\return          \\c 1 on failure."]
    pub fn mbedtls_chacha20_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_chachapoly_context {
    pub private_chacha20_ctx: mbedtls_chacha20_context,
    pub private_poly1305_ctx: mbedtls_poly1305_context,
    pub private_aad_len: u64,
    pub private_ciphertext_len: u64,
    pub private_state: crate::c_types::c_int,
    pub private_mode: mbedtls_chachapoly_mode_t,
}
extern "C" {
    #[doc = " \\brief           This function initializes the specified ChaCha20-Poly1305 context.\n\n                  It must be the first API called before using\n                  the context. It must be followed by a call to\n                  \\c mbedtls_chachapoly_setkey() before any operation can be\n                  done, and to \\c mbedtls_chachapoly_free() once all\n                  operations with that context have been finished.\n\n                  In order to encrypt or decrypt full messages at once, for\n                  each message you should make a single call to\n                  \\c mbedtls_chachapoly_crypt_and_tag() or\n                  \\c mbedtls_chachapoly_auth_decrypt().\n\n                  In order to encrypt messages piecewise, for each\n                  message you should make a call to\n                  \\c mbedtls_chachapoly_starts(), then 0 or more calls to\n                  \\c mbedtls_chachapoly_update_aad(), then 0 or more calls to\n                  \\c mbedtls_chachapoly_update(), then one call to\n                  \\c mbedtls_chachapoly_finish().\n\n \\warning         Decryption with the piecewise API is discouraged! Always\n                  use \\c mbedtls_chachapoly_auth_decrypt() when possible!\n\n                  If however this is not possible because the data is too\n                  large to fit in memory, you need to:\n\n                  - call \\c mbedtls_chachapoly_starts() and (if needed)\n                  \\c mbedtls_chachapoly_update_aad() as above,\n                  - call \\c mbedtls_chachapoly_update() multiple times and\n                  ensure its output (the plaintext) is NOT used in any other\n                  way than placing it in temporary storage at this point,\n                  - call \\c mbedtls_chachapoly_finish() to compute the\n                  authentication tag and compared it in constant time to the\n                  tag received with the ciphertext.\n\n                  If the tags are not equal, you must immediately discard\n                  all previous outputs of \\c mbedtls_chachapoly_update(),\n                  otherwise you can now safely use the plaintext.\n\n \\param ctx       The ChachaPoly context to initialize. Must not be \\c NULL."]
    pub fn mbedtls_chachapoly_init(ctx: *mut mbedtls_chachapoly_context);
}
extern "C" {
    #[doc = " \\brief           This function releases and clears the specified\n                  ChaCha20-Poly1305 context.\n\n \\param ctx       The ChachaPoly context to clear. This may be \\c NULL, in which\n                  case this function is a no-op."]
    pub fn mbedtls_chachapoly_free(ctx: *mut mbedtls_chachapoly_context);
}
extern "C" {
    #[doc = " \\brief           This function sets the ChaCha20-Poly1305\n                  symmetric encryption key.\n\n \\param ctx       The ChaCha20-Poly1305 context to which the key should be\n                  bound. This must be initialized.\n \\param key       The \\c 256 Bit (\\c 32 Bytes) key.\n\n \\return          \\c 0 on success.\n \\return          A negative error code on failure."]
    pub fn mbedtls_chachapoly_setkey(
        ctx: *mut mbedtls_chachapoly_context,
        key: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function starts a ChaCha20-Poly1305 encryption or\n                  decryption operation.\n\n \\warning         You must never use the same nonce twice with the same key.\n                  This would void any confidentiality and authenticity\n                  guarantees for the messages encrypted with the same nonce\n                  and key.\n\n \\note            If the context is being used for AAD only (no data to\n                  encrypt or decrypt) then \\p mode can be set to any value.\n\n \\warning         Decryption with the piecewise API is discouraged, see the\n                  warning on \\c mbedtls_chachapoly_init().\n\n \\param ctx       The ChaCha20-Poly1305 context. This must be initialized\n                  and bound to a key.\n \\param nonce     The nonce/IV to use for the message.\n                  This must be a readable buffer of length \\c 12 Bytes.\n \\param mode      The operation to perform: #MBEDTLS_CHACHAPOLY_ENCRYPT or\n                  #MBEDTLS_CHACHAPOLY_DECRYPT (discouraged, see warning).\n\n \\return          \\c 0 on success.\n \\return          A negative error code on failure."]
    pub fn mbedtls_chachapoly_starts(
        ctx: *mut mbedtls_chachapoly_context,
        nonce: *const crate::c_types::c_uchar,
        mode: mbedtls_chachapoly_mode_t,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function feeds additional data to be authenticated\n                  into an ongoing ChaCha20-Poly1305 operation.\n\n                  The Additional Authenticated Data (AAD), also called\n                  Associated Data (AD) is only authenticated but not\n                  encrypted nor included in the encrypted output. It is\n                  usually transmitted separately from the ciphertext or\n                  computed locally by each party.\n\n \\note            This function is called before data is encrypted/decrypted.\n                  I.e. call this function to process the AAD before calling\n                  \\c mbedtls_chachapoly_update().\n\n                  You may call this function multiple times to process\n                  an arbitrary amount of AAD. It is permitted to call\n                  this function 0 times, if no AAD is used.\n\n                  This function cannot be called any more if data has\n                  been processed by \\c mbedtls_chachapoly_update(),\n                  or if the context has been finished.\n\n \\warning         Decryption with the piecewise API is discouraged, see the\n                  warning on \\c mbedtls_chachapoly_init().\n\n \\param ctx       The ChaCha20-Poly1305 context. This must be initialized\n                  and bound to a key.\n \\param aad_len   The length in Bytes of the AAD. The length has no\n                  restrictions.\n \\param aad       Buffer containing the AAD.\n                  This pointer can be \\c NULL if `aad_len == 0`.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_POLY1305_BAD_INPUT_DATA\n                  if \\p ctx or \\p aad are NULL.\n \\return          #MBEDTLS_ERR_CHACHAPOLY_BAD_STATE\n                  if the operations has not been started or has been\n                  finished, or if the AAD has been finished."]
    pub fn mbedtls_chachapoly_update_aad(
        ctx: *mut mbedtls_chachapoly_context,
        aad: *const crate::c_types::c_uchar,
        aad_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Thus function feeds data to be encrypted or decrypted\n                  into an on-going ChaCha20-Poly1305\n                  operation.\n\n                  The direction (encryption or decryption) depends on the\n                  mode that was given when calling\n                  \\c mbedtls_chachapoly_starts().\n\n                  You may call this function multiple times to process\n                  an arbitrary amount of data. It is permitted to call\n                  this function 0 times, if no data is to be encrypted\n                  or decrypted.\n\n \\warning         Decryption with the piecewise API is discouraged, see the\n                  warning on \\c mbedtls_chachapoly_init().\n\n \\param ctx       The ChaCha20-Poly1305 context to use. This must be initialized.\n \\param len       The length (in bytes) of the data to encrypt or decrypt.\n \\param input     The buffer containing the data to encrypt or decrypt.\n                  This pointer can be \\c NULL if `len == 0`.\n \\param output    The buffer to where the encrypted or decrypted data is\n                  written. This must be able to hold \\p len bytes.\n                  This pointer can be \\c NULL if `len == 0`.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CHACHAPOLY_BAD_STATE\n                  if the operation has not been started or has been\n                  finished.\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_chachapoly_update(
        ctx: *mut mbedtls_chachapoly_context,
        len: usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function finished the ChaCha20-Poly1305 operation and\n                  generates the MAC (authentication tag).\n\n \\param ctx       The ChaCha20-Poly1305 context to use. This must be initialized.\n \\param mac       The buffer to where the 128-bit (16 bytes) MAC is written.\n\n \\warning         Decryption with the piecewise API is discouraged, see the\n                  warning on \\c mbedtls_chachapoly_init().\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CHACHAPOLY_BAD_STATE\n                  if the operation has not been started or has been\n                  finished.\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_chachapoly_finish(
        ctx: *mut mbedtls_chachapoly_context,
        mac: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs a complete ChaCha20-Poly1305\n                  authenticated encryption with the previously-set key.\n\n \\note            Before using this function, you must set the key with\n                  \\c mbedtls_chachapoly_setkey().\n\n \\warning         You must never use the same nonce twice with the same key.\n                  This would void any confidentiality and authenticity\n                  guarantees for the messages encrypted with the same nonce\n                  and key.\n\n \\param ctx       The ChaCha20-Poly1305 context to use (holds the key).\n                  This must be initialized.\n \\param length    The length (in bytes) of the data to encrypt or decrypt.\n \\param nonce     The 96-bit (12 bytes) nonce/IV to use.\n \\param aad       The buffer containing the additional authenticated\n                  data (AAD). This pointer can be \\c NULL if `aad_len == 0`.\n \\param aad_len   The length (in bytes) of the AAD data to process.\n \\param input     The buffer containing the data to encrypt or decrypt.\n                  This pointer can be \\c NULL if `ilen == 0`.\n \\param output    The buffer to where the encrypted or decrypted data\n                  is written. This pointer can be \\c NULL if `ilen == 0`.\n \\param tag       The buffer to where the computed 128-bit (16 bytes) MAC\n                  is written. This must not be \\c NULL.\n\n \\return          \\c 0 on success.\n \\return          A negative error code on failure."]
    pub fn mbedtls_chachapoly_encrypt_and_tag(
        ctx: *mut mbedtls_chachapoly_context,
        length: usize,
        nonce: *const crate::c_types::c_uchar,
        aad: *const crate::c_types::c_uchar,
        aad_len: usize,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
        tag: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function performs a complete ChaCha20-Poly1305\n                  authenticated decryption with the previously-set key.\n\n \\note            Before using this function, you must set the key with\n                  \\c mbedtls_chachapoly_setkey().\n\n \\param ctx       The ChaCha20-Poly1305 context to use (holds the key).\n \\param length    The length (in Bytes) of the data to decrypt.\n \\param nonce     The \\c 96 Bit (\\c 12 bytes) nonce/IV to use.\n \\param aad       The buffer containing the additional authenticated data (AAD).\n                  This pointer can be \\c NULL if `aad_len == 0`.\n \\param aad_len   The length (in bytes) of the AAD data to process.\n \\param tag       The buffer holding the authentication tag.\n                  This must be a readable buffer of length \\c 16 Bytes.\n \\param input     The buffer containing the data to decrypt.\n                  This pointer can be \\c NULL if `ilen == 0`.\n \\param output    The buffer to where the decrypted data is written.\n                  This pointer can be \\c NULL if `ilen == 0`.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CHACHAPOLY_AUTH_FAILED\n                  if the data was not authentic.\n \\return          Another negative error code on other kinds of failure."]
    pub fn mbedtls_chachapoly_auth_decrypt(
        ctx: *mut mbedtls_chachapoly_context,
        length: usize,
        nonce: *const crate::c_types::c_uchar,
        aad: *const crate::c_types::c_uchar,
        aad_len: usize,
        tag: *const crate::c_types::c_uchar,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           The ChaCha20-Poly1305 checkup routine.\n\n \\return          \\c 0 on success.\n \\return          \\c 1 on failure."]
    pub fn mbedtls_chachapoly_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
pub const psa_encrypt_or_decrypt_t_PSA_CRYPTO_DRIVER_DECRYPT: psa_encrypt_or_decrypt_t = 0;
pub const psa_encrypt_or_decrypt_t_PSA_CRYPTO_DRIVER_ENCRYPT: psa_encrypt_or_decrypt_t = 1;
#[doc = " For encrypt-decrypt functions, whether the operation is an encryption\n or a decryption."]
pub type psa_encrypt_or_decrypt_t = crate::c_types::c_uint;
#[doc = " \\brief          MD5 context structure\n\n \\warning        MD5 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_md5_context {
    pub private_total: [u32; 2usize],
    pub private_state: [u32; 4usize],
    pub private_buffer: [crate::c_types::c_uchar; 64usize],
}
extern "C" {
    #[doc = " \\brief          Initialize MD5 context\n\n \\param ctx      MD5 context to be initialized\n\n \\warning        MD5 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n"]
    pub fn mbedtls_md5_init(ctx: *mut mbedtls_md5_context);
}
extern "C" {
    #[doc = " \\brief          Clear MD5 context\n\n \\param ctx      MD5 context to be cleared\n\n \\warning        MD5 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n"]
    pub fn mbedtls_md5_free(ctx: *mut mbedtls_md5_context);
}
extern "C" {
    #[doc = " \\brief          Clone (the state of) an MD5 context\n\n \\param dst      The destination context\n \\param src      The context to be cloned\n\n \\warning        MD5 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n"]
    pub fn mbedtls_md5_clone(dst: *mut mbedtls_md5_context, src: *const mbedtls_md5_context);
}
extern "C" {
    #[doc = " \\brief          MD5 context setup\n\n \\param ctx      context to be initialized\n\n \\return         0 if successful\n\n \\warning        MD5 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n"]
    pub fn mbedtls_md5_starts(ctx: *mut mbedtls_md5_context) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          MD5 process buffer\n\n \\param ctx      MD5 context\n \\param input    buffer holding the data\n \\param ilen     length of the input data\n\n \\return         0 if successful\n\n \\warning        MD5 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n"]
    pub fn mbedtls_md5_update(
        ctx: *mut mbedtls_md5_context,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          MD5 final digest\n\n \\param ctx      MD5 context\n \\param output   MD5 checksum result\n\n \\return         0 if successful\n\n \\warning        MD5 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n"]
    pub fn mbedtls_md5_finish(
        ctx: *mut mbedtls_md5_context,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          MD5 process data block (internal use only)\n\n \\param ctx      MD5 context\n \\param data     buffer holding one block of data\n\n \\return         0 if successful\n\n \\warning        MD5 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n"]
    pub fn mbedtls_internal_md5_process(
        ctx: *mut mbedtls_md5_context,
        data: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Output = MD5( input buffer )\n\n \\param input    buffer holding the data\n \\param ilen     length of the input data\n \\param output   MD5 checksum result\n\n \\return         0 if successful\n\n \\warning        MD5 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n"]
    pub fn mbedtls_md5(
        input: *const crate::c_types::c_uchar,
        ilen: usize,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Checkup routine\n\n \\return         0 if successful, or 1 if the test failed\n\n \\warning        MD5 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n"]
    pub fn mbedtls_md5_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[doc = " \\brief          RIPEMD-160 context structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ripemd160_context {
    pub private_total: [u32; 2usize],
    pub private_state: [u32; 5usize],
    pub private_buffer: [crate::c_types::c_uchar; 64usize],
}
extern "C" {
    #[doc = " \\brief          Initialize RIPEMD-160 context\n\n \\param ctx      RIPEMD-160 context to be initialized"]
    pub fn mbedtls_ripemd160_init(ctx: *mut mbedtls_ripemd160_context);
}
extern "C" {
    #[doc = " \\brief          Clear RIPEMD-160 context\n\n \\param ctx      RIPEMD-160 context to be cleared"]
    pub fn mbedtls_ripemd160_free(ctx: *mut mbedtls_ripemd160_context);
}
extern "C" {
    #[doc = " \\brief          Clone (the state of) a RIPEMD-160 context\n\n \\param dst      The destination context\n \\param src      The context to be cloned"]
    pub fn mbedtls_ripemd160_clone(
        dst: *mut mbedtls_ripemd160_context,
        src: *const mbedtls_ripemd160_context,
    );
}
extern "C" {
    #[doc = " \\brief          RIPEMD-160 context setup\n\n \\param ctx      context to be initialized\n\n \\return         0 if successful"]
    pub fn mbedtls_ripemd160_starts(ctx: *mut mbedtls_ripemd160_context) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          RIPEMD-160 process buffer\n\n \\param ctx      RIPEMD-160 context\n \\param input    buffer holding the data\n \\param ilen     length of the input data\n\n \\return         0 if successful"]
    pub fn mbedtls_ripemd160_update(
        ctx: *mut mbedtls_ripemd160_context,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          RIPEMD-160 final digest\n\n \\param ctx      RIPEMD-160 context\n \\param output   RIPEMD-160 checksum result\n\n \\return         0 if successful"]
    pub fn mbedtls_ripemd160_finish(
        ctx: *mut mbedtls_ripemd160_context,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          RIPEMD-160 process data block (internal use only)\n\n \\param ctx      RIPEMD-160 context\n \\param data     buffer holding one block of data\n\n \\return         0 if successful"]
    pub fn mbedtls_internal_ripemd160_process(
        ctx: *mut mbedtls_ripemd160_context,
        data: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Output = RIPEMD-160( input buffer )\n\n \\param input    buffer holding the data\n \\param ilen     length of the input data\n \\param output   RIPEMD-160 checksum result\n\n \\return         0 if successful"]
    pub fn mbedtls_ripemd160(
        input: *const crate::c_types::c_uchar,
        ilen: usize,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Checkup routine\n\n \\return         0 if successful, or 1 if the test failed"]
    pub fn mbedtls_ripemd160_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[doc = " \\brief          The SHA-1 context structure.\n\n \\warning        SHA-1 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_sha1_context {
    pub private_total: [u32; 2usize],
    pub private_state: [u32; 5usize],
    pub private_buffer: [crate::c_types::c_uchar; 64usize],
}
extern "C" {
    #[doc = " \\brief          This function initializes a SHA-1 context.\n\n \\warning        SHA-1 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n\n \\param ctx      The SHA-1 context to initialize.\n                 This must not be \\c NULL.\n"]
    pub fn mbedtls_sha1_init(ctx: *mut mbedtls_sha1_context);
}
extern "C" {
    #[doc = " \\brief          This function clears a SHA-1 context.\n\n \\warning        SHA-1 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n\n \\param ctx      The SHA-1 context to clear. This may be \\c NULL,\n                 in which case this function does nothing. If it is\n                 not \\c NULL, it must point to an initialized\n                 SHA-1 context.\n"]
    pub fn mbedtls_sha1_free(ctx: *mut mbedtls_sha1_context);
}
extern "C" {
    #[doc = " \\brief          This function clones the state of a SHA-1 context.\n\n \\warning        SHA-1 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n\n \\param dst      The SHA-1 context to clone to. This must be initialized.\n \\param src      The SHA-1 context to clone from. This must be initialized.\n"]
    pub fn mbedtls_sha1_clone(dst: *mut mbedtls_sha1_context, src: *const mbedtls_sha1_context);
}
extern "C" {
    #[doc = " \\brief          This function starts a SHA-1 checksum calculation.\n\n \\warning        SHA-1 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n\n \\param ctx      The SHA-1 context to initialize. This must be initialized.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure.\n"]
    pub fn mbedtls_sha1_starts(ctx: *mut mbedtls_sha1_context) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function feeds an input buffer into an ongoing SHA-1\n                 checksum calculation.\n\n \\warning        SHA-1 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n\n \\param ctx      The SHA-1 context. This must be initialized\n                 and have a hash operation started.\n \\param input    The buffer holding the input data.\n                 This must be a readable buffer of length \\p ilen Bytes.\n \\param ilen     The length of the input data \\p input in Bytes.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
    pub fn mbedtls_sha1_update(
        ctx: *mut mbedtls_sha1_context,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function finishes the SHA-1 operation, and writes\n                 the result to the output buffer.\n\n \\warning        SHA-1 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n\n \\param ctx      The SHA-1 context to use. This must be initialized and\n                 have a hash operation started.\n \\param output   The SHA-1 checksum result. This must be a writable\n                 buffer of length \\c 20 Bytes.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
    pub fn mbedtls_sha1_finish(
        ctx: *mut mbedtls_sha1_context,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          SHA-1 process data block (internal use only).\n\n \\warning        SHA-1 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n\n \\param ctx      The SHA-1 context to use. This must be initialized.\n \\param data     The data block being processed. This must be a\n                 readable buffer of length \\c 64 Bytes.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure.\n"]
    pub fn mbedtls_internal_sha1_process(
        ctx: *mut mbedtls_sha1_context,
        data: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function calculates the SHA-1 checksum of a buffer.\n\n                 The function allocates the context, performs the\n                 calculation, and frees the context.\n\n                 The SHA-1 result is calculated as\n                 output = SHA-1(input buffer).\n\n \\warning        SHA-1 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n\n \\param input    The buffer holding the input data.\n                 This must be a readable buffer of length \\p ilen Bytes.\n \\param ilen     The length of the input data \\p input in Bytes.\n \\param output   The SHA-1 checksum result.\n                 This must be a writable buffer of length \\c 20 Bytes.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure.\n"]
    pub fn mbedtls_sha1(
        input: *const crate::c_types::c_uchar,
        ilen: usize,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          The SHA-1 checkup routine.\n\n \\warning        SHA-1 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n\n \\return         \\c 0 on success.\n \\return         \\c 1 on failure.\n"]
    pub fn mbedtls_sha1_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[doc = " \\brief          The SHA-256 context structure.\n\n                 The structure is used both for SHA-256 and for SHA-224\n                 checksum calculations. The choice between these two is\n                 made in the call to mbedtls_sha256_starts()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_sha256_context {
    pub private_total: [u32; 2usize],
    pub private_state: [u32; 8usize],
    pub private_buffer: [crate::c_types::c_uchar; 64usize],
    pub private_is224: crate::c_types::c_int,
}
extern "C" {
    #[doc = " \\brief          This function initializes a SHA-256 context.\n\n \\param ctx      The SHA-256 context to initialize. This must not be \\c NULL."]
    pub fn mbedtls_sha256_init(ctx: *mut mbedtls_sha256_context);
}
extern "C" {
    #[doc = " \\brief          This function clears a SHA-256 context.\n\n \\param ctx      The SHA-256 context to clear. This may be \\c NULL, in which\n                 case this function returns immediately. If it is not \\c NULL,\n                 it must point to an initialized SHA-256 context."]
    pub fn mbedtls_sha256_free(ctx: *mut mbedtls_sha256_context);
}
extern "C" {
    #[doc = " \\brief          This function clones the state of a SHA-256 context.\n\n \\param dst      The destination context. This must be initialized.\n \\param src      The context to clone. This must be initialized."]
    pub fn mbedtls_sha256_clone(
        dst: *mut mbedtls_sha256_context,
        src: *const mbedtls_sha256_context,
    );
}
extern "C" {
    #[doc = " \\brief          This function starts a SHA-224 or SHA-256 checksum\n                 calculation.\n\n \\param ctx      The context to use. This must be initialized.\n \\param is224    This determines which function to use. This must be\n                 either \\c 0 for SHA-256, or \\c 1 for SHA-224.\n\n \\note           is224 must be defined accordingly to the enabled\n                 MBEDTLS_SHA224_C/MBEDTLS_SHA256_C symbols otherwise the\n                 function will return #MBEDTLS_ERR_SHA512_BAD_INPUT_DATA.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
    pub fn mbedtls_sha256_starts(
        ctx: *mut mbedtls_sha256_context,
        is224: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function feeds an input buffer into an ongoing\n                 SHA-256 checksum calculation.\n\n \\param ctx      The SHA-256 context. This must be initialized\n                 and have a hash operation started.\n \\param input    The buffer holding the data. This must be a readable\n                 buffer of length \\p ilen Bytes.\n \\param ilen     The length of the input data in Bytes.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
    pub fn mbedtls_sha256_update(
        ctx: *mut mbedtls_sha256_context,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function finishes the SHA-256 operation, and writes\n                 the result to the output buffer.\n\n \\param ctx      The SHA-256 context. This must be initialized\n                 and have a hash operation started.\n \\param output   The SHA-224 or SHA-256 checksum result.\n                 This must be a writable buffer of length \\c 32 bytes\n                 for SHA-256, \\c 28 bytes for SHA-224.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
    pub fn mbedtls_sha256_finish(
        ctx: *mut mbedtls_sha256_context,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function processes a single data block within\n                 the ongoing SHA-256 computation. This function is for\n                 internal use only.\n\n \\param ctx      The SHA-256 context. This must be initialized.\n \\param data     The buffer holding one block of data. This must\n                 be a readable buffer of length \\c 64 Bytes.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
    pub fn mbedtls_internal_sha256_process(
        ctx: *mut mbedtls_sha256_context,
        data: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function calculates the SHA-224 or SHA-256\n                 checksum of a buffer.\n\n                 The function allocates the context, performs the\n                 calculation, and frees the context.\n\n                 The SHA-256 result is calculated as\n                 output = SHA-256(input buffer).\n\n \\param input    The buffer holding the data. This must be a readable\n                 buffer of length \\p ilen Bytes.\n \\param ilen     The length of the input data in Bytes.\n \\param output   The SHA-224 or SHA-256 checksum result.\n                 This must be a writable buffer of length \\c 32 bytes\n                 for SHA-256, \\c 28 bytes for SHA-224.\n \\param is224    Determines which function to use. This must be\n                 either \\c 0 for SHA-256, or \\c 1 for SHA-224.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
    pub fn mbedtls_sha256(
        input: *const crate::c_types::c_uchar,
        ilen: usize,
        output: *mut crate::c_types::c_uchar,
        is224: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          The SHA-224 checkup routine.\n\n \\return         \\c 0 on success.\n \\return         \\c 1 on failure."]
    pub fn mbedtls_sha224_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          The SHA-256 checkup routine.\n\n \\return         \\c 0 on success.\n \\return         \\c 1 on failure."]
    pub fn mbedtls_sha256_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[doc = " \\brief          The SHA-512 context structure.\n\n                 The structure is used both for SHA-384 and for SHA-512\n                 checksum calculations. The choice between these two is\n                 made in the call to mbedtls_sha512_starts()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_sha512_context {
    pub private_total: [u64; 2usize],
    pub private_state: [u64; 8usize],
    pub private_buffer: [crate::c_types::c_uchar; 128usize],
    pub private_is384: crate::c_types::c_int,
}
extern "C" {
    #[doc = " \\brief          This function initializes a SHA-512 context.\n\n \\param ctx      The SHA-512 context to initialize. This must\n                 not be \\c NULL."]
    pub fn mbedtls_sha512_init(ctx: *mut mbedtls_sha512_context);
}
extern "C" {
    #[doc = " \\brief          This function clears a SHA-512 context.\n\n \\param ctx      The SHA-512 context to clear. This may be \\c NULL,\n                 in which case this function does nothing. If it\n                 is not \\c NULL, it must point to an initialized\n                 SHA-512 context."]
    pub fn mbedtls_sha512_free(ctx: *mut mbedtls_sha512_context);
}
extern "C" {
    #[doc = " \\brief          This function clones the state of a SHA-512 context.\n\n \\param dst      The destination context. This must be initialized.\n \\param src      The context to clone. This must be initialized."]
    pub fn mbedtls_sha512_clone(
        dst: *mut mbedtls_sha512_context,
        src: *const mbedtls_sha512_context,
    );
}
extern "C" {
    #[doc = " \\brief          This function starts a SHA-384 or SHA-512 checksum\n                 calculation.\n\n \\param ctx      The SHA-512 context to use. This must be initialized.\n \\param is384    Determines which function to use. This must be\n                 either \\c 0 for SHA-512, or \\c 1 for SHA-384.\n\n \\note           is384 must be defined accordingly to the enabled\n                 MBEDTLS_SHA384_C/MBEDTLS_SHA512_C symbols otherwise the\n                 function will return #MBEDTLS_ERR_SHA512_BAD_INPUT_DATA.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
    pub fn mbedtls_sha512_starts(
        ctx: *mut mbedtls_sha512_context,
        is384: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function feeds an input buffer into an ongoing\n                 SHA-512 checksum calculation.\n\n \\param ctx      The SHA-512 context. This must be initialized\n                 and have a hash operation started.\n \\param input    The buffer holding the input data. This must\n                 be a readable buffer of length \\p ilen Bytes.\n \\param ilen     The length of the input data in Bytes.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
    pub fn mbedtls_sha512_update(
        ctx: *mut mbedtls_sha512_context,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function finishes the SHA-512 operation, and writes\n                 the result to the output buffer.\n\n \\param ctx      The SHA-512 context. This must be initialized\n                 and have a hash operation started.\n \\param output   The SHA-384 or SHA-512 checksum result.\n                 This must be a writable buffer of length \\c 64 bytes\n                 for SHA-512, \\c 48 bytes for SHA-384.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
    pub fn mbedtls_sha512_finish(
        ctx: *mut mbedtls_sha512_context,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function processes a single data block within\n                 the ongoing SHA-512 computation.\n                 This function is for internal use only.\n\n \\param ctx      The SHA-512 context. This must be initialized.\n \\param data     The buffer holding one block of data. This\n                 must be a readable buffer of length \\c 128 Bytes.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
    pub fn mbedtls_internal_sha512_process(
        ctx: *mut mbedtls_sha512_context,
        data: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function calculates the SHA-512 or SHA-384\n                 checksum of a buffer.\n\n                 The function allocates the context, performs the\n                 calculation, and frees the context.\n\n                 The SHA-512 result is calculated as\n                 output = SHA-512(input buffer).\n\n \\param input    The buffer holding the input data. This must be\n                 a readable buffer of length \\p ilen Bytes.\n \\param ilen     The length of the input data in Bytes.\n \\param output   The SHA-384 or SHA-512 checksum result.\n                 This must be a writable buffer of length \\c 64 bytes\n                 for SHA-512, \\c 48 bytes for SHA-384.\n \\param is384    Determines which function to use. This must be either\n                 \\c 0 for SHA-512, or \\c 1 for SHA-384.\n\n \\note           is384 must be defined accordingly with the supported\n                 symbols in the config file. If:\n                 - is384 is 0, but \\c MBEDTLS_SHA384_C is not defined, or\n                 - is384 is 1, but \\c MBEDTLS_SHA512_C is not defined\n                 then the function will return\n                 #MBEDTLS_ERR_SHA512_BAD_INPUT_DATA.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
    pub fn mbedtls_sha512(
        input: *const crate::c_types::c_uchar,
        ilen: usize,
        output: *mut crate::c_types::c_uchar,
        is384: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          The SHA-384 checkup routine.\n\n \\return         \\c 0 on success.\n \\return         \\c 1 on failure."]
    pub fn mbedtls_sha384_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          The SHA-512 checkup routine.\n\n \\return         \\c 0 on success.\n \\return         \\c 1 on failure."]
    pub fn mbedtls_sha512_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_hash_operation_t {
    pub private_alg: psa_algorithm_t,
    pub private_ctx: mbedtls_psa_hash_operation_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_psa_hash_operation_t__bindgen_ty_1 {
    pub dummy: crate::c_types::c_uint,
    pub md5: mbedtls_md5_context,
    pub ripemd160: mbedtls_ripemd160_context,
    pub sha1: mbedtls_sha1_context,
    pub sha256: mbedtls_sha256_context,
    pub sha512: mbedtls_sha512_context,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_cipher_operation_t {
    pub private_alg: psa_algorithm_t,
    pub private_iv_length: u8,
    pub private_block_length: u8,
    pub private_ctx: mbedtls_psa_cipher_operation_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_psa_cipher_operation_t__bindgen_ty_1 {
    pub private_dummy: crate::c_types::c_uint,
    pub private_cipher: mbedtls_cipher_context_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_hash_context_t {
    pub dummy: crate::c_types::c_uint,
    pub mbedtls_ctx: mbedtls_psa_hash_operation_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_cipher_context_t {
    pub dummy: crate::c_types::c_uint,
    pub mbedtls_ctx: mbedtls_psa_cipher_operation_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_hash_operation_s {
    pub private_id: crate::c_types::c_uint,
    pub private_ctx: psa_driver_hash_context_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_cipher_operation_s {
    pub private_id: crate::c_types::c_uint,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_default_iv_length: u8,
    pub private_ctx: psa_driver_cipher_context_t,
}
impl psa_cipher_operation_s {
    #[inline]
    pub fn private_iv_required(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_iv_required(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn private_iv_set(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_iv_set(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_iv_required: crate::c_types::c_uint,
        private_iv_set: crate::c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_iv_required: u32 = unsafe { ::core::mem::transmute(private_iv_required) };
            private_iv_required as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let private_iv_set: u32 = unsafe { ::core::mem::transmute(private_iv_set) };
            private_iv_set as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_hmac_operation_t {
    pub private_alg: psa_algorithm_t,
    #[doc = " The hash context."]
    pub hash_ctx: psa_hash_operation_s,
    pub private_opad: [u8; 128usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_mac_operation_t {
    pub private_alg: psa_algorithm_t,
    pub private_ctx: mbedtls_psa_mac_operation_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_psa_mac_operation_t__bindgen_ty_1 {
    pub private_dummy: crate::c_types::c_uint,
    pub private_hmac: mbedtls_psa_hmac_operation_t,
    pub private_cmac: mbedtls_cipher_context_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_aead_operation_t {
    pub private_alg: psa_algorithm_t,
    pub private_key_type: psa_key_type_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_tag_length: u8,
    pub ctx: mbedtls_psa_aead_operation_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_psa_aead_operation_t__bindgen_ty_1 {
    pub dummy: crate::c_types::c_uint,
    pub private_ccm: mbedtls_ccm_context,
    pub private_gcm: mbedtls_gcm_context,
    pub private_chachapoly: mbedtls_chachapoly_context,
}
impl mbedtls_psa_aead_operation_t {
    #[inline]
    pub fn private_is_encrypt(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_is_encrypt(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_is_encrypt: crate::c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_is_encrypt: u32 = unsafe { ::core::mem::transmute(private_is_encrypt) };
            private_is_encrypt as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_sign_hash_interruptible_operation_t {
    pub private_dummy: crate::c_types::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_verify_hash_interruptible_operation_t {
    pub private_dummy: crate::c_types::c_uint,
}
#[doc = "< Client"]
pub const mbedtls_ecjpake_role_MBEDTLS_ECJPAKE_CLIENT: mbedtls_ecjpake_role = 0;
#[doc = "< Server"]
pub const mbedtls_ecjpake_role_MBEDTLS_ECJPAKE_SERVER: mbedtls_ecjpake_role = 1;
#[doc = " Roles in the EC J-PAKE exchange"]
pub type mbedtls_ecjpake_role = crate::c_types::c_uint;
#[doc = " EC J-PAKE context structure.\n\n J-PAKE is a symmetric protocol, except for the identifiers used in\n Zero-Knowledge Proofs, and the serialization of the second message\n (KeyExchange) as defined by the Thread spec.\n\n In order to benefit from this symmetry, we choose a different naming\n convention from the Thread v1.0 spec. Correspondence is indicated in the\n description as a pair C: client name, S: server name"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ecjpake_context {
    pub private_md_type: mbedtls_md_type_t,
    pub private_grp: mbedtls_ecp_group,
    pub private_role: mbedtls_ecjpake_role,
    pub private_point_format: crate::c_types::c_int,
    pub private_Xm1: mbedtls_ecp_point,
    pub private_Xm2: mbedtls_ecp_point,
    pub private_Xp1: mbedtls_ecp_point,
    pub private_Xp2: mbedtls_ecp_point,
    pub private_Xp: mbedtls_ecp_point,
    pub private_xm1: mbedtls_mpi,
    pub private_xm2: mbedtls_mpi,
    pub private_s: mbedtls_mpi,
}
extern "C" {
    #[doc = " \\brief           Initialize an ECJPAKE context.\n\n \\param ctx       The ECJPAKE context to initialize.\n                  This must not be \\c NULL."]
    pub fn mbedtls_ecjpake_init(ctx: *mut mbedtls_ecjpake_context);
}
extern "C" {
    #[doc = " \\brief           Set up an ECJPAKE context for use.\n\n \\note            Currently the only values for hash/curve allowed by the\n                  standard are #MBEDTLS_MD_SHA256/#MBEDTLS_ECP_DP_SECP256R1.\n\n \\param ctx       The ECJPAKE context to set up. This must be initialized.\n \\param role      The role of the caller. This must be either\n                  #MBEDTLS_ECJPAKE_CLIENT or #MBEDTLS_ECJPAKE_SERVER.\n \\param hash      The identifier of the hash function to use,\n                  for example #MBEDTLS_MD_SHA256.\n \\param curve     The identifier of the elliptic curve to use,\n                  for example #MBEDTLS_ECP_DP_SECP256R1.\n \\param secret    The pre-shared secret (passphrase). This must be\n                  a readable not empty buffer of length \\p len Bytes. It need\n                  only be valid for the duration of this call.\n \\param len       The length of the pre-shared secret \\p secret.\n\n \\return          \\c 0 if successful.\n \\return          A negative error code on failure."]
    pub fn mbedtls_ecjpake_setup(
        ctx: *mut mbedtls_ecjpake_context,
        role: mbedtls_ecjpake_role,
        hash: mbedtls_md_type_t,
        curve: mbedtls_ecp_group_id,
        secret: *const crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               Set the point format for future reads and writes.\n\n \\param ctx           The ECJPAKE context to configure.\n \\param point_format  The point format to use:\n                      #MBEDTLS_ECP_PF_UNCOMPRESSED (default)\n                      or #MBEDTLS_ECP_PF_COMPRESSED.\n\n \\return              \\c 0 if successful.\n \\return              #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if \\p point_format\n                      is invalid."]
    pub fn mbedtls_ecjpake_set_point_format(
        ctx: *mut mbedtls_ecjpake_context,
        point_format: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Check if an ECJPAKE context is ready for use.\n\n \\param ctx       The ECJPAKE context to check. This must be\n                  initialized.\n\n \\return          \\c 0 if the context is ready for use.\n \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA otherwise."]
    pub fn mbedtls_ecjpake_check(ctx: *const mbedtls_ecjpake_context) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Generate and write the first round message\n                  (TLS: contents of the Client/ServerHello extension,\n                  excluding extension type and length bytes).\n\n \\param ctx       The ECJPAKE context to use. This must be\n                  initialized and set up.\n \\param buf       The buffer to write the contents to. This must be a\n                  writable buffer of length \\p len Bytes.\n \\param len       The length of \\p buf in Bytes.\n \\param olen      The address at which to store the total number\n                  of Bytes written to \\p buf. This must not be \\c NULL.\n \\param f_rng     The RNG function to use. This must not be \\c NULL.\n \\param p_rng     The RNG parameter to be passed to \\p f_rng. This\n                  may be \\c NULL if \\p f_rng doesn't use a context.\n\n \\return          \\c 0 if successful.\n \\return          A negative error code on failure."]
    pub fn mbedtls_ecjpake_write_round_one(
        ctx: *mut mbedtls_ecjpake_context,
        buf: *mut crate::c_types::c_uchar,
        len: usize,
        olen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Read and process the first round message\n                  (TLS: contents of the Client/ServerHello extension,\n                  excluding extension type and length bytes).\n\n \\param ctx       The ECJPAKE context to use. This must be initialized\n                  and set up.\n \\param buf       The buffer holding the first round message. This must\n                  be a readable buffer of length \\p len Bytes.\n \\param len       The length in Bytes of \\p buf.\n\n \\return          \\c 0 if successful.\n \\return          A negative error code on failure."]
    pub fn mbedtls_ecjpake_read_round_one(
        ctx: *mut mbedtls_ecjpake_context,
        buf: *const crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Generate and write the second round message\n                  (TLS: contents of the Client/ServerKeyExchange).\n\n \\param ctx       The ECJPAKE context to use. This must be initialized,\n                  set up, and already have performed round one.\n \\param buf       The buffer to write the round two contents to.\n                  This must be a writable buffer of length \\p len Bytes.\n \\param len       The size of \\p buf in Bytes.\n \\param olen      The address at which to store the total number of Bytes\n                  written to \\p buf. This must not be \\c NULL.\n \\param f_rng     The RNG function to use. This must not be \\c NULL.\n \\param p_rng     The RNG parameter to be passed to \\p f_rng. This\n                  may be \\c NULL if \\p f_rng doesn't use a context.\n\n \\return          \\c 0 if successful.\n \\return          A negative error code on failure."]
    pub fn mbedtls_ecjpake_write_round_two(
        ctx: *mut mbedtls_ecjpake_context,
        buf: *mut crate::c_types::c_uchar,
        len: usize,
        olen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Read and process the second round message\n                  (TLS: contents of the Client/ServerKeyExchange).\n\n \\param ctx       The ECJPAKE context to use. This must be initialized\n                  and set up and already have performed round one.\n \\param buf       The buffer holding the second round message. This must\n                  be a readable buffer of length \\p len Bytes.\n \\param len       The length in Bytes of \\p buf.\n\n \\return          \\c 0 if successful.\n \\return          A negative error code on failure."]
    pub fn mbedtls_ecjpake_read_round_two(
        ctx: *mut mbedtls_ecjpake_context,
        buf: *const crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Derive the shared secret\n                  (TLS: Pre-Master Secret).\n\n \\param ctx       The ECJPAKE context to use. This must be initialized,\n                  set up and have performed both round one and two.\n \\param buf       The buffer to write the derived secret to. This must\n                  be a writable buffer of length \\p len Bytes.\n \\param len       The length of \\p buf in Bytes.\n \\param olen      The address at which to store the total number of Bytes\n                  written to \\p buf. This must not be \\c NULL.\n \\param f_rng     The RNG function to use. This must not be \\c NULL.\n \\param p_rng     The RNG parameter to be passed to \\p f_rng. This\n                  may be \\c NULL if \\p f_rng doesn't use a context.\n\n \\return          \\c 0 if successful.\n \\return          A negative error code on failure."]
    pub fn mbedtls_ecjpake_derive_secret(
        ctx: *mut mbedtls_ecjpake_context,
        buf: *mut crate::c_types::c_uchar,
        len: usize,
        olen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Write the shared key material to be passed to a Key\n                  Derivation Function as described in RFC8236.\n\n \\param ctx       The ECJPAKE context to use. This must be initialized,\n                  set up and have performed both round one and two.\n \\param buf       The buffer to write the derived secret to. This must\n                  be a writable buffer of length \\p len Bytes.\n \\param len       The length of \\p buf in Bytes.\n \\param olen      The address at which to store the total number of bytes\n                  written to \\p buf. This must not be \\c NULL.\n \\param f_rng     The RNG function to use. This must not be \\c NULL.\n \\param p_rng     The RNG parameter to be passed to \\p f_rng. This\n                  may be \\c NULL if \\p f_rng doesn't use a context.\n\n \\return          \\c 0 if successful.\n \\return          A negative error code on failure."]
    pub fn mbedtls_ecjpake_write_shared_key(
        ctx: *mut mbedtls_ecjpake_context,
        buf: *mut crate::c_types::c_uchar,
        len: usize,
        olen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This clears an ECJPAKE context and frees any\n                  embedded data structure.\n\n \\param ctx       The ECJPAKE context to free. This may be \\c NULL,\n                  in which case this function does nothing. If it is not\n                  \\c NULL, it must point to an initialized ECJPAKE context."]
    pub fn mbedtls_ecjpake_free(ctx: *mut mbedtls_ecjpake_context);
}
extern "C" {
    #[doc = " \\brief          Checkup routine\n\n \\return         0 if successful, or 1 if a test failed"]
    pub fn mbedtls_ecjpake_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_pake_operation_t {
    pub private_alg: psa_algorithm_t,
    pub private_password: *mut u8,
    pub private_password_len: usize,
    pub private_role: u8,
    pub private_buffer: [u8; 336usize],
    pub private_buffer_length: usize,
    pub private_buffer_offset: usize,
    pub private_ctx: mbedtls_psa_pake_operation_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_psa_pake_operation_t__bindgen_ty_1 {
    pub private_dummy: crate::c_types::c_uint,
    pub private_jpake: mbedtls_ecjpake_context,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_mac_context_t {
    pub dummy: crate::c_types::c_uint,
    pub mbedtls_ctx: mbedtls_psa_mac_operation_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_aead_context_t {
    pub dummy: crate::c_types::c_uint,
    pub mbedtls_ctx: mbedtls_psa_aead_operation_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_sign_hash_interruptible_context_t {
    pub dummy: crate::c_types::c_uint,
    pub mbedtls_ctx: mbedtls_psa_sign_hash_interruptible_operation_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_verify_hash_interruptible_context_t {
    pub dummy: crate::c_types::c_uint,
    pub mbedtls_ctx: mbedtls_psa_verify_hash_interruptible_operation_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_pake_context_t {
    pub dummy: crate::c_types::c_uint,
    pub mbedtls_ctx: mbedtls_psa_pake_operation_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_mac_operation_s {
    pub private_id: crate::c_types::c_uint,
    pub private_mac_size: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_ctx: psa_driver_mac_context_t,
}
impl psa_mac_operation_s {
    #[inline]
    pub fn private_is_sign(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_is_sign(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_is_sign: crate::c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_is_sign: u32 = unsafe { ::core::mem::transmute(private_is_sign) };
            private_is_sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_aead_operation_s {
    pub private_id: crate::c_types::c_uint,
    pub private_alg: psa_algorithm_t,
    pub private_key_type: psa_key_type_t,
    pub private_ad_remaining: usize,
    pub private_body_remaining: usize,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_ctx: psa_driver_aead_context_t,
}
impl psa_aead_operation_s {
    #[inline]
    pub fn private_nonce_set(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_nonce_set(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn private_lengths_set(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_lengths_set(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn private_ad_started(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_ad_started(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn private_body_started(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_body_started(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn private_is_encrypt(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_is_encrypt(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_nonce_set: crate::c_types::c_uint,
        private_lengths_set: crate::c_types::c_uint,
        private_ad_started: crate::c_types::c_uint,
        private_body_started: crate::c_types::c_uint,
        private_is_encrypt: crate::c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_nonce_set: u32 = unsafe { ::core::mem::transmute(private_nonce_set) };
            private_nonce_set as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let private_lengths_set: u32 = unsafe { ::core::mem::transmute(private_lengths_set) };
            private_lengths_set as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let private_ad_started: u32 = unsafe { ::core::mem::transmute(private_ad_started) };
            private_ad_started as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let private_body_started: u32 = unsafe { ::core::mem::transmute(private_body_started) };
            private_body_started as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let private_is_encrypt: u32 = unsafe { ::core::mem::transmute(private_is_encrypt) };
            private_is_encrypt as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_hkdf_key_derivation_t {
    pub private_info: *mut u8,
    pub private_info_length: usize,
    pub private_offset_in_block: u8,
    pub private_block_number: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_output_block: [u8; 64usize],
    pub private_prk: [u8; 64usize],
    pub private_hmac: psa_mac_operation_s,
}
impl psa_hkdf_key_derivation_t {
    #[inline]
    pub fn private_state(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_private_state(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn private_info_set(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_info_set(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_state: crate::c_types::c_uint,
        private_info_set: crate::c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let private_state: u32 = unsafe { ::core::mem::transmute(private_state) };
            private_state as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let private_info_set: u32 = unsafe { ::core::mem::transmute(private_info_set) };
            private_info_set as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_tls12_ecjpake_to_pms_t {
    pub private_data: [u8; 32usize],
}
pub const psa_tls12_prf_key_derivation_state_t_PSA_TLS12_PRF_STATE_INIT:
    psa_tls12_prf_key_derivation_state_t = 0;
pub const psa_tls12_prf_key_derivation_state_t_PSA_TLS12_PRF_STATE_SEED_SET:
    psa_tls12_prf_key_derivation_state_t = 1;
pub const psa_tls12_prf_key_derivation_state_t_PSA_TLS12_PRF_STATE_OTHER_KEY_SET:
    psa_tls12_prf_key_derivation_state_t = 2;
pub const psa_tls12_prf_key_derivation_state_t_PSA_TLS12_PRF_STATE_KEY_SET:
    psa_tls12_prf_key_derivation_state_t = 3;
pub const psa_tls12_prf_key_derivation_state_t_PSA_TLS12_PRF_STATE_LABEL_SET:
    psa_tls12_prf_key_derivation_state_t = 4;
pub const psa_tls12_prf_key_derivation_state_t_PSA_TLS12_PRF_STATE_OUTPUT:
    psa_tls12_prf_key_derivation_state_t = 5;
pub type psa_tls12_prf_key_derivation_state_t = crate::c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_tls12_prf_key_derivation_s {
    pub private_left_in_block: u8,
    pub private_block_number: u8,
    pub private_state: psa_tls12_prf_key_derivation_state_t,
    pub private_secret: *mut u8,
    pub private_secret_length: usize,
    pub private_seed: *mut u8,
    pub private_seed_length: usize,
    pub private_label: *mut u8,
    pub private_label_length: usize,
    pub private_other_secret: *mut u8,
    pub private_other_secret_length: usize,
    pub private_Ai: [u8; 64usize],
    pub private_output_block: [u8; 64usize],
}
pub type psa_tls12_prf_key_derivation_t = psa_tls12_prf_key_derivation_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_key_derivation_s {
    pub private_alg: psa_algorithm_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_capacity: usize,
    pub private_ctx: psa_key_derivation_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_key_derivation_s__bindgen_ty_1 {
    pub private_dummy: u8,
    pub private_hkdf: psa_hkdf_key_derivation_t,
    pub private_tls12_prf: psa_tls12_prf_key_derivation_t,
    pub private_tls12_ecjpake_to_pms: psa_tls12_ecjpake_to_pms_t,
}
impl psa_key_derivation_s {
    #[inline]
    pub fn private_can_output_key(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_can_output_key(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_can_output_key: crate::c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_can_output_key: u32 =
                unsafe { ::core::mem::transmute(private_can_output_key) };
            private_can_output_key as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_key_policy_s {
    pub private_usage: psa_key_usage_t,
    pub private_alg: psa_algorithm_t,
    pub private_alg2: psa_algorithm_t,
}
pub type psa_key_policy_t = psa_key_policy_s;
pub type psa_key_bits_t = u16;
#[doc = " A mask of flags that can be stored in key attributes.\n\n This type is also used internally to store flags in slots. Internal\n flags are defined in library/psa_crypto_core.h. Internal flags may have\n the same value as external flags if they are properly handled during\n key creation and in psa_get_key_attributes."]
pub type psa_key_attributes_flag_t = u16;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_core_key_attributes_t {
    pub private_type: psa_key_type_t,
    pub private_bits: psa_key_bits_t,
    pub private_lifetime: psa_key_lifetime_t,
    pub private_id: mbedtls_svc_key_id_t,
    pub private_policy: psa_key_policy_t,
    pub private_flags: psa_key_attributes_flag_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_key_attributes_s {
    pub private_core: psa_core_key_attributes_t,
    pub private_domain_parameters: *mut crate::c_types::c_void,
    pub private_domain_parameters_size: usize,
}
extern "C" {
    #[doc = " \\brief Set domain parameters for a key.\n\n Some key types require additional domain parameters in addition to\n the key type identifier and the key size. Use this function instead\n of psa_set_key_type() when you need to specify domain parameters.\n\n The format for the required domain parameters varies based on the key type.\n\n - For RSA keys (#PSA_KEY_TYPE_RSA_PUBLIC_KEY or #PSA_KEY_TYPE_RSA_KEY_PAIR),\n   the domain parameter data consists of the public exponent,\n   represented as a big-endian integer with no leading zeros.\n   This information is used when generating an RSA key pair.\n   When importing a key, the public exponent is read from the imported\n   key data and the exponent recorded in the attribute structure is ignored.\n   As an exception, the public exponent 65537 is represented by an empty\n   byte string.\n - For DSA keys (#PSA_KEY_TYPE_DSA_PUBLIC_KEY or #PSA_KEY_TYPE_DSA_KEY_PAIR),\n   the `Dss-Params` format as defined by RFC 3279 &sect;2.3.2.\n   ```\n   Dss-Params ::= SEQUENCE  {\n      p       INTEGER,\n      q       INTEGER,\n      g       INTEGER\n   }\n   ```\n - For Diffie-Hellman key exchange keys\n   (#PSA_KEY_TYPE_DH_PUBLIC_KEY(#PSA_DH_FAMILY_CUSTOM) or\n   #PSA_KEY_TYPE_DH_KEY_PAIR(#PSA_DH_FAMILY_CUSTOM)), the\n   `DomainParameters` format as defined by RFC 3279 &sect;2.3.3.\n   ```\n   DomainParameters ::= SEQUENCE {\n      p               INTEGER,                    -- odd prime, p=jq +1\n      g               INTEGER,                    -- generator, g\n      q               INTEGER,                    -- factor of p-1\n      j               INTEGER OPTIONAL,           -- subgroup factor\n      validationParams ValidationParams OPTIONAL\n   }\n   ValidationParams ::= SEQUENCE {\n      seed            BIT STRING,\n      pgenCounter     INTEGER\n   }\n   ```\n\n \\note This function may allocate memory or other resources.\n       Once you have called this function on an attribute structure,\n       you must call psa_reset_key_attributes() to free these resources.\n\n \\note This is an experimental extension to the interface. It may change\n       in future versions of the library.\n\n \\param[in,out] attributes    Attribute structure where the specified domain\n                              parameters will be stored.\n                              If this function fails, the content of\n                              \\p attributes is not modified.\n \\param type                  Key type (a \\c PSA_KEY_TYPE_XXX value).\n \\param[in] data              Buffer containing the key domain parameters.\n                              The content of this buffer is interpreted\n                              according to \\p type as described above.\n \\param data_length           Size of the \\p data buffer in bytes.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
    pub fn psa_set_key_domain_parameters(
        attributes: *mut psa_key_attributes_t,
        type_: psa_key_type_t,
        data: *const u8,
        data_length: usize,
    ) -> psa_status_t;
}
#[doc = " \\brief The context for PSA interruptible hash signing."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_sign_hash_interruptible_operation_s {
    pub private_id: crate::c_types::c_uint,
    pub private_ctx: psa_driver_sign_hash_interruptible_context_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_num_ops: u32,
}
impl psa_sign_hash_interruptible_operation_s {
    #[inline]
    pub fn private_error_occurred(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_error_occurred(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_error_occurred: crate::c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_error_occurred: u32 =
                unsafe { ::core::mem::transmute(private_error_occurred) };
            private_error_occurred as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " \\brief The context for PSA interruptible hash verification."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_verify_hash_interruptible_operation_s {
    pub private_id: crate::c_types::c_uint,
    pub private_ctx: psa_driver_verify_hash_interruptible_context_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_num_ops: u32,
}
impl psa_verify_hash_interruptible_operation_s {
    #[inline]
    pub fn private_error_occurred(&self) -> crate::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_private_error_occurred(&mut self, val: crate::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        private_error_occurred: crate::c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let private_error_occurred: u32 =
                unsafe { ::core::mem::transmute(private_error_occurred) };
            private_error_occurred as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type psa_key_handle_t = mbedtls_svc_key_id_t;
extern "C" {
    #[doc = " Open a handle to an existing persistent key.\n\n Open a handle to a persistent key. A key is persistent if it was created\n with a lifetime other than #PSA_KEY_LIFETIME_VOLATILE. A persistent key\n always has a nonzero key identifier, set with psa_set_key_id() when\n creating the key. Implementations may provide additional pre-provisioned\n keys that can be opened with psa_open_key(). Such keys have an application\n key identifier in the vendor range, as documented in the description of\n #psa_key_id_t.\n\n The application must eventually close the handle with psa_close_key() or\n psa_destroy_key() to release associated resources. If the application dies\n without calling one of these functions, the implementation should perform\n the equivalent of a call to psa_close_key().\n\n Some implementations permit an application to open the same key multiple\n times. If this is successful, each call to psa_open_key() will return a\n different key handle.\n\n \\note This API is not part of the PSA Cryptography API Release 1.0.0\n specification. It was defined in the 1.0 Beta 3 version of the\n specification but was removed in the 1.0.0 released version. This API is\n kept for the time being to not break applications relying on it. It is not\n deprecated yet but will be in the near future.\n\n \\note Applications that rely on opening a key multiple times will not be\n portable to implementations that only permit a single key handle to be\n opened. See also :ref:\\`key-handles\\`.\n\n\n \\param key           The persistent identifier of the key.\n \\param[out] handle   On success, a handle to the key.\n\n \\retval #PSA_SUCCESS\n         Success. The application can now use the value of `*handle`\n         to access the key.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n         The implementation does not have sufficient resources to open the\n         key. This can be due to reaching an implementation limit on the\n         number of open keys, the number of open key handles, or available\n         memory.\n \\retval #PSA_ERROR_DOES_NOT_EXIST\n         There is no persistent key with key identifier \\p key.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not a valid persistent key identifier.\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The specified key exists, but the application does not have the\n         permission to access it. Note that this specification does not\n         define any way to create such a key, but it may be possible\n         through implementation-specific means.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_open_key(key: mbedtls_svc_key_id_t, handle: *mut psa_key_handle_t) -> psa_status_t;
}
extern "C" {
    #[doc = " Close a key handle.\n\n If the handle designates a volatile key, this will destroy the key material\n and free all associated resources, just like psa_destroy_key().\n\n If this is the last open handle to a persistent key, then closing the handle\n will free all resources associated with the key in volatile memory. The key\n data in persistent storage is not affected and can be opened again later\n with a call to psa_open_key().\n\n Closing the key handle makes the handle invalid, and the key handle\n must not be used again by the application.\n\n \\note This API is not part of the PSA Cryptography API Release 1.0.0\n specification. It was defined in the 1.0 Beta 3 version of the\n specification but was removed in the 1.0.0 released version. This API is\n kept for the time being to not break applications relying on it. It is not\n deprecated yet but will be in the near future.\n\n \\note If the key handle was used to set up an active\n :ref:\\`multipart operation <multipart-operations>\\`, then closing the\n key handle can cause the multipart operation to fail. Applications should\n maintain the key handle until after the multipart operation has finished.\n\n \\param handle        The key handle to close.\n                      If this is \\c 0, do nothing and return \\c PSA_SUCCESS.\n\n \\retval #PSA_SUCCESS\n         \\p handle was a valid handle or \\c 0. It is now closed.\n \\retval #PSA_ERROR_INVALID_HANDLE\n         \\p handle is not a valid handle nor \\c 0.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_close_key(handle: psa_key_handle_t) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Library deinitialization.\n\n This function clears all data associated with the PSA layer,\n including the whole key store.\n\n This is an Mbed TLS extension."]
    pub fn mbedtls_psa_crypto_free();
}
#[doc = " \\brief Statistics about\n resource consumption related to the PSA keystore.\n\n \\note The content of this structure is not part of the stable API and ABI\n       of Mbed Crypto and may change arbitrarily from version to version."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_stats_s {
    pub private_volatile_slots: usize,
    pub private_persistent_slots: usize,
    pub private_external_slots: usize,
    pub private_half_filled_slots: usize,
    pub private_cache_slots: usize,
    pub private_empty_slots: usize,
    pub private_locked_slots: usize,
    pub private_max_open_internal_key_id: psa_key_id_t,
    pub private_max_open_external_key_id: psa_key_id_t,
}
#[doc = " \\brief Statistics about\n resource consumption related to the PSA keystore.\n\n \\note The content of this structure is not part of the stable API and ABI\n       of Mbed Crypto and may change arbitrarily from version to version."]
pub type mbedtls_psa_stats_t = mbedtls_psa_stats_s;
extern "C" {
    #[doc = " \\brief Get statistics about\n resource consumption related to the PSA keystore.\n\n \\note When Mbed Crypto is built as part of a service, with isolation\n       between the application and the keystore, the service may or\n       may not expose this function."]
    pub fn mbedtls_psa_get_stats(stats: *mut mbedtls_psa_stats_t);
}
extern "C" {
    #[doc = " \\brief Inject an initial entropy seed for the random generator into\n        secure storage.\n\n This function injects data to be used as a seed for the random generator\n used by the PSA Crypto implementation. On devices that lack a trusted\n entropy source (preferably a hardware random number generator),\n the Mbed PSA Crypto implementation uses this value to seed its\n random generator.\n\n On devices without a trusted entropy source, this function must be\n called exactly once in the lifetime of the device. On devices with\n a trusted entropy source, calling this function is optional.\n In all cases, this function may only be called before calling any\n other function in the PSA Crypto API, including psa_crypto_init().\n\n When this function returns successfully, it populates a file in\n persistent storage. Once the file has been created, this function\n can no longer succeed.\n\n If any error occurs, this function does not change the system state.\n You can call this function again after correcting the reason for the\n error if possible.\n\n \\warning This function **can** fail! Callers MUST check the return status.\n\n \\warning If you use this function, you should use it as part of a\n          factory provisioning process. The value of the injected seed\n          is critical to the security of the device. It must be\n          *secret*, *unpredictable* and (statistically) *unique per device*.\n          You should be generate it randomly using a cryptographically\n          secure random generator seeded from trusted entropy sources.\n          You should transmit it securely to the device and ensure\n          that its value is not leaked or stored anywhere beyond the\n          needs of transmitting it from the point of generation to\n          the call of this function, and erase all copies of the value\n          once this function returns.\n\n This is an Mbed TLS extension.\n\n \\note This function is only available on the following platforms:\n * If the compile-time option MBEDTLS_PSA_INJECT_ENTROPY is enabled.\n   Note that you must provide compatible implementations of\n   mbedtls_nv_seed_read and mbedtls_nv_seed_write.\n * In a client-server integration of PSA Cryptography, on the client side,\n   if the server supports this feature.\n \\param[in] seed          Buffer containing the seed value to inject.\n \\param[in] seed_size     Size of the \\p seed buffer.\n                          The size of the seed in bytes must be greater\n                          or equal to both #MBEDTLS_ENTROPY_BLOCK_SIZE\n                          and the value of \\c MBEDTLS_ENTROPY_MIN_PLATFORM\n                          in `library/entropy_poll.h` in the Mbed TLS source\n                          code.\n                          It must be less or equal to\n                          #MBEDTLS_ENTROPY_MAX_SEED_SIZE.\n\n \\retval #PSA_SUCCESS\n         The seed value was injected successfully. The random generator\n         of the PSA Crypto implementation is now ready for use.\n         You may now call psa_crypto_init() and use the PSA Crypto\n         implementation.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p seed_size is out of range.\n \\retval #PSA_ERROR_STORAGE_FAILURE\n         There was a failure reading or writing from storage.\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The library has already been initialized. It is no longer\n         possible to call this function."]
    pub fn mbedtls_psa_inject_entropy(seed: *const u8, seed_size: usize) -> psa_status_t;
}
extern "C" {
    #[doc = " \\brief Get domain parameters for a key.\n\n Get the domain parameters for a key with this function, if any. The format\n of the domain parameters written to \\p data is specified in the\n documentation for psa_set_key_domain_parameters().\n\n \\note This is an experimental extension to the interface. It may change\n       in future versions of the library.\n\n \\param[in] attributes        The key attribute structure to query.\n \\param[out] data             On success, the key domain parameters.\n \\param data_size             Size of the \\p data buffer in bytes.\n                              The buffer is guaranteed to be large\n                              enough if its size in bytes is at least\n                              the value given by\n                              PSA_KEY_DOMAIN_PARAMETERS_SIZE().\n \\param[out] data_length      On success, the number of bytes\n                              that make up the key domain parameters data.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL \\emptydescription"]
    pub fn psa_get_key_domain_parameters(
        attributes: *const psa_key_attributes_t,
        data: *mut u8,
        data_size: usize,
        data_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Convert an ECC curve identifier from the PSA encoding to Mbed TLS.\n\n \\note This function is provided solely for the convenience of\n       Mbed TLS and may be removed at any time without notice.\n\n \\param curve         A PSA elliptic curve identifier\n                      (`PSA_ECC_FAMILY_xxx`).\n \\param bits          The bit-length of a private key on \\p curve.\n \\param bits_is_sloppy If true, \\p bits may be the bit-length rounded up\n                      to the nearest multiple of 8. This allows the caller\n                      to infer the exact curve from the length of a key\n                      which is supplied as a byte string.\n\n \\return              The corresponding Mbed TLS elliptic curve identifier\n                      (`MBEDTLS_ECP_DP_xxx`).\n \\return              #MBEDTLS_ECP_DP_NONE if \\c curve is not recognized.\n \\return              #MBEDTLS_ECP_DP_NONE if \\p bits is not\n                      correct for \\p curve."]
    pub fn mbedtls_ecc_group_of_psa(
        curve: psa_ecc_family_t,
        bits: usize,
        bits_is_sloppy: crate::c_types::c_int,
    ) -> mbedtls_ecp_group_id;
}
extern "C" {
    #[doc = " External random generator function, implemented by the platform.\n\n When the compile-time option #MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG is enabled,\n this function replaces Mbed TLS's entropy and DRBG modules for all\n random generation triggered via PSA crypto interfaces.\n\n \\note This random generator must deliver random numbers with cryptographic\n       quality and high performance. It must supply unpredictable numbers\n       with a uniform distribution. The implementation of this function\n       is responsible for ensuring that the random generator is seeded\n       with sufficient entropy. If you have a hardware TRNG which is slow\n       or delivers non-uniform output, declare it as an entropy source\n       with mbedtls_entropy_add_source() instead of enabling this option.\n\n \\param[in,out] context       Pointer to the random generator context.\n                              This is all-bits-zero on the first call\n                              and preserved between successive calls.\n \\param[out] output           Output buffer. On success, this buffer\n                              contains random data with a uniform\n                              distribution.\n \\param output_size           The size of the \\p output buffer in bytes.\n \\param[out] output_length    On success, set this value to \\p output_size.\n\n \\retval #PSA_SUCCESS\n         Success. The output buffer contains \\p output_size bytes of\n         cryptographic-quality random data, and \\c *output_length is\n         set to \\p output_size.\n \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY\n         The random generator requires extra entropy and there is no\n         way to obtain entropy under current environment conditions.\n         This error should not happen under normal circumstances since\n         this function is responsible for obtaining as much entropy as\n         it needs. However implementations of this function may return\n         #PSA_ERROR_INSUFFICIENT_ENTROPY if there is no way to obtain\n         entropy without blocking indefinitely.\n \\retval #PSA_ERROR_HARDWARE_FAILURE\n         A failure of the random generator hardware that isn't covered\n         by #PSA_ERROR_INSUFFICIENT_ENTROPY."]
    pub fn mbedtls_psa_external_get_random(
        context: *mut mbedtls_psa_external_random_context_t,
        output: *mut u8,
        output_size: usize,
        output_length: *mut usize,
    ) -> psa_status_t;
}
#[doc = " A slot number identifying a key in a driver.\n\n Values of this type are used to identify built-in keys."]
pub type psa_drv_slot_number_t = u64;
#[doc = " \\brief Encoding of the application role of PAKE\n\n Encodes the application's role in the algorithm is being executed. For more\n information see the documentation of individual \\c PSA_PAKE_ROLE_XXX\n constants."]
pub type psa_pake_role_t = u8;
#[doc = " Encoding of input and output indicators for PAKE.\n\n Some PAKE algorithms need to exchange more data than just a single key share.\n This type is for encoding additional input and output data for such\n algorithms."]
pub type psa_pake_step_t = u8;
#[doc = " Encoding of the type of the PAKE's primitive.\n\n Values defined by this standard will never be in the range 0x80-0xff.\n Vendors who define additional types must use an encoding in this range.\n\n For more information see the documentation of individual\n \\c PSA_PAKE_PRIMITIVE_TYPE_XXX constants."]
pub type psa_pake_primitive_type_t = u8;
#[doc = " \\brief Encoding of the family of the primitive associated with the PAKE.\n\n For more information see the documentation of individual\n \\c PSA_PAKE_PRIMITIVE_TYPE_XXX constants."]
pub type psa_pake_family_t = u8;
#[doc = " \\brief Encoding of the primitive associated with the PAKE.\n\n For more information see the documentation of the #PSA_PAKE_PRIMITIVE macro."]
pub type psa_pake_primitive_t = u32;
#[doc = " The type of the data structure for PAKE cipher suites.\n\n This is an implementation-defined \\c struct. Applications should not\n make any assumptions about the content of this structure.\n Implementation details can change in future versions without notice."]
pub type psa_pake_cipher_suite_t = psa_pake_cipher_suite_s;
#[doc = " The type of the state data structure for PAKE operations.\n\n Before calling any function on a PAKE operation object, the application\n must initialize it by any of the following means:\n - Set the structure to all-bits-zero, for example:\n   \\code\n   psa_pake_operation_t operation;\n   memset(&operation, 0, sizeof(operation));\n   \\endcode\n - Initialize the structure to logical zero values, for example:\n   \\code\n   psa_pake_operation_t operation = {0};\n   \\endcode\n - Initialize the structure to the initializer #PSA_PAKE_OPERATION_INIT,\n   for example:\n   \\code\n   psa_pake_operation_t operation = PSA_PAKE_OPERATION_INIT;\n   \\endcode\n - Assign the result of the function psa_pake_operation_init()\n   to the structure, for example:\n   \\code\n   psa_pake_operation_t operation;\n   operation = psa_pake_operation_init();\n   \\endcode\n\n This is an implementation-defined \\c struct. Applications should not\n make any assumptions about the content of this structure.\n Implementation details can change in future versions without notice."]
pub type psa_pake_operation_t = psa_pake_operation_s;
#[doc = " The type of input values for PAKE operations."]
pub type psa_crypto_driver_pake_inputs_t = psa_crypto_driver_pake_inputs_s;
#[doc = " The type of computation stage for J-PAKE operations."]
pub type psa_jpake_computation_stage_t = psa_jpake_computation_stage_s;
extern "C" {
    #[doc = " Get the length of the password in bytes from given inputs.\n\n \\param[in]  inputs           Operation inputs.\n \\param[out] password_len     Password length.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BAD_STATE\n         Password hasn't been set yet."]
    pub fn psa_crypto_driver_pake_get_password_len(
        inputs: *const psa_crypto_driver_pake_inputs_t,
        password_len: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Get the password from given inputs.\n\n \\param[in]  inputs           Operation inputs.\n \\param[out] buffer           Return buffer for password.\n \\param      buffer_size      Size of the return buffer in bytes.\n \\param[out] buffer_length    Actual size of the password in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BAD_STATE\n         Password hasn't been set yet."]
    pub fn psa_crypto_driver_pake_get_password(
        inputs: *const psa_crypto_driver_pake_inputs_t,
        buffer: *mut u8,
        buffer_size: usize,
        buffer_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Get the role from given inputs.\n\n \\param[in]  inputs           Operation inputs.\n \\param[out] role             Return buffer for role.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BAD_STATE\n         Role hasn't been set yet."]
    pub fn psa_crypto_driver_pake_get_role(
        inputs: *const psa_crypto_driver_pake_inputs_t,
        role: *mut psa_pake_role_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Get the length of the user id in bytes from given inputs.\n\n \\param[in]  inputs           Operation inputs.\n \\param[out] user_len         User id length.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BAD_STATE\n         User id hasn't been set yet."]
    pub fn psa_crypto_driver_pake_get_user_len(
        inputs: *const psa_crypto_driver_pake_inputs_t,
        user_len: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Get the length of the peer id in bytes from given inputs.\n\n \\param[in]  inputs           Operation inputs.\n \\param[out] peer_len         Peer id length.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BAD_STATE\n         Peer id hasn't been set yet."]
    pub fn psa_crypto_driver_pake_get_peer_len(
        inputs: *const psa_crypto_driver_pake_inputs_t,
        peer_len: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Get the user id from given inputs.\n\n \\param[in]  inputs           Operation inputs.\n \\param[out] user_id          User id.\n \\param      user_id_size     Size of \\p user_id in bytes.\n \\param[out] user_id_len      Size of the user id in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BAD_STATE\n         User id hasn't been set yet.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p user_id is too small."]
    pub fn psa_crypto_driver_pake_get_user(
        inputs: *const psa_crypto_driver_pake_inputs_t,
        user_id: *mut u8,
        user_id_size: usize,
        user_id_len: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Get the peer id from given inputs.\n\n \\param[in]  inputs           Operation inputs.\n \\param[out] peer_id          Peer id.\n \\param      peer_id_size     Size of \\p peer_id in bytes.\n \\param[out] peer_id_length   Size of the peer id in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BAD_STATE\n         Peer id hasn't been set yet.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p peer_id is too small."]
    pub fn psa_crypto_driver_pake_get_peer(
        inputs: *const psa_crypto_driver_pake_inputs_t,
        peer_id: *mut u8,
        peer_id_size: usize,
        peer_id_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Get the cipher suite from given inputs.\n\n \\param[in]  inputs           Operation inputs.\n \\param[out] cipher_suite     Return buffer for role.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BAD_STATE\n         Cipher_suite hasn't been set yet."]
    pub fn psa_crypto_driver_pake_get_cipher_suite(
        inputs: *const psa_crypto_driver_pake_inputs_t,
        cipher_suite: *mut psa_pake_cipher_suite_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the session information for a password-authenticated key exchange.\n\n The sequence of operations to set up a password-authenticated key exchange\n is as follows:\n -# Allocate an operation object which will be passed to all the functions\n    listed here.\n -# Initialize the operation object with one of the methods described in the\n    documentation for #psa_pake_operation_t, e.g.\n    #PSA_PAKE_OPERATION_INIT.\n -# Call psa_pake_setup() to specify the cipher suite.\n -# Call \\c psa_pake_set_xxx() functions on the operation to complete the\n    setup. The exact sequence of \\c psa_pake_set_xxx() functions that needs\n    to be called depends on the algorithm in use.\n\n Refer to the documentation of individual PAKE algorithm types (`PSA_ALG_XXX`\n values of type ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\\c alg) is true)\n for more information.\n\n A typical sequence of calls to perform a password-authenticated key\n exchange:\n -# Call psa_pake_output(operation, #PSA_PAKE_STEP_KEY_SHARE, ...) to get the\n    key share that needs to be sent to the peer.\n -# Call psa_pake_input(operation, #PSA_PAKE_STEP_KEY_SHARE, ...) to provide\n    the key share that was received from the peer.\n -# Depending on the algorithm additional calls to psa_pake_output() and\n    psa_pake_input() might be necessary.\n -# Call psa_pake_get_implicit_key() for accessing the shared secret.\n\n Refer to the documentation of individual PAKE algorithm types (`PSA_ALG_XXX`\n values of type ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\\c alg) is true)\n for more information.\n\n If an error occurs at any step after a call to psa_pake_setup(),\n the operation will need to be reset by a call to psa_pake_abort(). The\n application may call psa_pake_abort() at any time after the operation\n has been initialized.\n\n After a successful call to psa_pake_setup(), the application must\n eventually terminate the operation. The following events terminate an\n operation:\n - A call to psa_pake_abort().\n - A successful call to psa_pake_get_implicit_key().\n\n \\param[in,out] operation     The operation object to set up. It must have\n                              been initialized but not set up yet.\n \\param[in] cipher_suite      The cipher suite to use. (A cipher suite fully\n                              characterizes a PAKE algorithm and determines\n                              the algorithm as well.)\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The algorithm in \\p cipher_suite is not a PAKE algorithm, or the\n         PAKE primitive in \\p cipher_suite is not compatible with the\n         PAKE algorithm, or the hash algorithm in \\p cipher_suite is invalid\n         or not compatible with the PAKE algorithm and primitive.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         The algorithm in \\p cipher_suite is not a supported PAKE algorithm,\n         or the PAKE primitive in \\p cipher_suite is not supported or not\n         compatible with the PAKE algorithm, or the hash algorithm in\n         \\p cipher_suite is not supported or not compatible with the PAKE\n         algorithm and primitive.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid, or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_pake_setup(
        operation: *mut psa_pake_operation_t,
        cipher_suite: *const psa_pake_cipher_suite_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the password for a password-authenticated key exchange from key ID.\n\n Call this function when the password, or a value derived from the password,\n is already present in the key store.\n\n \\param[in,out] operation     The operation object to set the password for. It\n                              must have been set up by psa_pake_setup() and\n                              not yet in use (neither psa_pake_output() nor\n                              psa_pake_input() has been called yet). It must\n                              be on operation for which the password hasn't\n                              been set yet (psa_pake_set_password_key()\n                              hasn't been called yet).\n \\param password              Identifier of the key holding the password or a\n                              value derived from the password (eg. by a\n                              memory-hard function).  It must remain valid\n                              until the operation terminates. It must be of\n                              type #PSA_KEY_TYPE_PASSWORD or\n                              #PSA_KEY_TYPE_PASSWORD_HASH. It has to allow\n                              the usage #PSA_KEY_USAGE_DERIVE.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE\n         \\p password is not a valid key identifier.\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The key does not have the #PSA_KEY_USAGE_DERIVE flag, or it does not\n         permit the \\p operation's algorithm.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The key type for \\p password is not #PSA_KEY_TYPE_PASSWORD or\n         #PSA_KEY_TYPE_PASSWORD_HASH, or \\p password is not compatible with\n         the \\p operation's cipher suite.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         The key type or key size of \\p password is not supported with the\n         \\p operation's cipher suite.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription\n \\retval #PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must have been set up.), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_pake_set_password_key(
        operation: *mut psa_pake_operation_t,
        password: mbedtls_svc_key_id_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the user ID for a password-authenticated key exchange.\n\n Call this function to set the user ID. For PAKE algorithms that associate a\n user identifier with each side of the session you need to call\n psa_pake_set_peer() as well. For PAKE algorithms that associate a single\n user identifier with the session, call psa_pake_set_user() only.\n\n Refer to the documentation of individual PAKE algorithm types (`PSA_ALG_XXX`\n values of type ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\\c alg) is true)\n for more information.\n\n \\param[in,out] operation     The operation object to set the user ID for. It\n                              must have been set up by psa_pake_setup() and\n                              not yet in use (neither psa_pake_output() nor\n                              psa_pake_input() has been called yet). It must\n                              be on operation for which the user ID hasn't\n                              been set (psa_pake_set_user() hasn't been\n                              called yet).\n \\param[in] user_id           The user ID to authenticate with.\n                              (temporary limitation: \"client\" or \"server\" only)\n \\param user_id_len           Size of the \\p user_id buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p user_id is not valid for the \\p operation's algorithm and cipher\n         suite.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         The value of \\p user_id is not supported by the implementation.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid, or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_pake_set_user(
        operation: *mut psa_pake_operation_t,
        user_id: *const u8,
        user_id_len: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the peer ID for a password-authenticated key exchange.\n\n Call this function in addition to psa_pake_set_user() for PAKE algorithms\n that associate a user identifier with each side of the session. For PAKE\n algorithms that associate a single user identifier with the session, call\n psa_pake_set_user() only.\n\n Refer to the documentation of individual PAKE algorithm types (`PSA_ALG_XXX`\n values of type ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\\c alg) is true)\n for more information.\n\n \\param[in,out] operation     The operation object to set the peer ID for. It\n                              must have been set up by psa_pake_setup() and\n                              not yet in use (neither psa_pake_output() nor\n                              psa_pake_input() has been called yet). It must\n                              be on operation for which the peer ID hasn't\n                              been set (psa_pake_set_peer() hasn't been\n                              called yet).\n \\param[in] peer_id           The peer's ID to authenticate.\n                              (temporary limitation: \"client\" or \"server\" only)\n \\param peer_id_len           Size of the \\p peer_id buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p user_id is not valid for the \\p operation's algorithm and cipher\n         suite.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         The algorithm doesn't associate a second identity with the session.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         Calling psa_pake_set_peer() is invalid with the \\p operation's\n         algorithm, the operation state is not valid, or the library has not\n         been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_pake_set_peer(
        operation: *mut psa_pake_operation_t,
        peer_id: *const u8,
        peer_id_len: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Set the application role for a password-authenticated key exchange.\n\n Not all PAKE algorithms need to differentiate the communicating entities.\n It is optional to call this function for PAKEs that don't require a role\n to be specified. For such PAKEs the application role parameter is ignored,\n or #PSA_PAKE_ROLE_NONE can be passed as \\c role.\n\n Refer to the documentation of individual PAKE algorithm types (`PSA_ALG_XXX`\n values of type ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\\c alg) is true)\n for more information.\n\n \\param[in,out] operation     The operation object to specify the\n                              application's role for. It must have been set up\n                              by psa_pake_setup() and not yet in use (neither\n                              psa_pake_output() nor psa_pake_input() has been\n                              called yet). It must be on operation for which\n                              the application's role hasn't been specified\n                              (psa_pake_set_role() hasn't been called yet).\n \\param role                  A value of type ::psa_pake_role_t indicating the\n                              application's role in the PAKE the algorithm\n                              that is being set up. For more information see\n                              the documentation of \\c PSA_PAKE_ROLE_XXX\n                              constants.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The \\p role is not a valid PAKE role in the \\p operation’s algorithm.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         The \\p role for this algorithm is not supported or is not valid.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid, or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_pake_set_role(
        operation: *mut psa_pake_operation_t,
        role: psa_pake_role_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Get output for a step of a password-authenticated key exchange.\n\n Depending on the algorithm being executed, you might need to call this\n function several times or you might not need to call this at all.\n\n The exact sequence of calls to perform a password-authenticated key\n exchange depends on the algorithm in use.  Refer to the documentation of\n individual PAKE algorithm types (`PSA_ALG_XXX` values of type\n ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\\c alg) is true) for more\n information.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_pake_abort().\n\n \\param[in,out] operation    Active PAKE operation.\n \\param step                 The step of the algorithm for which the output is\n                             requested.\n \\param[out] output          Buffer where the output is to be written in the\n                             format appropriate for this \\p step. Refer to\n                             the documentation of the individual\n                             \\c PSA_PAKE_STEP_XXX constants for more\n                             information.\n \\param output_size          Size of the \\p output buffer in bytes. This must\n                             be at least #PSA_PAKE_OUTPUT_SIZE(\\p alg, \\p\n                             primitive, \\p step) where \\p alg and\n                             \\p primitive are the PAKE algorithm and primitive\n                             in the operation's cipher suite, and \\p step is\n                             the output step.\n\n \\param[out] output_length   On success, the number of bytes of the returned\n                             output.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p output buffer is too small.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p step is not compatible with the operation's algorithm.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p step is not supported with the operation's algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription\n \\retval #PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active, and fully set\n         up, and this call must conform to the algorithm's requirements\n         for ordering of input and output steps), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_pake_output(
        operation: *mut psa_pake_operation_t,
        step: psa_pake_step_t,
        output: *mut u8,
        output_size: usize,
        output_length: *mut usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Provide input for a step of a password-authenticated key exchange.\n\n Depending on the algorithm being executed, you might need to call this\n function several times or you might not need to call this at all.\n\n The exact sequence of calls to perform a password-authenticated key\n exchange depends on the algorithm in use.  Refer to the documentation of\n individual PAKE algorithm types (`PSA_ALG_XXX` values of type\n ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\\c alg) is true) for more\n information.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_pake_abort().\n\n \\param[in,out] operation    Active PAKE operation.\n \\param step                 The step for which the input is provided.\n \\param[in] input            Buffer containing the input in the format\n                             appropriate for this \\p step. Refer to the\n                             documentation of the individual\n                             \\c PSA_PAKE_STEP_XXX constants for more\n                             information.\n \\param input_length         Size of the \\p input buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The verification fails for a #PSA_PAKE_STEP_ZK_PROOF input step.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p is not compatible with the \\p operation’s algorithm, or the\n         \\p input is not valid for the \\p operation's algorithm, cipher suite\n         or \\p step.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p step p is not supported with the \\p operation's algorithm, or the\n         \\p input is not supported for the \\p operation's algorithm, cipher\n         suite or \\p step.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription\n \\retval #PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active, and fully set\n         up, and this call must conform to the algorithm's requirements\n         for ordering of input and output steps), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_pake_input(
        operation: *mut psa_pake_operation_t,
        step: psa_pake_step_t,
        input: *const u8,
        input_length: usize,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Get implicitly confirmed shared secret from a PAKE.\n\n At this point there is a cryptographic guarantee that only the authenticated\n party who used the same password is able to compute the key. But there is no\n guarantee that the peer is the party it claims to be and was able to do so.\n\n That is, the authentication is only implicit. Since the peer is not\n authenticated yet, no action should be taken yet that assumes that the peer\n is who it claims to be. For example, do not access restricted files on the\n peer's behalf until an explicit authentication has succeeded.\n\n This function can be called after the key exchange phase of the operation\n has completed. It imports the shared secret output of the PAKE into the\n provided derivation operation. The input step\n #PSA_KEY_DERIVATION_INPUT_SECRET is used when placing the shared key\n material in the key derivation operation.\n\n The exact sequence of calls to perform a password-authenticated key\n exchange depends on the algorithm in use.  Refer to the documentation of\n individual PAKE algorithm types (`PSA_ALG_XXX` values of type\n ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\\c alg) is true) for more\n information.\n\n When this function returns successfully, \\p operation becomes inactive.\n If this function returns an error status, both \\p operation\n and \\p key_derivation operations enter an error state and must be aborted by\n calling psa_pake_abort() and psa_key_derivation_abort() respectively.\n\n \\param[in,out] operation    Active PAKE operation.\n \\param[out] output          A key derivation operation that is ready\n                             for an input step of type\n                             #PSA_KEY_DERIVATION_INPUT_SECRET.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         #PSA_KEY_DERIVATION_INPUT_SECRET is not compatible with the\n         algorithm in the \\p output key derivation operation.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         Input from a PAKE is not supported by the algorithm in the \\p output\n         key derivation operation.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription\n \\retval #PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The PAKE operation state is not valid (it must be active, but beyond\n         that validity is specific to the algorithm), or\n         the library has not been previously initialized by psa_crypto_init(),\n         or the state of \\p output is not valid for\n         the #PSA_KEY_DERIVATION_INPUT_SECRET step. This can happen if the\n         step is out of order or the application has done this step already\n         and it may not be repeated.\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_pake_get_implicit_key(
        operation: *mut psa_pake_operation_t,
        output: *mut psa_key_derivation_operation_t,
    ) -> psa_status_t;
}
extern "C" {
    #[doc = " Abort a PAKE operation.\n\n Aborting an operation frees all associated resources except for the \\c\n operation structure itself. Once aborted, the operation object can be reused\n for another operation by calling psa_pake_setup() again.\n\n This function may be called at any time after the operation\n object has been initialized as described in #psa_pake_operation_t.\n\n In particular, calling psa_pake_abort() after the operation has been\n terminated by a call to psa_pake_abort() or psa_pake_get_implicit_key()\n is safe and has no effect.\n\n \\param[in,out] operation    The operation to abort.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
    pub fn psa_pake_abort(operation: *mut psa_pake_operation_t) -> psa_status_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_pake_cipher_suite_s {
    pub algorithm: psa_algorithm_t,
    pub type_: psa_pake_primitive_type_t,
    pub family: psa_pake_family_t,
    pub bits: u16,
    pub hash: psa_algorithm_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_crypto_driver_pake_inputs_s {
    pub private_password: *mut u8,
    pub private_password_len: usize,
    pub private_role: psa_pake_role_t,
    pub private_user: *mut u8,
    pub private_user_len: usize,
    pub private_peer: *mut u8,
    pub private_peer_len: usize,
    pub private_attributes: psa_key_attributes_t,
    pub private_cipher_suite: psa_pake_cipher_suite_t,
}
pub const psa_jpake_step_PSA_PAKE_STEP_INVALID: psa_jpake_step = 0;
pub const psa_jpake_step_PSA_PAKE_STEP_X1_X2: psa_jpake_step = 1;
pub const psa_jpake_step_PSA_PAKE_STEP_X2S: psa_jpake_step = 2;
pub const psa_jpake_step_PSA_PAKE_STEP_DERIVE: psa_jpake_step = 3;
pub type psa_jpake_step = crate::c_types::c_uint;
pub use self::psa_jpake_step as psa_jpake_step_t;
pub const psa_jpake_state_PSA_PAKE_STATE_INVALID: psa_jpake_state = 0;
pub const psa_jpake_state_PSA_PAKE_STATE_SETUP: psa_jpake_state = 1;
pub const psa_jpake_state_PSA_PAKE_STATE_READY: psa_jpake_state = 2;
pub const psa_jpake_state_PSA_PAKE_OUTPUT_X1_X2: psa_jpake_state = 3;
pub const psa_jpake_state_PSA_PAKE_OUTPUT_X2S: psa_jpake_state = 4;
pub const psa_jpake_state_PSA_PAKE_INPUT_X1_X2: psa_jpake_state = 5;
pub const psa_jpake_state_PSA_PAKE_INPUT_X4S: psa_jpake_state = 6;
pub type psa_jpake_state = crate::c_types::c_uint;
pub use self::psa_jpake_state as psa_jpake_state_t;
pub const psa_jpake_sequence_PSA_PAKE_SEQ_INVALID: psa_jpake_sequence = 0;
pub const psa_jpake_sequence_PSA_PAKE_X1_STEP_KEY_SHARE: psa_jpake_sequence = 1;
pub const psa_jpake_sequence_PSA_PAKE_X1_STEP_ZK_PUBLIC: psa_jpake_sequence = 2;
pub const psa_jpake_sequence_PSA_PAKE_X1_STEP_ZK_PROOF: psa_jpake_sequence = 3;
pub const psa_jpake_sequence_PSA_PAKE_X2_STEP_KEY_SHARE: psa_jpake_sequence = 4;
pub const psa_jpake_sequence_PSA_PAKE_X2_STEP_ZK_PUBLIC: psa_jpake_sequence = 5;
pub const psa_jpake_sequence_PSA_PAKE_X2_STEP_ZK_PROOF: psa_jpake_sequence = 6;
pub const psa_jpake_sequence_PSA_PAKE_SEQ_END: psa_jpake_sequence = 7;
pub type psa_jpake_sequence = crate::c_types::c_uint;
pub use self::psa_jpake_sequence as psa_jpake_sequence_t;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_STEP_INVALID: psa_crypto_driver_pake_step = 0;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X1_STEP_KEY_SHARE: psa_crypto_driver_pake_step = 1;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X1_STEP_ZK_PUBLIC: psa_crypto_driver_pake_step = 2;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X1_STEP_ZK_PROOF: psa_crypto_driver_pake_step = 3;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X2_STEP_KEY_SHARE: psa_crypto_driver_pake_step = 4;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X2_STEP_ZK_PUBLIC: psa_crypto_driver_pake_step = 5;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X2_STEP_ZK_PROOF: psa_crypto_driver_pake_step = 6;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X2S_STEP_KEY_SHARE: psa_crypto_driver_pake_step = 7;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X2S_STEP_ZK_PUBLIC: psa_crypto_driver_pake_step = 8;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X2S_STEP_ZK_PROOF: psa_crypto_driver_pake_step = 9;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X4S_STEP_KEY_SHARE: psa_crypto_driver_pake_step =
    10;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X4S_STEP_ZK_PUBLIC: psa_crypto_driver_pake_step =
    11;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X4S_STEP_ZK_PROOF: psa_crypto_driver_pake_step = 12;
pub type psa_crypto_driver_pake_step = crate::c_types::c_uint;
pub use self::psa_crypto_driver_pake_step as psa_crypto_driver_pake_step_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_jpake_computation_stage_s {
    pub private_state: psa_jpake_state_t,
    pub private_sequence: psa_jpake_sequence_t,
    pub private_input_step: psa_jpake_step_t,
    pub private_output_step: psa_jpake_step_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_pake_operation_s {
    pub private_id: crate::c_types::c_uint,
    pub private_alg: psa_algorithm_t,
    pub private_stage: u8,
    pub private_computation_stage: psa_pake_operation_s__bindgen_ty_1,
    pub private_data: psa_pake_operation_s__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_pake_operation_s__bindgen_ty_1 {
    pub private_dummy: u8,
    pub private_jpake: psa_jpake_computation_stage_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_pake_operation_s__bindgen_ty_2 {
    pub private_ctx: psa_driver_pake_context_t,
    pub private_inputs: psa_crypto_driver_pake_inputs_t,
}
#[doc = " Type-length-value structure that allows for ASN1 using DER."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_asn1_buf {
    #[doc = "< ASN1 type, e.g. MBEDTLS_ASN1_UTF8_STRING."]
    pub tag: crate::c_types::c_int,
    #[doc = "< ASN1 length, in octets."]
    pub len: usize,
    #[doc = "< ASN1 data, e.g. in ASCII."]
    pub p: *mut crate::c_types::c_uchar,
}
#[doc = " Container for ASN1 bit strings."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_asn1_bitstring {
    #[doc = "< ASN1 length, in octets."]
    pub len: usize,
    #[doc = "< Number of unused bits at the end of the string"]
    pub unused_bits: crate::c_types::c_uchar,
    #[doc = "< Raw ASN1 data for the bit string"]
    pub p: *mut crate::c_types::c_uchar,
}
#[doc = " Container for a sequence of ASN.1 items"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_asn1_sequence {
    #[doc = "< Buffer containing the given ASN.1 item."]
    pub buf: mbedtls_asn1_buf,
    #[doc = " The next entry in the sequence.\n\n The details of memory management for sequences are not documented and\n may change in future versions. Set this field to \\p NULL when\n initializing a structure, and do not modify it except via Mbed TLS\n library functions."]
    pub next: *mut mbedtls_asn1_sequence,
}
#[doc = " Container for a sequence or list of 'named' ASN.1 data items"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_asn1_named_data {
    #[doc = "< The object identifier."]
    pub oid: mbedtls_asn1_buf,
    #[doc = "< The named value."]
    pub val: mbedtls_asn1_buf,
    #[doc = " The next entry in the sequence.\n\n The details of memory management for named data sequences are not\n documented and may change in future versions. Set this field to \\p NULL\n when initializing a structure, and do not modify it except via Mbed TLS\n library functions."]
    pub next: *mut mbedtls_asn1_named_data,
    pub private_next_merged: crate::c_types::c_uchar,
}
extern "C" {
    #[doc = " \\brief       Get the length of an ASN.1 element.\n              Updates the pointer to immediately behind the length.\n\n \\param p     On entry, \\c *p points to the first byte of the length,\n              i.e. immediately after the tag.\n              On successful completion, \\c *p points to the first byte\n              after the length, i.e. the first byte of the content.\n              On error, the value of \\c *p is undefined.\n \\param end   End of data.\n \\param len   On successful completion, \\c *len contains the length\n              read from the ASN.1 input.\n\n \\return      0 if successful.\n \\return      #MBEDTLS_ERR_ASN1_OUT_OF_DATA if the ASN.1 element\n              would end beyond \\p end.\n \\return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the length is unparsable."]
    pub fn mbedtls_asn1_get_len(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        len: *mut usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief       Get the tag and length of the element.\n              Check for the requested tag.\n              Updates the pointer to immediately behind the tag and length.\n\n \\param p     On entry, \\c *p points to the start of the ASN.1 element.\n              On successful completion, \\c *p points to the first byte\n              after the length, i.e. the first byte of the content.\n              On error, the value of \\c *p is undefined.\n \\param end   End of data.\n \\param len   On successful completion, \\c *len contains the length\n              read from the ASN.1 input.\n \\param tag   The expected tag.\n\n \\return      0 if successful.\n \\return      #MBEDTLS_ERR_ASN1_UNEXPECTED_TAG if the data does not start\n              with the requested tag.\n \\return      #MBEDTLS_ERR_ASN1_OUT_OF_DATA if the ASN.1 element\n              would end beyond \\p end.\n \\return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the length is unparsable."]
    pub fn mbedtls_asn1_get_tag(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        len: *mut usize,
        tag: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve a boolean ASN.1 tag and its value.\n              Updates the pointer to immediately behind the full tag.\n\n \\param p     On entry, \\c *p points to the start of the ASN.1 element.\n              On successful completion, \\c *p points to the first byte\n              beyond the ASN.1 element.\n              On error, the value of \\c *p is undefined.\n \\param end   End of data.\n \\param val   On success, the parsed value (\\c 0 or \\c 1).\n\n \\return      0 if successful.\n \\return      An ASN.1 error code if the input does not start with\n              a valid ASN.1 BOOLEAN."]
    pub fn mbedtls_asn1_get_bool(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        val: *mut crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve an integer ASN.1 tag and its value.\n              Updates the pointer to immediately behind the full tag.\n\n \\param p     On entry, \\c *p points to the start of the ASN.1 element.\n              On successful completion, \\c *p points to the first byte\n              beyond the ASN.1 element.\n              On error, the value of \\c *p is undefined.\n \\param end   End of data.\n \\param val   On success, the parsed value.\n\n \\return      0 if successful.\n \\return      An ASN.1 error code if the input does not start with\n              a valid ASN.1 INTEGER.\n \\return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the parsed value does\n              not fit in an \\c int."]
    pub fn mbedtls_asn1_get_int(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        val: *mut crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve an enumerated ASN.1 tag and its value.\n              Updates the pointer to immediately behind the full tag.\n\n \\param p     On entry, \\c *p points to the start of the ASN.1 element.\n              On successful completion, \\c *p points to the first byte\n              beyond the ASN.1 element.\n              On error, the value of \\c *p is undefined.\n \\param end   End of data.\n \\param val   On success, the parsed value.\n\n \\return      0 if successful.\n \\return      An ASN.1 error code if the input does not start with\n              a valid ASN.1 ENUMERATED.\n \\return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the parsed value does\n              not fit in an \\c int."]
    pub fn mbedtls_asn1_get_enum(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        val: *mut crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve a bitstring ASN.1 tag and its value.\n              Updates the pointer to immediately behind the full tag.\n\n \\param p     On entry, \\c *p points to the start of the ASN.1 element.\n              On successful completion, \\c *p is equal to \\p end.\n              On error, the value of \\c *p is undefined.\n \\param end   End of data.\n \\param bs    On success, ::mbedtls_asn1_bitstring information about\n              the parsed value.\n\n \\return      0 if successful.\n \\return      #MBEDTLS_ERR_ASN1_LENGTH_MISMATCH if the input contains\n              extra data after a valid BIT STRING.\n \\return      An ASN.1 error code if the input does not start with\n              a valid ASN.1 BIT STRING."]
    pub fn mbedtls_asn1_get_bitstring(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        bs: *mut mbedtls_asn1_bitstring,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve a bitstring ASN.1 tag without unused bits and its\n              value.\n              Updates the pointer to the beginning of the bit/octet string.\n\n \\param p     On entry, \\c *p points to the start of the ASN.1 element.\n              On successful completion, \\c *p points to the first byte\n              of the content of the BIT STRING.\n              On error, the value of \\c *p is undefined.\n \\param end   End of data.\n \\param len   On success, \\c *len is the length of the content in bytes.\n\n \\return      0 if successful.\n \\return      #MBEDTLS_ERR_ASN1_INVALID_DATA if the input starts with\n              a valid BIT STRING with a nonzero number of unused bits.\n \\return      An ASN.1 error code if the input does not start with\n              a valid ASN.1 BIT STRING."]
    pub fn mbedtls_asn1_get_bitstring_null(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        len: *mut usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief       Parses and splits an ASN.1 \"SEQUENCE OF <tag>\".\n              Updates the pointer to immediately behind the full sequence tag.\n\n This function allocates memory for the sequence elements. You can free\n the allocated memory with mbedtls_asn1_sequence_free().\n\n \\note        On error, this function may return a partial list in \\p cur.\n              You must set `cur->next = NULL` before calling this function!\n              Otherwise it is impossible to distinguish a previously non-null\n              pointer from a pointer to an object allocated by this function.\n\n \\note        If the sequence is empty, this function does not modify\n              \\c *cur. If the sequence is valid and non-empty, this\n              function sets `cur->buf.tag` to \\p tag. This allows\n              callers to distinguish between an empty sequence and\n              a one-element sequence.\n\n \\param p     On entry, \\c *p points to the start of the ASN.1 element.\n              On successful completion, \\c *p is equal to \\p end.\n              On error, the value of \\c *p is undefined.\n \\param end   End of data.\n \\param cur   A ::mbedtls_asn1_sequence which this function fills.\n              When this function returns, \\c *cur is the head of a linked\n              list. Each node in this list is allocated with\n              mbedtls_calloc() apart from \\p cur itself, and should\n              therefore be freed with mbedtls_free().\n              The list describes the content of the sequence.\n              The head of the list (i.e. \\c *cur itself) describes the\n              first element, `*cur->next` describes the second element, etc.\n              For each element, `buf.tag == tag`, `buf.len` is the length\n              of the content of the content of the element, and `buf.p`\n              points to the first byte of the content (i.e. immediately\n              past the length of the element).\n              Note that list elements may be allocated even on error.\n \\param tag   Each element of the sequence must have this tag.\n\n \\return      0 if successful.\n \\return      #MBEDTLS_ERR_ASN1_LENGTH_MISMATCH if the input contains\n              extra data after a valid SEQUENCE OF \\p tag.\n \\return      #MBEDTLS_ERR_ASN1_UNEXPECTED_TAG if the input starts with\n              an ASN.1 SEQUENCE in which an element has a tag that\n              is different from \\p tag.\n \\return      #MBEDTLS_ERR_ASN1_ALLOC_FAILED if a memory allocation failed.\n \\return      An ASN.1 error code if the input does not start with\n              a valid ASN.1 SEQUENCE."]
    pub fn mbedtls_asn1_get_sequence_of(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        cur: *mut mbedtls_asn1_sequence,
        tag: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Free a heap-allocated linked list presentation of\n                 an ASN.1 sequence, including the first element.\n\n There are two common ways to manage the memory used for the representation\n of a parsed ASN.1 sequence:\n - Allocate a head node `mbedtls_asn1_sequence *head` with mbedtls_calloc().\n   Pass this node as the `cur` argument to mbedtls_asn1_get_sequence_of().\n   When you have finished processing the sequence,\n   call mbedtls_asn1_sequence_free() on `head`.\n - Allocate a head node `mbedtls_asn1_sequence *head` in any manner,\n   for example on the stack. Make sure that `head->next == NULL`.\n   Pass `head` as the `cur` argument to mbedtls_asn1_get_sequence_of().\n   When you have finished processing the sequence,\n   call mbedtls_asn1_sequence_free() on `head->cur`,\n   then free `head` itself in the appropriate manner.\n\n \\param seq      The address of the first sequence component. This may\n                 be \\c NULL, in which case this functions returns\n                 immediately."]
    pub fn mbedtls_asn1_sequence_free(seq: *mut mbedtls_asn1_sequence);
}
extern "C" {
    #[doc = " \\brief                Traverse an ASN.1 SEQUENCE container and\n                       call a callback for each entry.\n\n This function checks that the input is a SEQUENCE of elements that\n each have a \"must\" tag, and calls a callback function on the elements\n that have a \"may\" tag.\n\n For example, to validate that the input is a SEQUENCE of `tag1` and call\n `cb` on each element, use\n ```\n mbedtls_asn1_traverse_sequence_of(&p, end, 0xff, tag1, 0, 0, cb, ctx);\n ```\n\n To validate that the input is a SEQUENCE of ANY and call `cb` on\n each element, use\n ```\n mbedtls_asn1_traverse_sequence_of(&p, end, 0, 0, 0, 0, cb, ctx);\n ```\n\n To validate that the input is a SEQUENCE of CHOICE {NULL, OCTET STRING}\n and call `cb` on each element that is an OCTET STRING, use\n ```\n mbedtls_asn1_traverse_sequence_of(&p, end, 0xfe, 0x04, 0xff, 0x04, cb, ctx);\n ```\n\n The callback is called on the elements with a \"may\" tag from left to\n right. If the input is not a valid SEQUENCE of elements with a \"must\" tag,\n the callback is called on the elements up to the leftmost point where\n the input is invalid.\n\n \\warning              This function is still experimental and may change\n                       at any time.\n\n \\param p              The address of the pointer to the beginning of\n                       the ASN.1 SEQUENCE header. This is updated to\n                       point to the end of the ASN.1 SEQUENCE container\n                       on a successful invocation.\n \\param end            The end of the ASN.1 SEQUENCE container.\n \\param tag_must_mask  A mask to be applied to the ASN.1 tags found within\n                       the SEQUENCE before comparing to \\p tag_must_value.\n \\param tag_must_val   The required value of each ASN.1 tag found in the\n                       SEQUENCE, after masking with \\p tag_must_mask.\n                       Mismatching tags lead to an error.\n                       For example, a value of \\c 0 for both \\p tag_must_mask\n                       and \\p tag_must_val means that every tag is allowed,\n                       while a value of \\c 0xFF for \\p tag_must_mask means\n                       that \\p tag_must_val is the only allowed tag.\n \\param tag_may_mask   A mask to be applied to the ASN.1 tags found within\n                       the SEQUENCE before comparing to \\p tag_may_value.\n \\param tag_may_val    The desired value of each ASN.1 tag found in the\n                       SEQUENCE, after masking with \\p tag_may_mask.\n                       Mismatching tags will be silently ignored.\n                       For example, a value of \\c 0 for \\p tag_may_mask and\n                       \\p tag_may_val means that any tag will be considered,\n                       while a value of \\c 0xFF for \\p tag_may_mask means\n                       that all tags with value different from \\p tag_may_val\n                       will be ignored.\n \\param cb             The callback to trigger for each component\n                       in the ASN.1 SEQUENCE that matches \\p tag_may_val.\n                       The callback function is called with the following\n                       parameters:\n                       - \\p ctx.\n                       - The tag of the current element.\n                       - A pointer to the start of the current element's\n                         content inside the input.\n                       - The length of the content of the current element.\n                       If the callback returns a non-zero value,\n                       the function stops immediately,\n                       forwarding the callback's return value.\n \\param ctx            The context to be passed to the callback \\p cb.\n\n \\return               \\c 0 if successful the entire ASN.1 SEQUENCE\n                       was traversed without parsing or callback errors.\n \\return               #MBEDTLS_ERR_ASN1_LENGTH_MISMATCH if the input\n                       contains extra data after a valid SEQUENCE\n                       of elements with an accepted tag.\n \\return               #MBEDTLS_ERR_ASN1_UNEXPECTED_TAG if the input starts\n                       with an ASN.1 SEQUENCE in which an element has a tag\n                       that is not accepted.\n \\return               An ASN.1 error code if the input does not start with\n                       a valid ASN.1 SEQUENCE.\n \\return               A non-zero error code forwarded from the callback\n                       \\p cb in case the latter returns a non-zero value."]
    pub fn mbedtls_asn1_traverse_sequence_of(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        tag_must_mask: crate::c_types::c_uchar,
        tag_must_val: crate::c_types::c_uchar,
        tag_may_mask: crate::c_types::c_uchar,
        tag_may_val: crate::c_types::c_uchar,
        cb: ::core::option::Option<
            unsafe extern "C" fn(
                ctx: *mut crate::c_types::c_void,
                tag: crate::c_types::c_int,
                start: *mut crate::c_types::c_uchar,
                len: usize,
            ) -> crate::c_types::c_int,
        >,
        ctx: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve an integer ASN.1 tag and its value.\n              Updates the pointer to immediately behind the full tag.\n\n \\param p     On entry, \\c *p points to the start of the ASN.1 element.\n              On successful completion, \\c *p points to the first byte\n              beyond the ASN.1 element.\n              On error, the value of \\c *p is undefined.\n \\param end   End of data.\n \\param X     On success, the parsed value.\n\n \\return      0 if successful.\n \\return      An ASN.1 error code if the input does not start with\n              a valid ASN.1 INTEGER.\n \\return      #MBEDTLS_ERR_ASN1_INVALID_LENGTH if the parsed value does\n              not fit in an \\c int.\n \\return      An MPI error code if the parsed value is too large."]
    pub fn mbedtls_asn1_get_mpi(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        X: *mut mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve an AlgorithmIdentifier ASN.1 sequence.\n              Updates the pointer to immediately behind the full\n              AlgorithmIdentifier.\n\n \\param p     On entry, \\c *p points to the start of the ASN.1 element.\n              On successful completion, \\c *p points to the first byte\n              beyond the AlgorithmIdentifier element.\n              On error, the value of \\c *p is undefined.\n \\param end   End of data.\n \\param alg   The buffer to receive the OID.\n \\param params The buffer to receive the parameters.\n              This is zeroized if there are no parameters.\n\n \\return      0 if successful or a specific ASN.1 or MPI error code."]
    pub fn mbedtls_asn1_get_alg(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        alg: *mut mbedtls_asn1_buf,
        params: *mut mbedtls_asn1_buf,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief       Retrieve an AlgorithmIdentifier ASN.1 sequence with NULL or no\n              params.\n              Updates the pointer to immediately behind the full\n              AlgorithmIdentifier.\n\n \\param p     On entry, \\c *p points to the start of the ASN.1 element.\n              On successful completion, \\c *p points to the first byte\n              beyond the AlgorithmIdentifier element.\n              On error, the value of \\c *p is undefined.\n \\param end   End of data.\n \\param alg   The buffer to receive the OID.\n\n \\return      0 if successful or a specific ASN.1 or MPI error code."]
    pub fn mbedtls_asn1_get_alg_null(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        alg: *mut mbedtls_asn1_buf,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief       Find a specific named_data entry in a sequence or list based on\n              the OID.\n\n \\param list  The list to seek through\n \\param oid   The OID to look for\n \\param len   Size of the OID\n\n \\return      NULL if not found, or a pointer to the existing entry."]
    pub fn mbedtls_asn1_find_named_data(
        list: *const mbedtls_asn1_named_data,
        oid: *const crate::c_types::c_char,
        len: usize,
    ) -> *const mbedtls_asn1_named_data;
}
extern "C" {
    #[doc = " \\brief       Free a mbedtls_asn1_named_data entry\n\n \\deprecated  This function is deprecated and will be removed in a\n              future version of the library.\n              Please use mbedtls_asn1_free_named_data_list()\n              or mbedtls_asn1_free_named_data_list_shallow().\n\n \\param entry The named data entry to free.\n              This function calls mbedtls_free() on\n              `entry->oid.p` and `entry->val.p`."]
    pub fn mbedtls_asn1_free_named_data(entry: *mut mbedtls_asn1_named_data);
}
extern "C" {
    #[doc = " \\brief       Free all entries in a mbedtls_asn1_named_data list.\n\n \\param head  Pointer to the head of the list of named data entries to free.\n              This function calls mbedtls_free() on\n              `entry->oid.p` and `entry->val.p` and then on `entry`\n              for each list entry, and sets \\c *head to \\c NULL."]
    pub fn mbedtls_asn1_free_named_data_list(head: *mut *mut mbedtls_asn1_named_data);
}
extern "C" {
    #[doc = " \\brief       Free all shallow entries in a mbedtls_asn1_named_data list,\n              but do not free internal pointer targets.\n\n \\param name  Head of the list of named data entries to free.\n              This function calls mbedtls_free() on each list element."]
    pub fn mbedtls_asn1_free_named_data_list_shallow(name: *mut mbedtls_asn1_named_data);
}
#[doc = " Type-length-value structure that allows for ASN1 using DER."]
pub type mbedtls_x509_buf = mbedtls_asn1_buf;
#[doc = " Container for ASN1 bit strings."]
pub type mbedtls_x509_bitstring = mbedtls_asn1_bitstring;
#[doc = " Container for ASN1 named information objects.\n It allows for Relative Distinguished Names (e.g. cn=localhost,ou=code,etc.)."]
pub type mbedtls_x509_name = mbedtls_asn1_named_data;
#[doc = " Container for a sequence of ASN.1 items"]
pub type mbedtls_x509_sequence = mbedtls_asn1_sequence;
#[doc = " Container for date and time (precision in seconds)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_time {
    #[doc = "< Date."]
    pub year: crate::c_types::c_int,
    #[doc = "< Date."]
    pub mon: crate::c_types::c_int,
    #[doc = "< Date."]
    pub day: crate::c_types::c_int,
    #[doc = "< Time."]
    pub hour: crate::c_types::c_int,
    #[doc = "< Time."]
    pub min: crate::c_types::c_int,
    #[doc = "< Time."]
    pub sec: crate::c_types::c_int,
}
#[doc = " From RFC 5280 section 4.2.1.6:\n OtherName ::= SEQUENCE {\n      type-id    OBJECT IDENTIFIER,\n      value      [0] EXPLICIT ANY DEFINED BY type-id }\n\n Future versions of the library may add new fields to this structure or\n to its embedded union and structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_san_other_name {
    #[doc = "< The type id."]
    pub type_id: mbedtls_x509_buf,
    pub value: mbedtls_x509_san_other_name__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_x509_san_other_name__bindgen_ty_1 {
    pub hardware_module_name: mbedtls_x509_san_other_name__bindgen_ty_1__bindgen_ty_1,
}
#[doc = " From RFC 4108 section 5:\n HardwareModuleName ::= SEQUENCE {\n                         hwType OBJECT IDENTIFIER,\n                         hwSerialNum OCTET STRING }"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_san_other_name__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< The object identifier."]
    pub oid: mbedtls_x509_buf,
    #[doc = "< The named value."]
    pub val: mbedtls_x509_buf,
}
#[doc = " A structure for holding the parsed Subject Alternative Name,\n according to type.\n\n Future versions of the library may add new fields to this structure or\n to its embedded union and structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_subject_alternative_name {
    #[doc = "< The SAN type, value of MBEDTLS_X509_SAN_XXX."]
    pub type_: crate::c_types::c_int,
    #[doc = "< A union of the supported SAN types"]
    pub san: mbedtls_x509_subject_alternative_name__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_x509_subject_alternative_name__bindgen_ty_1 {
    #[doc = "< The otherName supported type."]
    pub other_name: mbedtls_x509_san_other_name,
    #[doc = "< The buffer for the unconstructed types. Only rfc822Name, dnsName and uniformResourceIdentifier are currently supported"]
    pub unstructured_name: mbedtls_x509_buf,
}
extern "C" {
    #[doc = " \\brief          Store the certificate DN in printable form into buf;\n                 no more than size characters will be written.\n\n \\param buf      Buffer to write to\n \\param size     Maximum size of buffer\n \\param dn       The X509 name to represent\n\n \\return         The length of the string written (not including the\n                 terminated nul byte), or a negative error code."]
    pub fn mbedtls_x509_dn_gets(
        buf: *mut crate::c_types::c_char,
        size: usize,
        dn: *const mbedtls_x509_name,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Store the certificate serial in printable form into buf;\n                 no more than size characters will be written.\n\n \\param buf      Buffer to write to\n \\param size     Maximum size of buffer\n \\param serial   The X509 serial to represent\n\n \\return         The length of the string written (not including the\n                 terminated nul byte), or a negative error code."]
    pub fn mbedtls_x509_serial_gets(
        buf: *mut crate::c_types::c_char,
        size: usize,
        serial: *const mbedtls_x509_buf,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Check a given mbedtls_x509_time against the system time\n                 and tell if it's in the past.\n\n \\note           Intended usage is \"if( is_past( valid_to ) ) ERROR\".\n                 Hence the return value of 1 if on internal errors.\n\n \\param to       mbedtls_x509_time to check\n\n \\return         1 if the given time is in the past or an error occurred,\n                 0 otherwise."]
    pub fn mbedtls_x509_time_is_past(to: *const mbedtls_x509_time) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Check a given mbedtls_x509_time against the system time\n                 and tell if it's in the future.\n\n \\note           Intended usage is \"if( is_future( valid_from ) ) ERROR\".\n                 Hence the return value of 1 if on internal errors.\n\n \\param from     mbedtls_x509_time to check\n\n \\return         1 if the given time is in the future or an error occurred,\n                 0 otherwise."]
    pub fn mbedtls_x509_time_is_future(from: *const mbedtls_x509_time) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function parses an item in the SubjectAlternativeNames\n                 extension.\n\n \\param san_buf  The buffer holding the raw data item of the subject\n                 alternative name.\n \\param san      The target structure to populate with the parsed presentation\n                 of the subject alternative name encoded in \\p san_raw.\n\n \\note           Supported GeneralName types, as defined in RFC 5280:\n                 \"rfc822Name\", \"dnsName\", \"uniformResourceIdentifier\" and \"hardware_module_name\"\n                 of type \"otherName\", as defined in RFC 4108.\n\n \\note           This function should be called on a single raw data of\n                 subject alternative name. For example, after successful\n                 certificate parsing, one must iterate on every item in the\n                 \\p crt->subject_alt_names sequence, and pass it to\n                 this function.\n\n \\warning        The target structure contains pointers to the raw data of the\n                 parsed certificate, and its lifetime is restricted by the\n                 lifetime of the certificate.\n\n \\return         \\c 0 on success\n \\return         #MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE for an unsupported\n                 SAN type.\n \\return         Another negative value for any other failure."]
    pub fn mbedtls_x509_parse_subject_alt_name(
        san_buf: *const mbedtls_x509_buf,
        san: *mut mbedtls_x509_subject_alternative_name,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\} addtogroup x509_module"]
    pub fn mbedtls_x509_get_name(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        cur: *mut mbedtls_x509_name,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_alg_null(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        alg: *mut mbedtls_x509_buf,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_alg(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        alg: *mut mbedtls_x509_buf,
        params: *mut mbedtls_x509_buf,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_rsassa_pss_params(
        params: *const mbedtls_x509_buf,
        md_alg: *mut mbedtls_md_type_t,
        mgf_md: *mut mbedtls_md_type_t,
        salt_len: *mut crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_sig(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        sig: *mut mbedtls_x509_buf,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_sig_alg(
        sig_oid: *const mbedtls_x509_buf,
        sig_params: *const mbedtls_x509_buf,
        md_alg: *mut mbedtls_md_type_t,
        pk_alg: *mut mbedtls_pk_type_t,
        sig_opts: *mut *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_time(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        t: *mut mbedtls_x509_time,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_serial(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        serial: *mut mbedtls_x509_buf,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_ext(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        ext: *mut mbedtls_x509_buf,
        tag: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_sig_alg_gets(
        buf: *mut crate::c_types::c_char,
        size: usize,
        sig_oid: *const mbedtls_x509_buf,
        pk_alg: mbedtls_pk_type_t,
        md_alg: mbedtls_md_type_t,
        sig_opts: *const crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_key_size_helper(
        buf: *mut crate::c_types::c_char,
        buf_size: usize,
        name: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_string_to_names(
        head: *mut *mut mbedtls_asn1_named_data,
        name: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_set_extension(
        head: *mut *mut mbedtls_asn1_named_data,
        oid: *const crate::c_types::c_char,
        oid_len: usize,
        critical: crate::c_types::c_int,
        val: *const crate::c_types::c_uchar,
        val_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_write_extensions(
        p: *mut *mut crate::c_types::c_uchar,
        start: *mut crate::c_types::c_uchar,
        first: *mut mbedtls_asn1_named_data,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_write_names(
        p: *mut *mut crate::c_types::c_uchar,
        start: *mut crate::c_types::c_uchar,
        first: *mut mbedtls_asn1_named_data,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_write_sig(
        p: *mut *mut crate::c_types::c_uchar,
        start: *mut crate::c_types::c_uchar,
        oid: *const crate::c_types::c_char,
        oid_len: usize,
        sig: *mut crate::c_types::c_uchar,
        size: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_ns_cert_type(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        ns_cert_type: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_key_usage(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        key_usage: *mut crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_get_subject_alt_name(
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        subject_alt_name: *mut mbedtls_x509_sequence,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_info_subject_alt_name(
        buf: *mut *mut crate::c_types::c_char,
        size: *mut usize,
        subject_alt_name: *const mbedtls_x509_sequence,
        prefix: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_info_cert_type(
        buf: *mut *mut crate::c_types::c_char,
        size: *mut usize,
        ns_cert_type: crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    pub fn mbedtls_x509_info_key_usage(
        buf: *mut *mut crate::c_types::c_char,
        size: *mut usize,
        key_usage: crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
#[doc = " Certificate revocation list entry.\n Contains the CA-specific serial numbers and revocation dates.\n\n Some fields of this structure are publicly readable. Do not modify\n them except via Mbed TLS library functions: the effect of modifying\n those fields or the data that those fields points to is unspecified."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_crl_entry {
    #[doc = " Direct access to the whole entry inside the containing buffer."]
    pub raw: mbedtls_x509_buf,
    #[doc = " The serial number of the revoked certificate."]
    pub serial: mbedtls_x509_buf,
    #[doc = " The revocation date of this entry."]
    pub revocation_date: mbedtls_x509_time,
    #[doc = " Direct access to the list of CRL entry extensions\n (an ASN.1 constructed sequence).\n\n If there are no extensions, `entry_ext.len == 0` and\n `entry_ext.p == NULL`."]
    pub entry_ext: mbedtls_x509_buf,
    #[doc = " Next element in the linked list of entries.\n \\p NULL indicates the end of the list.\n Do not modify this field directly."]
    pub next: *mut mbedtls_x509_crl_entry,
}
#[doc = " Certificate revocation list structure.\n Every CRL may have multiple entries."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_crl {
    #[doc = "< The raw certificate data (DER)."]
    pub raw: mbedtls_x509_buf,
    #[doc = "< The raw certificate body (DER). The part that is To Be Signed."]
    pub tbs: mbedtls_x509_buf,
    #[doc = "< CRL version (1=v1, 2=v2)"]
    pub version: crate::c_types::c_int,
    #[doc = "< CRL signature type identifier"]
    pub sig_oid: mbedtls_x509_buf,
    #[doc = "< The raw issuer data (DER)."]
    pub issuer_raw: mbedtls_x509_buf,
    #[doc = "< The parsed issuer data (named information object)."]
    pub issuer: mbedtls_x509_name,
    pub this_update: mbedtls_x509_time,
    pub next_update: mbedtls_x509_time,
    #[doc = "< The CRL entries containing the certificate revocation times for this CA."]
    pub entry: mbedtls_x509_crl_entry,
    pub crl_ext: mbedtls_x509_buf,
    pub private_sig_oid2: mbedtls_x509_buf,
    pub private_sig: mbedtls_x509_buf,
    pub private_sig_md: mbedtls_md_type_t,
    pub private_sig_pk: mbedtls_pk_type_t,
    pub private_sig_opts: *mut crate::c_types::c_void,
    #[doc = " Next element in the linked list of CRL.\n \\p NULL indicates the end of the list.\n Do not modify this field directly."]
    pub next: *mut mbedtls_x509_crl,
}
extern "C" {
    #[doc = " \\brief          Parse a DER-encoded CRL and append it to the chained list\n\n \\note           If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto\n                 subsystem must have been initialized by calling\n                 psa_crypto_init() before calling this function.\n\n \\param chain    points to the start of the chain\n \\param buf      buffer holding the CRL data in DER format\n \\param buflen   size of the buffer\n                 (including the terminating null byte for PEM data)\n\n \\return         0 if successful, or a specific X509 or PEM error code"]
    pub fn mbedtls_x509_crl_parse_der(
        chain: *mut mbedtls_x509_crl,
        buf: *const crate::c_types::c_uchar,
        buflen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Parse one or more CRLs and append them to the chained list\n\n \\note           Multiple CRLs are accepted only if using PEM format\n\n \\note           If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto\n                 subsystem must have been initialized by calling\n                 psa_crypto_init() before calling this function.\n\n \\param chain    points to the start of the chain\n \\param buf      buffer holding the CRL data in PEM or DER format\n \\param buflen   size of the buffer\n                 (including the terminating null byte for PEM data)\n\n \\return         0 if successful, or a specific X509 or PEM error code"]
    pub fn mbedtls_x509_crl_parse(
        chain: *mut mbedtls_x509_crl,
        buf: *const crate::c_types::c_uchar,
        buflen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Returns an informational string about the CRL.\n\n \\param buf      Buffer to write to\n \\param size     Maximum size of buffer\n \\param prefix   A line prefix\n \\param crl      The X509 CRL to represent\n\n \\return         The length of the string written (not including the\n                 terminated nul byte), or a negative error code."]
    pub fn mbedtls_x509_crl_info(
        buf: *mut crate::c_types::c_char,
        size: usize,
        prefix: *const crate::c_types::c_char,
        crl: *const mbedtls_x509_crl,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Initialize a CRL (chain)\n\n \\param crl      CRL chain to initialize"]
    pub fn mbedtls_x509_crl_init(crl: *mut mbedtls_x509_crl);
}
extern "C" {
    #[doc = " \\brief          Unallocate all CRL data\n\n \\param crl      CRL chain to free"]
    pub fn mbedtls_x509_crl_free(crl: *mut mbedtls_x509_crl);
}
#[doc = " Container for an X.509 certificate. The certificate may be chained.\n\n Some fields of this structure are publicly readable. Do not modify\n them except via Mbed TLS library functions: the effect of modifying\n those fields or the data that those fields points to is unspecified."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_crt {
    pub private_own_buffer: crate::c_types::c_int,
    #[doc = "< The raw certificate data (DER)."]
    pub raw: mbedtls_x509_buf,
    #[doc = "< The raw certificate body (DER). The part that is To Be Signed."]
    pub tbs: mbedtls_x509_buf,
    #[doc = "< The X.509 version. (1=v1, 2=v2, 3=v3)"]
    pub version: crate::c_types::c_int,
    #[doc = "< Unique id for certificate issued by a specific CA."]
    pub serial: mbedtls_x509_buf,
    #[doc = "< Signature algorithm, e.g. sha1RSA"]
    pub sig_oid: mbedtls_x509_buf,
    #[doc = "< The raw issuer data (DER). Used for quick comparison."]
    pub issuer_raw: mbedtls_x509_buf,
    #[doc = "< The raw subject data (DER). Used for quick comparison."]
    pub subject_raw: mbedtls_x509_buf,
    #[doc = "< The parsed issuer data (named information object)."]
    pub issuer: mbedtls_x509_name,
    #[doc = "< The parsed subject data (named information object)."]
    pub subject: mbedtls_x509_name,
    #[doc = "< Start time of certificate validity."]
    pub valid_from: mbedtls_x509_time,
    #[doc = "< End time of certificate validity."]
    pub valid_to: mbedtls_x509_time,
    pub pk_raw: mbedtls_x509_buf,
    #[doc = "< Container for the public key context."]
    pub pk: mbedtls_pk_context,
    #[doc = "< Optional X.509 v2/v3 issuer unique identifier."]
    pub issuer_id: mbedtls_x509_buf,
    #[doc = "< Optional X.509 v2/v3 subject unique identifier."]
    pub subject_id: mbedtls_x509_buf,
    #[doc = "< Optional X.509 v3 extensions."]
    pub v3_ext: mbedtls_x509_buf,
    #[doc = "< Optional list of raw entries of Subject Alternative Names extension (currently only dNSName, uniformResourceIdentifier and OtherName are listed)."]
    pub subject_alt_names: mbedtls_x509_sequence,
    #[doc = "< Optional list of certificate policies (Only anyPolicy is printed and enforced, however the rest of the policies are still listed)."]
    pub certificate_policies: mbedtls_x509_sequence,
    pub private_ext_types: crate::c_types::c_int,
    pub private_ca_istrue: crate::c_types::c_int,
    pub private_max_pathlen: crate::c_types::c_int,
    pub private_key_usage: crate::c_types::c_uint,
    #[doc = "< Optional list of extended key usage OIDs."]
    pub ext_key_usage: mbedtls_x509_sequence,
    pub private_ns_cert_type: crate::c_types::c_uchar,
    pub private_sig: mbedtls_x509_buf,
    pub private_sig_md: mbedtls_md_type_t,
    pub private_sig_pk: mbedtls_pk_type_t,
    pub private_sig_opts: *mut crate::c_types::c_void,
    #[doc = " Next certificate in the linked list that constitutes the CA chain.\n \\p NULL indicates the end of the list.\n Do not modify this field directly."]
    pub next: *mut mbedtls_x509_crt,
}
#[doc = " Security profile for certificate verification.\n\n All lists are bitfields, built by ORing flags from MBEDTLS_X509_ID_FLAG().\n\n The fields of this structure are part of the public API and can be\n manipulated directly by applications. Future versions of the library may\n add extra fields or reorder existing fields.\n\n You can create custom profiles by starting from a copy of\n an existing profile, such as mbedtls_x509_crt_profile_default or\n mbedtls_x509_ctr_profile_none and then tune it to your needs.\n\n For example to allow SHA-224 in addition to the default:\n\n  mbedtls_x509_crt_profile my_profile = mbedtls_x509_crt_profile_default;\n  my_profile.allowed_mds |= MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA224 );\n\n Or to allow only RSA-3072+ with SHA-256:\n\n  mbedtls_x509_crt_profile my_profile = mbedtls_x509_crt_profile_none;\n  my_profile.allowed_mds = MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA256 );\n  my_profile.allowed_pks = MBEDTLS_X509_ID_FLAG( MBEDTLS_PK_RSA );\n  my_profile.rsa_min_bitlen = 3072;"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_crt_profile {
    #[doc = "< MDs for signatures"]
    pub allowed_mds: u32,
    #[doc = "< PK algs for public keys;\n   this applies to all certificates\n   in the provided chain."]
    pub allowed_pks: u32,
    #[doc = "< Elliptic curves for ECDSA"]
    pub allowed_curves: u32,
    #[doc = "< Minimum size for RSA keys"]
    pub rsa_min_bitlen: u32,
}
#[doc = " Container for writing a certificate (CRT)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509write_cert {
    pub private_version: crate::c_types::c_int,
    pub private_serial: [crate::c_types::c_uchar; 20usize],
    pub private_serial_len: usize,
    pub private_subject_key: *mut mbedtls_pk_context,
    pub private_issuer_key: *mut mbedtls_pk_context,
    pub private_subject: *mut mbedtls_asn1_named_data,
    pub private_issuer: *mut mbedtls_asn1_named_data,
    pub private_md_alg: mbedtls_md_type_t,
    pub private_not_before: [crate::c_types::c_char; 16usize],
    pub private_not_after: [crate::c_types::c_char; 16usize],
    pub private_extensions: *mut mbedtls_asn1_named_data,
}
#[doc = " Item in a verification chain: cert and flags for it"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_crt_verify_chain_item {
    pub private_crt: *mut mbedtls_x509_crt,
    pub private_flags: u32,
}
#[doc = " Verification chain as built by \\c mbedtls_crt_verify_chain()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_x509_crt_verify_chain {
    pub private_items: [mbedtls_x509_crt_verify_chain_item; 10usize],
    pub private_len: crate::c_types::c_uint,
}
pub type mbedtls_x509_crt_restart_ctx = crate::c_types::c_void;
extern "C" {
    #[doc = " Default security profile. Should provide a good balance between security\n and compatibility with current deployments.\n\n This profile permits:\n - SHA2 hashes with at least 256 bits: SHA-256, SHA-384, SHA-512.\n - Elliptic curves with 255 bits and above except secp256k1.\n - RSA with 2048 bits and above.\n\n New minor versions of Mbed TLS may extend this profile, for example if\n new algorithms are added to the library. New minor versions of Mbed TLS will\n not reduce this profile unless serious security concerns require it."]
    pub static mbedtls_x509_crt_profile_default: mbedtls_x509_crt_profile;
}
extern "C" {
    #[doc = " Expected next default profile. Recommended for new deployments.\n Currently targets a 128-bit security level, except for allowing RSA-2048.\n This profile may change at any time."]
    pub static mbedtls_x509_crt_profile_next: mbedtls_x509_crt_profile;
}
extern "C" {
    #[doc = " NSA Suite B profile."]
    pub static mbedtls_x509_crt_profile_suiteb: mbedtls_x509_crt_profile;
}
extern "C" {
    #[doc = " Empty profile that allows nothing. Useful as a basis for constructing\n custom profiles."]
    pub static mbedtls_x509_crt_profile_none: mbedtls_x509_crt_profile;
}
extern "C" {
    #[doc = " \\brief          Parse a single DER formatted certificate and add it\n                 to the end of the provided chained list.\n\n \\note           If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto\n                 subsystem must have been initialized by calling\n                 psa_crypto_init() before calling this function.\n\n \\param chain    The pointer to the start of the CRT chain to attach to.\n                 When parsing the first CRT in a chain, this should point\n                 to an instance of ::mbedtls_x509_crt initialized through\n                 mbedtls_x509_crt_init().\n \\param buf      The buffer holding the DER encoded certificate.\n \\param buflen   The size in Bytes of \\p buf.\n\n \\note           This function makes an internal copy of the CRT buffer\n                 \\p buf. In particular, \\p buf may be destroyed or reused\n                 after this call returns. To avoid duplicating the CRT\n                 buffer (at the cost of stricter lifetime constraints),\n                 use mbedtls_x509_crt_parse_der_nocopy() instead.\n\n \\return         \\c 0 if successful.\n \\return         A negative error code on failure."]
    pub fn mbedtls_x509_crt_parse_der(
        chain: *mut mbedtls_x509_crt,
        buf: *const crate::c_types::c_uchar,
        buflen: usize,
    ) -> crate::c_types::c_int;
}
#[doc = " \\brief          The type of certificate extension callbacks.\n\n                 Callbacks of this type are passed to and used by the\n                 mbedtls_x509_crt_parse_der_with_ext_cb() routine when\n                 it encounters either an unsupported extension or a\n                 \"certificate policies\" extension containing any\n                 unsupported certificate policies.\n                 Future versions of the library may invoke the callback\n                 in other cases, if and when the need arises.\n\n \\param p_ctx    An opaque context passed to the callback.\n \\param crt      The certificate being parsed.\n \\param oid      The OID of the extension.\n \\param critical Whether the extension is critical.\n \\param p        Pointer to the start of the extension value\n                 (the content of the OCTET STRING).\n \\param end      End of extension value.\n\n \\note           The callback must fail and return a negative error code\n                 if it can not parse or does not support the extension.\n                 When the callback fails to parse a critical extension\n                 mbedtls_x509_crt_parse_der_with_ext_cb() also fails.\n                 When the callback fails to parse a non critical extension\n                 mbedtls_x509_crt_parse_der_with_ext_cb() simply skips\n                 the extension and continues parsing.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
pub type mbedtls_x509_crt_ext_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_ctx: *mut crate::c_types::c_void,
        crt: *const mbedtls_x509_crt,
        oid: *const mbedtls_x509_buf,
        critical: crate::c_types::c_int,
        p: *const crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int,
>;
extern "C" {
    #[doc = " \\brief            Parse a single DER formatted certificate and add it\n                   to the end of the provided chained list.\n\n \\note             If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto\n                   subsystem must have been initialized by calling\n                   psa_crypto_init() before calling this function.\n\n \\param chain      The pointer to the start of the CRT chain to attach to.\n                   When parsing the first CRT in a chain, this should point\n                   to an instance of ::mbedtls_x509_crt initialized through\n                   mbedtls_x509_crt_init().\n \\param buf        The buffer holding the DER encoded certificate.\n \\param buflen     The size in Bytes of \\p buf.\n \\param make_copy  When not zero this function makes an internal copy of the\n                   CRT buffer \\p buf. In particular, \\p buf may be destroyed\n                   or reused after this call returns.\n                   When zero this function avoids duplicating the CRT buffer\n                   by taking temporary ownership thereof until the CRT\n                   is destroyed (like mbedtls_x509_crt_parse_der_nocopy())\n \\param cb         A callback invoked for every unsupported certificate\n                   extension.\n \\param p_ctx      An opaque context passed to the callback.\n\n \\note             This call is functionally equivalent to\n                   mbedtls_x509_crt_parse_der(), and/or\n                   mbedtls_x509_crt_parse_der_nocopy()\n                   but it calls the callback with every unsupported\n                   certificate extension and additionally the\n                   \"certificate policies\" extension if it contains any\n                   unsupported certificate policies.\n                   The callback must return a negative error code if it\n                   does not know how to handle such an extension.\n                   When the callback fails to parse a critical extension\n                   mbedtls_x509_crt_parse_der_with_ext_cb() also fails.\n                   When the callback fails to parse a non critical extension\n                   mbedtls_x509_crt_parse_der_with_ext_cb() simply skips\n                   the extension and continues parsing.\n                   Future versions of the library may invoke the callback\n                   in other cases, if and when the need arises.\n\n \\return           \\c 0 if successful.\n \\return           A negative error code on failure."]
    pub fn mbedtls_x509_crt_parse_der_with_ext_cb(
        chain: *mut mbedtls_x509_crt,
        buf: *const crate::c_types::c_uchar,
        buflen: usize,
        make_copy: crate::c_types::c_int,
        cb: mbedtls_x509_crt_ext_cb_t,
        p_ctx: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Parse a single DER formatted certificate and add it\n                 to the end of the provided chained list. This is a\n                 variant of mbedtls_x509_crt_parse_der() which takes\n                 temporary ownership of the CRT buffer until the CRT\n                 is destroyed.\n\n \\note           If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto\n                 subsystem must have been initialized by calling\n                 psa_crypto_init() before calling this function.\n\n \\param chain    The pointer to the start of the CRT chain to attach to.\n                 When parsing the first CRT in a chain, this should point\n                 to an instance of ::mbedtls_x509_crt initialized through\n                 mbedtls_x509_crt_init().\n \\param buf      The address of the readable buffer holding the DER encoded\n                 certificate to use. On success, this buffer must be\n                 retained and not be changed for the lifetime of the\n                 CRT chain \\p chain, that is, until \\p chain is destroyed\n                 through a call to mbedtls_x509_crt_free().\n \\param buflen   The size in Bytes of \\p buf.\n\n \\note           This call is functionally equivalent to\n                 mbedtls_x509_crt_parse_der(), but it avoids creating a\n                 copy of the input buffer at the cost of stronger lifetime\n                 constraints. This is useful in constrained environments\n                 where duplication of the CRT cannot be tolerated.\n\n \\return         \\c 0 if successful.\n \\return         A negative error code on failure."]
    pub fn mbedtls_x509_crt_parse_der_nocopy(
        chain: *mut mbedtls_x509_crt,
        buf: *const crate::c_types::c_uchar,
        buflen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Parse one DER-encoded or one or more concatenated PEM-encoded\n                 certificates and add them to the chained list.\n\n                 For CRTs in PEM encoding, the function parses permissively:\n                 if at least one certificate can be parsed, the function\n                 returns the number of certificates for which parsing failed\n                 (hence \\c 0 if all certificates were parsed successfully).\n                 If no certificate could be parsed, the function returns\n                 the first (negative) error encountered during parsing.\n\n                 PEM encoded certificates may be interleaved by other data\n                 such as human readable descriptions of their content, as\n                 long as the certificates are enclosed in the PEM specific\n                 '-----{BEGIN/END} CERTIFICATE-----' delimiters.\n\n \\note           If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto\n                 subsystem must have been initialized by calling\n                 psa_crypto_init() before calling this function.\n\n \\param chain    The chain to which to add the parsed certificates.\n \\param buf      The buffer holding the certificate data in PEM or DER format.\n                 For certificates in PEM encoding, this may be a concatenation\n                 of multiple certificates; for DER encoding, the buffer must\n                 comprise exactly one certificate.\n \\param buflen   The size of \\p buf, including the terminating \\c NULL byte\n                 in case of PEM encoded data.\n\n \\return         \\c 0 if all certificates were parsed successfully.\n \\return         The (positive) number of certificates that couldn't\n                 be parsed if parsing was partly successful (see above).\n \\return         A negative X509 or PEM error code otherwise.\n"]
    pub fn mbedtls_x509_crt_parse(
        chain: *mut mbedtls_x509_crt,
        buf: *const crate::c_types::c_uchar,
        buflen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Returns an informational string about the\n                 certificate.\n\n \\param buf      Buffer to write to\n \\param size     Maximum size of buffer\n \\param prefix   A line prefix\n \\param crt      The X509 certificate to represent\n\n \\return         The length of the string written (not including the\n                 terminated nul byte), or a negative error code."]
    pub fn mbedtls_x509_crt_info(
        buf: *mut crate::c_types::c_char,
        size: usize,
        prefix: *const crate::c_types::c_char,
        crt: *const mbedtls_x509_crt,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Returns an informational string about the\n                 verification status of a certificate.\n\n \\param buf      Buffer to write to\n \\param size     Maximum size of buffer\n \\param prefix   A line prefix\n \\param flags    Verification flags created by mbedtls_x509_crt_verify()\n\n \\return         The length of the string written (not including the\n                 terminated nul byte), or a negative error code."]
    pub fn mbedtls_x509_crt_verify_info(
        buf: *mut crate::c_types::c_char,
        size: usize,
        prefix: *const crate::c_types::c_char,
        flags: u32,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Verify a chain of certificates.\n\n                 The verify callback is a user-supplied callback that\n                 can clear / modify / add flags for a certificate. If set,\n                 the verification callback is called for each\n                 certificate in the chain (from the trust-ca down to the\n                 presented crt). The parameters for the callback are:\n                 (void *parameter, mbedtls_x509_crt *crt, int certificate_depth,\n                 int *flags). With the flags representing current flags for\n                 that specific certificate and the certificate depth from\n                 the bottom (Peer cert depth = 0).\n\n                 All flags left after returning from the callback\n                 are also returned to the application. The function should\n                 return 0 for anything (including invalid certificates)\n                 other than fatal error, as a non-zero return code\n                 immediately aborts the verification process. For fatal\n                 errors, a specific error code should be used (different\n                 from MBEDTLS_ERR_X509_CERT_VERIFY_FAILED which should not\n                 be returned at this point), or MBEDTLS_ERR_X509_FATAL_ERROR\n                 can be used if no better code is available.\n\n \\note           In case verification failed, the results can be displayed\n                 using \\c mbedtls_x509_crt_verify_info()\n\n \\note           Same as \\c mbedtls_x509_crt_verify_with_profile() with the\n                 default security profile.\n\n \\note           It is your responsibility to provide up-to-date CRLs for\n                 all trusted CAs. If no CRL is provided for the CA that was\n                 used to sign the certificate, CRL verification is skipped\n                 silently, that is *without* setting any flag.\n\n \\note           The \\c trust_ca list can contain two types of certificates:\n                 (1) those of trusted root CAs, so that certificates\n                 chaining up to those CAs will be trusted, and (2)\n                 self-signed end-entity certificates to be trusted (for\n                 specific peers you know) - in that case, the self-signed\n                 certificate doesn't need to have the CA bit set.\n\n \\param crt      The certificate chain to be verified.\n \\param trust_ca The list of trusted CAs.\n \\param ca_crl   The list of CRLs for trusted CAs.\n \\param cn       The expected Common Name. This will be checked to be\n                 present in the certificate's subjectAltNames extension or,\n                 if this extension is absent, as a CN component in its\n                 Subject name. Currently only DNS names are supported. This\n                 may be \\c NULL if the CN need not be verified.\n \\param flags    The address at which to store the result of the verification.\n                 If the verification couldn't be completed, the flag value is\n                 set to (uint32_t) -1.\n \\param f_vrfy   The verification callback to use. See the documentation\n                 of mbedtls_x509_crt_verify() for more information.\n \\param p_vrfy   The context to be passed to \\p f_vrfy.\n\n \\return         \\c 0 if the chain is valid with respect to the\n                 passed CN, CAs, CRLs and security profile.\n \\return         #MBEDTLS_ERR_X509_CERT_VERIFY_FAILED in case the\n                 certificate chain verification failed. In this case,\n                 \\c *flags will have one or more\n                 \\c MBEDTLS_X509_BADCERT_XXX or \\c MBEDTLS_X509_BADCRL_XXX\n                 flags set.\n \\return         Another negative error code in case of a fatal error\n                 encountered during the verification process."]
    pub fn mbedtls_x509_crt_verify(
        crt: *mut mbedtls_x509_crt,
        trust_ca: *mut mbedtls_x509_crt,
        ca_crl: *mut mbedtls_x509_crl,
        cn: *const crate::c_types::c_char,
        flags: *mut u32,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut mbedtls_x509_crt,
                arg3: crate::c_types::c_int,
                arg4: *mut u32,
            ) -> crate::c_types::c_int,
        >,
        p_vrfy: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Verify a chain of certificates with respect to\n                 a configurable security profile.\n\n \\note           Same as \\c mbedtls_x509_crt_verify(), but with explicit\n                 security profile.\n\n \\note           The restrictions on keys (RSA minimum size, allowed curves\n                 for ECDSA) apply to all certificates: trusted root,\n                 intermediate CAs if any, and end entity certificate.\n\n \\param crt      The certificate chain to be verified.\n \\param trust_ca The list of trusted CAs.\n \\param ca_crl   The list of CRLs for trusted CAs.\n \\param profile  The security profile to use for the verification.\n \\param cn       The expected Common Name. This may be \\c NULL if the\n                 CN need not be verified.\n \\param flags    The address at which to store the result of the verification.\n                 If the verification couldn't be completed, the flag value is\n                 set to (uint32_t) -1.\n \\param f_vrfy   The verification callback to use. See the documentation\n                 of mbedtls_x509_crt_verify() for more information.\n \\param p_vrfy   The context to be passed to \\p f_vrfy.\n\n \\return         \\c 0 if the chain is valid with respect to the\n                 passed CN, CAs, CRLs and security profile.\n \\return         #MBEDTLS_ERR_X509_CERT_VERIFY_FAILED in case the\n                 certificate chain verification failed. In this case,\n                 \\c *flags will have one or more\n                 \\c MBEDTLS_X509_BADCERT_XXX or \\c MBEDTLS_X509_BADCRL_XXX\n                 flags set.\n \\return         Another negative error code in case of a fatal error\n                 encountered during the verification process."]
    pub fn mbedtls_x509_crt_verify_with_profile(
        crt: *mut mbedtls_x509_crt,
        trust_ca: *mut mbedtls_x509_crt,
        ca_crl: *mut mbedtls_x509_crl,
        profile: *const mbedtls_x509_crt_profile,
        cn: *const crate::c_types::c_char,
        flags: *mut u32,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut mbedtls_x509_crt,
                arg3: crate::c_types::c_int,
                arg4: *mut u32,
            ) -> crate::c_types::c_int,
        >,
        p_vrfy: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Restartable version of \\c mbedtls_crt_verify_with_profile()\n\n \\note           Performs the same job as \\c mbedtls_crt_verify_with_profile()\n                 but can return early and restart according to the limit\n                 set with \\c mbedtls_ecp_set_max_ops() to reduce blocking.\n\n \\param crt      The certificate chain to be verified.\n \\param trust_ca The list of trusted CAs.\n \\param ca_crl   The list of CRLs for trusted CAs.\n \\param profile  The security profile to use for the verification.\n \\param cn       The expected Common Name. This may be \\c NULL if the\n                 CN need not be verified.\n \\param flags    The address at which to store the result of the verification.\n                 If the verification couldn't be completed, the flag value is\n                 set to (uint32_t) -1.\n \\param f_vrfy   The verification callback to use. See the documentation\n                 of mbedtls_x509_crt_verify() for more information.\n \\param p_vrfy   The context to be passed to \\p f_vrfy.\n \\param rs_ctx   The restart context to use. This may be set to \\c NULL\n                 to disable restartable ECC.\n\n \\return         See \\c mbedtls_crt_verify_with_profile(), or\n \\return         #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of\n                 operations was reached: see \\c mbedtls_ecp_set_max_ops()."]
    pub fn mbedtls_x509_crt_verify_restartable(
        crt: *mut mbedtls_x509_crt,
        trust_ca: *mut mbedtls_x509_crt,
        ca_crl: *mut mbedtls_x509_crl,
        profile: *const mbedtls_x509_crt_profile,
        cn: *const crate::c_types::c_char,
        flags: *mut u32,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut mbedtls_x509_crt,
                arg3: crate::c_types::c_int,
                arg4: *mut u32,
            ) -> crate::c_types::c_int,
        >,
        p_vrfy: *mut crate::c_types::c_void,
        rs_ctx: *mut mbedtls_x509_crt_restart_ctx,
    ) -> crate::c_types::c_int;
}
#[doc = " \\brief               The type of trusted certificate callbacks.\n\n                      Callbacks of this type are passed to and used by the CRT\n                      verification routine mbedtls_x509_crt_verify_with_ca_cb()\n                      when looking for trusted signers of a given certificate.\n\n                      On success, the callback returns a list of trusted\n                      certificates to be considered as potential signers\n                      for the input certificate.\n\n \\param p_ctx         An opaque context passed to the callback.\n \\param child         The certificate for which to search a potential signer.\n                      This will point to a readable certificate.\n \\param candidate_cas The address at which to store the address of the first\n                      entry in the generated linked list of candidate signers.\n                      This will not be \\c NULL.\n\n \\note                The callback must only return a non-zero value on a\n                      fatal error. If, in contrast, the search for a potential\n                      signer completes without a single candidate, the\n                      callback must return \\c 0 and set \\c *candidate_cas\n                      to \\c NULL.\n\n \\return              \\c 0 on success. In this case, \\c *candidate_cas points\n                      to a heap-allocated linked list of instances of\n                      ::mbedtls_x509_crt, and ownership of this list is passed\n                      to the caller.\n \\return              A negative error code on failure."]
pub type mbedtls_x509_crt_ca_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_ctx: *mut crate::c_types::c_void,
        child: *const mbedtls_x509_crt,
        candidate_cas: *mut *mut mbedtls_x509_crt,
    ) -> crate::c_types::c_int,
>;
extern "C" {
    #[doc = " \\brief          Check usage of certificate against keyUsage extension.\n\n \\param crt      Leaf certificate used.\n \\param usage    Intended usage(s) (eg MBEDTLS_X509_KU_KEY_ENCIPHERMENT\n                 before using the certificate to perform an RSA key\n                 exchange).\n\n \\note           Except for decipherOnly and encipherOnly, a bit set in the\n                 usage argument means this bit MUST be set in the\n                 certificate. For decipherOnly and encipherOnly, it means\n                 that bit MAY be set.\n\n \\return         0 is these uses of the certificate are allowed,\n                 MBEDTLS_ERR_X509_BAD_INPUT_DATA if the keyUsage extension\n                 is present but does not match the usage argument.\n\n \\note           You should only call this function on leaf certificates, on\n                 (intermediate) CAs the keyUsage extension is automatically\n                 checked by \\c mbedtls_x509_crt_verify()."]
    pub fn mbedtls_x509_crt_check_key_usage(
        crt: *const mbedtls_x509_crt,
        usage: crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Check usage of certificate against extendedKeyUsage.\n\n \\param crt       Leaf certificate used.\n \\param usage_oid Intended usage (eg MBEDTLS_OID_SERVER_AUTH or\n                  MBEDTLS_OID_CLIENT_AUTH).\n \\param usage_len Length of usage_oid (eg given by MBEDTLS_OID_SIZE()).\n\n \\return          0 if this use of the certificate is allowed,\n                  MBEDTLS_ERR_X509_BAD_INPUT_DATA if not.\n\n \\note            Usually only makes sense on leaf certificates."]
    pub fn mbedtls_x509_crt_check_extended_key_usage(
        crt: *const mbedtls_x509_crt,
        usage_oid: *const crate::c_types::c_char,
        usage_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Verify the certificate revocation status\n\n \\param crt      a certificate to be verified\n \\param crl      the CRL to verify against\n\n \\return         1 if the certificate is revoked, 0 otherwise\n"]
    pub fn mbedtls_x509_crt_is_revoked(
        crt: *const mbedtls_x509_crt,
        crl: *const mbedtls_x509_crl,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Initialize a certificate (chain)\n\n \\param crt      Certificate chain to initialize"]
    pub fn mbedtls_x509_crt_init(crt: *mut mbedtls_x509_crt);
}
extern "C" {
    #[doc = " \\brief          Unallocate all certificate data\n\n \\param crt      Certificate chain to free"]
    pub fn mbedtls_x509_crt_free(crt: *mut mbedtls_x509_crt);
}
extern "C" {
    #[doc = " \\brief           Initialize a CRT writing context\n\n \\param ctx       CRT context to initialize"]
    pub fn mbedtls_x509write_crt_init(ctx: *mut mbedtls_x509write_cert);
}
extern "C" {
    #[doc = " \\brief           Set the version for a Certificate\n                  Default: MBEDTLS_X509_CRT_VERSION_3\n\n \\param ctx       CRT context to use\n \\param version   version to set (MBEDTLS_X509_CRT_VERSION_1, MBEDTLS_X509_CRT_VERSION_2 or\n                                  MBEDTLS_X509_CRT_VERSION_3)"]
    pub fn mbedtls_x509write_crt_set_version(
        ctx: *mut mbedtls_x509write_cert,
        version: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief           Set the serial number for a Certificate.\n\n \\deprecated      This function is deprecated and will be removed in a\n                  future version of the library. Please use\n                  mbedtls_x509write_crt_set_serial_raw() instead.\n\n \\note            Even though the MBEDTLS_BIGNUM_C guard looks redundant since\n                  X509 depends on PK and PK depends on BIGNUM, this emphasizes\n                  a direct dependency between X509 and BIGNUM which is going\n                  to be deprecated in the future.\n\n \\param ctx       CRT context to use\n \\param serial    serial number to set\n\n \\return          0 if successful"]
    pub fn mbedtls_x509write_crt_set_serial(
        ctx: *mut mbedtls_x509write_cert,
        serial: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the serial number for a Certificate.\n\n \\param ctx          CRT context to use\n \\param serial       A raw array of bytes containing the serial number in big\n                     endian format\n \\param serial_len   Length of valid bytes (expressed in bytes) in \\p serial\n                     input buffer\n\n \\return          0 if successful, or\n                  MBEDTLS_ERR_X509_BAD_INPUT_DATA if the provided input buffer\n                  is too big (longer than MBEDTLS_X509_RFC5280_MAX_SERIAL_LEN)"]
    pub fn mbedtls_x509write_crt_set_serial_raw(
        ctx: *mut mbedtls_x509write_cert,
        serial: *mut crate::c_types::c_uchar,
        serial_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the validity period for a Certificate\n                  Timestamps should be in string format for UTC timezone\n                  i.e. \"YYYYMMDDhhmmss\"\n                  e.g. \"20131231235959\" for December 31st 2013\n                       at 23:59:59\n\n \\param ctx       CRT context to use\n \\param not_before    not_before timestamp\n \\param not_after     not_after timestamp\n\n \\return          0 if timestamp was parsed successfully, or\n                  a specific error code"]
    pub fn mbedtls_x509write_crt_set_validity(
        ctx: *mut mbedtls_x509write_cert,
        not_before: *const crate::c_types::c_char,
        not_after: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the issuer name for a Certificate\n                  Issuer names should contain a comma-separated list\n                  of OID types and values:\n                  e.g. \"C=UK,O=ARM,CN=mbed TLS CA\"\n\n \\param ctx           CRT context to use\n \\param issuer_name   issuer name to set\n\n \\return          0 if issuer name was parsed successfully, or\n                  a specific error code"]
    pub fn mbedtls_x509write_crt_set_issuer_name(
        ctx: *mut mbedtls_x509write_cert,
        issuer_name: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the subject name for a Certificate\n                  Subject names should contain a comma-separated list\n                  of OID types and values:\n                  e.g. \"C=UK,O=ARM,CN=mbed TLS Server 1\"\n\n \\param ctx           CRT context to use\n \\param subject_name  subject name to set\n\n \\return          0 if subject name was parsed successfully, or\n                  a specific error code"]
    pub fn mbedtls_x509write_crt_set_subject_name(
        ctx: *mut mbedtls_x509write_cert,
        subject_name: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the subject public key for the certificate\n\n \\param ctx       CRT context to use\n \\param key       public key to include"]
    pub fn mbedtls_x509write_crt_set_subject_key(
        ctx: *mut mbedtls_x509write_cert,
        key: *mut mbedtls_pk_context,
    );
}
extern "C" {
    #[doc = " \\brief           Set the issuer key used for signing the certificate\n\n \\param ctx       CRT context to use\n \\param key       private key to sign with"]
    pub fn mbedtls_x509write_crt_set_issuer_key(
        ctx: *mut mbedtls_x509write_cert,
        key: *mut mbedtls_pk_context,
    );
}
extern "C" {
    #[doc = " \\brief           Set the MD algorithm to use for the signature\n                  (e.g. MBEDTLS_MD_SHA1)\n\n \\param ctx       CRT context to use\n \\param md_alg    MD algorithm to use"]
    pub fn mbedtls_x509write_crt_set_md_alg(
        ctx: *mut mbedtls_x509write_cert,
        md_alg: mbedtls_md_type_t,
    );
}
extern "C" {
    #[doc = " \\brief           Generic function to add to or replace an extension in the\n                  CRT\n\n \\param ctx       CRT context to use\n \\param oid       OID of the extension\n \\param oid_len   length of the OID\n \\param critical  if the extension is critical (per the RFC's definition)\n \\param val       value of the extension OCTET STRING\n \\param val_len   length of the value data\n\n \\return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED"]
    pub fn mbedtls_x509write_crt_set_extension(
        ctx: *mut mbedtls_x509write_cert,
        oid: *const crate::c_types::c_char,
        oid_len: usize,
        critical: crate::c_types::c_int,
        val: *const crate::c_types::c_uchar,
        val_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the basicConstraints extension for a CRT\n\n \\param ctx       CRT context to use\n \\param is_ca     is this a CA certificate\n \\param max_pathlen   maximum length of certificate chains below this\n                      certificate (only for CA certificates, -1 is\n                      unlimited)\n\n \\return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED"]
    pub fn mbedtls_x509write_crt_set_basic_constraints(
        ctx: *mut mbedtls_x509write_cert,
        is_ca: crate::c_types::c_int,
        max_pathlen: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the subjectKeyIdentifier extension for a CRT\n                  Requires that mbedtls_x509write_crt_set_subject_key() has been\n                  called before\n\n \\param ctx       CRT context to use\n\n \\return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED"]
    pub fn mbedtls_x509write_crt_set_subject_key_identifier(
        ctx: *mut mbedtls_x509write_cert,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the authorityKeyIdentifier extension for a CRT\n                  Requires that mbedtls_x509write_crt_set_issuer_key() has been\n                  called before\n\n \\param ctx       CRT context to use\n\n \\return          0 if successful, or a MBEDTLS_ERR_X509_ALLOC_FAILED"]
    pub fn mbedtls_x509write_crt_set_authority_key_identifier(
        ctx: *mut mbedtls_x509write_cert,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the Key Usage Extension flags\n                  (e.g. MBEDTLS_X509_KU_DIGITAL_SIGNATURE | MBEDTLS_X509_KU_KEY_CERT_SIGN)\n\n \\param ctx       CRT context to use\n \\param key_usage key usage flags to set\n\n \\return          0 if successful, or MBEDTLS_ERR_X509_ALLOC_FAILED"]
    pub fn mbedtls_x509write_crt_set_key_usage(
        ctx: *mut mbedtls_x509write_cert,
        key_usage: crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the Extended Key Usage Extension\n                  (e.g. MBEDTLS_OID_SERVER_AUTH)\n\n \\param ctx       CRT context to use\n \\param exts      extended key usage extensions to set, a sequence of\n                  MBEDTLS_ASN1_OID objects\n\n \\return          0 if successful, or MBEDTLS_ERR_X509_ALLOC_FAILED"]
    pub fn mbedtls_x509write_crt_set_ext_key_usage(
        ctx: *mut mbedtls_x509write_cert,
        exts: *const mbedtls_asn1_sequence,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Set the Netscape Cert Type flags\n                  (e.g. MBEDTLS_X509_NS_CERT_TYPE_SSL_CLIENT | MBEDTLS_X509_NS_CERT_TYPE_EMAIL)\n\n \\param ctx           CRT context to use\n \\param ns_cert_type  Netscape Cert Type flags to set\n\n \\return          0 if successful, or MBEDTLS_ERR_X509_ALLOC_FAILED"]
    pub fn mbedtls_x509write_crt_set_ns_cert_type(
        ctx: *mut mbedtls_x509write_cert,
        ns_cert_type: crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Free the contents of a CRT write context\n\n \\param ctx       CRT context to free"]
    pub fn mbedtls_x509write_crt_free(ctx: *mut mbedtls_x509write_cert);
}
extern "C" {
    #[doc = " \\brief           Write a built up certificate to a X509 DER structure\n                  Note: data is written at the end of the buffer! Use the\n                        return value to determine where you should start\n                        using the buffer\n\n \\param ctx       certificate to write away\n \\param buf       buffer to write to\n \\param size      size of the buffer\n \\param f_rng     RNG function. This must not be \\c NULL.\n \\param p_rng     RNG parameter\n\n \\return          length of data written if successful, or a specific\n                  error code\n\n \\note            \\p f_rng is used for the signature operation."]
    pub fn mbedtls_x509write_crt_der(
        ctx: *mut mbedtls_x509write_cert,
        buf: *mut crate::c_types::c_uchar,
        size: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Write a built up certificate to a X509 PEM string\n\n \\param ctx       certificate to write away\n \\param buf       buffer to write to\n \\param size      size of the buffer\n \\param f_rng     RNG function. This must not be \\c NULL.\n \\param p_rng     RNG parameter\n\n \\return          0 if successful, or a specific error code\n\n \\note            \\p f_rng is used for the signature operation."]
    pub fn mbedtls_x509write_crt_pem(
        ctx: *mut mbedtls_x509write_cert,
        buf: *mut crate::c_types::c_uchar,
        size: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
#[doc = "<  The prime modulus."]
pub const mbedtls_dhm_parameter_MBEDTLS_DHM_PARAM_P: mbedtls_dhm_parameter = 0;
#[doc = "<  The generator."]
pub const mbedtls_dhm_parameter_MBEDTLS_DHM_PARAM_G: mbedtls_dhm_parameter = 1;
#[doc = "<  Our secret value."]
pub const mbedtls_dhm_parameter_MBEDTLS_DHM_PARAM_X: mbedtls_dhm_parameter = 2;
#[doc = "<  Our public key = \\c G^X mod \\c P."]
pub const mbedtls_dhm_parameter_MBEDTLS_DHM_PARAM_GX: mbedtls_dhm_parameter = 3;
#[doc = "<  The public key of the peer = \\c G^Y mod \\c P."]
pub const mbedtls_dhm_parameter_MBEDTLS_DHM_PARAM_GY: mbedtls_dhm_parameter = 4;
#[doc = "<  The shared secret = \\c G^(XY) mod \\c P."]
pub const mbedtls_dhm_parameter_MBEDTLS_DHM_PARAM_K: mbedtls_dhm_parameter = 5;
#[doc = " Which parameter to access in mbedtls_dhm_get_value()."]
pub type mbedtls_dhm_parameter = crate::c_types::c_uint;
#[doc = " \\brief          The DHM context structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_dhm_context {
    pub private_P: mbedtls_mpi,
    pub private_G: mbedtls_mpi,
    pub private_X: mbedtls_mpi,
    pub private_GX: mbedtls_mpi,
    pub private_GY: mbedtls_mpi,
    pub private_K: mbedtls_mpi,
    pub private_RP: mbedtls_mpi,
    pub private_Vi: mbedtls_mpi,
    pub private_Vf: mbedtls_mpi,
    pub private_pX: mbedtls_mpi,
}
extern "C" {
    #[doc = " \\brief          This function initializes the DHM context.\n\n \\param ctx      The DHM context to initialize."]
    pub fn mbedtls_dhm_init(ctx: *mut mbedtls_dhm_context);
}
extern "C" {
    #[doc = " \\brief          This function parses the DHM parameters in a\n                 TLS ServerKeyExchange handshake message\n                 (DHM modulus, generator, and public key).\n\n \\note           In a TLS handshake, this is the how the client\n                 sets up its DHM context from the server's public\n                 DHM key material.\n\n \\param ctx      The DHM context to use. This must be initialized.\n \\param p        On input, *p must be the start of the input buffer.\n                 On output, *p is updated to point to the end of the data\n                 that has been read. On success, this is the first byte\n                 past the end of the ServerKeyExchange parameters.\n                 On error, this is the point at which an error has been\n                 detected, which is usually not useful except to debug\n                 failures.\n \\param end      The end of the input buffer.\n\n \\return         \\c 0 on success.\n \\return         An \\c MBEDTLS_ERR_DHM_XXX error code on failure."]
    pub fn mbedtls_dhm_read_params(
        ctx: *mut mbedtls_dhm_context,
        p: *mut *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function generates a DHM key pair and exports its\n                 public part together with the DHM parameters in the format\n                 used in a TLS ServerKeyExchange handshake message.\n\n \\note           This function assumes that the DHM parameters \\c ctx->P\n                 and \\c ctx->G have already been properly set. For that, use\n                 mbedtls_dhm_set_group() below in conjunction with\n                 mbedtls_mpi_read_binary() and mbedtls_mpi_read_string().\n\n \\note           In a TLS handshake, this is the how the server generates\n                 and exports its DHM key material.\n\n \\param ctx      The DHM context to use. This must be initialized\n                 and have the DHM parameters set. It may or may not\n                 already have imported the peer's public key.\n \\param x_size   The private key size in Bytes.\n \\param olen     The address at which to store the number of Bytes\n                 written on success. This must not be \\c NULL.\n \\param output   The destination buffer. This must be a writable buffer of\n                 sufficient size to hold the reduced binary presentation of\n                 the modulus, the generator and the public key, each wrapped\n                 with a 2-byte length field. It is the responsibility of the\n                 caller to ensure that enough space is available. Refer to\n                 mbedtls_mpi_size() to computing the byte-size of an MPI.\n \\param f_rng    The RNG function. Must not be \\c NULL.\n \\param p_rng    The RNG context to be passed to \\p f_rng. This may be\n                 \\c NULL if \\p f_rng doesn't need a context parameter.\n\n \\return         \\c 0 on success.\n \\return         An \\c MBEDTLS_ERR_DHM_XXX error code on failure."]
    pub fn mbedtls_dhm_make_params(
        ctx: *mut mbedtls_dhm_context,
        x_size: crate::c_types::c_int,
        output: *mut crate::c_types::c_uchar,
        olen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function sets the prime modulus and generator.\n\n \\note           This function can be used to set \\c ctx->P, \\c ctx->G\n                 in preparation for mbedtls_dhm_make_params().\n\n \\param ctx      The DHM context to configure. This must be initialized.\n \\param P        The MPI holding the DHM prime modulus. This must be\n                 an initialized MPI.\n \\param G        The MPI holding the DHM generator. This must be an\n                 initialized MPI.\n\n \\return         \\c 0 if successful.\n \\return         An \\c MBEDTLS_ERR_DHM_XXX error code on failure."]
    pub fn mbedtls_dhm_set_group(
        ctx: *mut mbedtls_dhm_context,
        P: *const mbedtls_mpi,
        G: *const mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function imports the raw public value of the peer.\n\n \\note           In a TLS handshake, this is the how the server imports\n                 the Client's public DHM key.\n\n \\param ctx      The DHM context to use. This must be initialized and have\n                 its DHM parameters set, e.g. via mbedtls_dhm_set_group().\n                 It may or may not already have generated its own private key.\n \\param input    The input buffer containing the \\c G^Y value of the peer.\n                 This must be a readable buffer of size \\p ilen Bytes.\n \\param ilen     The size of the input buffer \\p input in Bytes.\n\n \\return         \\c 0 on success.\n \\return         An \\c MBEDTLS_ERR_DHM_XXX error code on failure."]
    pub fn mbedtls_dhm_read_public(
        ctx: *mut mbedtls_dhm_context,
        input: *const crate::c_types::c_uchar,
        ilen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function creates a DHM key pair and exports\n                 the raw public key in big-endian format.\n\n \\note           The destination buffer is always fully written\n                 so as to contain a big-endian representation of G^X mod P.\n                 If it is larger than \\c ctx->len, it is padded accordingly\n                 with zero-bytes at the beginning.\n\n \\param ctx      The DHM context to use. This must be initialized and\n                 have the DHM parameters set. It may or may not already\n                 have imported the peer's public key.\n \\param x_size   The private key size in Bytes.\n \\param output   The destination buffer. This must be a writable buffer of\n                 size \\p olen Bytes.\n \\param olen     The length of the destination buffer. This must be at least\n                 equal to `ctx->len` (the size of \\c P).\n \\param f_rng    The RNG function. This must not be \\c NULL.\n \\param p_rng    The RNG context to be passed to \\p f_rng. This may be \\c NULL\n                 if \\p f_rng doesn't need a context argument.\n\n \\return         \\c 0 on success.\n \\return         An \\c MBEDTLS_ERR_DHM_XXX error code on failure."]
    pub fn mbedtls_dhm_make_public(
        ctx: *mut mbedtls_dhm_context,
        x_size: crate::c_types::c_int,
        output: *mut crate::c_types::c_uchar,
        olen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function derives and exports the shared secret\n                 \\c (G^Y)^X mod \\c P.\n\n \\note           If \\p f_rng is not \\c NULL, it is used to blind the input as\n                 a countermeasure against timing attacks. Blinding is used\n                 only if our private key \\c X is re-used, and not used\n                 otherwise. We recommend always passing a non-NULL\n                 \\p f_rng argument.\n\n \\param ctx           The DHM context to use. This must be initialized\n                      and have its own private key generated and the peer's\n                      public key imported.\n \\param output        The buffer to write the generated shared key to. This\n                      must be a writable buffer of size \\p output_size Bytes.\n \\param output_size   The size of the destination buffer. This must be at\n                      least the size of \\c ctx->len (the size of \\c P).\n \\param olen          On exit, holds the actual number of Bytes written.\n \\param f_rng         The RNG function. Must not be \\c NULL. Used for\n                      blinding.\n \\param p_rng         The RNG context to be passed to \\p f_rng. This may be\n                      \\c NULL if \\p f_rng doesn't need a context parameter.\n\n \\return              \\c 0 on success.\n \\return              An \\c MBEDTLS_ERR_DHM_XXX error code on failure."]
    pub fn mbedtls_dhm_calc_secret(
        ctx: *mut mbedtls_dhm_context,
        output: *mut crate::c_types::c_uchar,
        output_size: usize,
        olen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function returns the size of the prime modulus in bits.\n\n \\param ctx      The DHM context to query.\n\n \\return         The size of the prime modulus in bits,\n                 i.e. the number n such that 2^(n-1) <= P < 2^n."]
    pub fn mbedtls_dhm_get_bitlen(ctx: *const mbedtls_dhm_context) -> usize;
}
extern "C" {
    #[doc = " \\brief          This function returns the size of the prime modulus in bytes.\n\n \\param ctx      The DHM context to query.\n\n \\return         The size of the prime modulus in bytes,\n                 i.e. the number n such that 2^(8*(n-1)) <= P < 2^(8*n)."]
    pub fn mbedtls_dhm_get_len(ctx: *const mbedtls_dhm_context) -> usize;
}
extern "C" {
    #[doc = " \\brief          This function copies a parameter of a DHM key.\n\n \\param ctx      The DHM context to query.\n \\param param    The parameter to copy.\n \\param dest     The MPI object to copy the value into. It must be\n                 initialized.\n\n \\return         \\c 0 on success.\n \\return         #MBEDTLS_ERR_DHM_BAD_INPUT_DATA if \\p field is invalid.\n \\return         An \\c MBEDTLS_ERR_MPI_XXX error code if the copy fails."]
    pub fn mbedtls_dhm_get_value(
        ctx: *const mbedtls_dhm_context,
        param: mbedtls_dhm_parameter,
        dest: *mut mbedtls_mpi,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function frees and clears the components\n                 of a DHM context.\n\n \\param ctx      The DHM context to free and clear. This may be \\c NULL,\n                 in which case this function is a no-op. If it is not \\c NULL,\n                 it must point to an initialized DHM context."]
    pub fn mbedtls_dhm_free(ctx: *mut mbedtls_dhm_context);
}
extern "C" {
    #[doc = " \\brief             This function parses DHM parameters in PEM or DER format.\n\n \\param dhm         The DHM context to import the DHM parameters into.\n                    This must be initialized.\n \\param dhmin       The input buffer. This must be a readable buffer of\n                    length \\p dhminlen Bytes.\n \\param dhminlen    The size of the input buffer \\p dhmin, including the\n                    terminating \\c NULL Byte for PEM data.\n\n \\return            \\c 0 on success.\n \\return            An \\c MBEDTLS_ERR_DHM_XXX or \\c MBEDTLS_ERR_PEM_XXX error\n                    code on failure."]
    pub fn mbedtls_dhm_parse_dhm(
        dhm: *mut mbedtls_dhm_context,
        dhmin: *const crate::c_types::c_uchar,
        dhminlen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          The DMH checkup routine.\n\n \\return         \\c 0 on success.\n \\return         \\c 1 on failure."]
    pub fn mbedtls_dhm_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[doc = "< Our key."]
pub const mbedtls_ecdh_side_MBEDTLS_ECDH_OURS: mbedtls_ecdh_side = 0;
#[doc = "< The key of the peer."]
pub const mbedtls_ecdh_side_MBEDTLS_ECDH_THEIRS: mbedtls_ecdh_side = 1;
#[doc = " Defines the source of the imported EC key."]
pub type mbedtls_ecdh_side = crate::c_types::c_uint;
#[doc = "< Implementation not defined."]
pub const mbedtls_ecdh_variant_MBEDTLS_ECDH_VARIANT_NONE: mbedtls_ecdh_variant = 0;
#[doc = "< The default Mbed TLS implementation"]
pub const mbedtls_ecdh_variant_MBEDTLS_ECDH_VARIANT_MBEDTLS_2_0: mbedtls_ecdh_variant = 1;
#[doc = " Defines the ECDH implementation used.\n\n Later versions of the library may add new variants, therefore users should\n not make any assumptions about them."]
pub type mbedtls_ecdh_variant = crate::c_types::c_uint;
#[doc = " The context used by the default ECDH implementation.\n\n Later versions might change the structure of this context, therefore users\n should not make any assumptions about the structure of\n mbedtls_ecdh_context_mbed."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ecdh_context_mbed {
    pub private_grp: mbedtls_ecp_group,
    pub private_d: mbedtls_mpi,
    pub private_Q: mbedtls_ecp_point,
    pub private_Qp: mbedtls_ecp_point,
    pub private_z: mbedtls_mpi,
}
#[doc = " \\warning         Performing multiple operations concurrently on the same\n                  ECDSA context is not supported; objects of this type\n                  should not be shared between multiple threads.\n \\brief           The ECDH context structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ecdh_context {
    pub private_point_format: u8,
    pub private_grp_id: mbedtls_ecp_group_id,
    pub private_var: mbedtls_ecdh_variant,
    pub private_ctx: mbedtls_ecdh_context__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_ecdh_context__bindgen_ty_1 {
    pub private_mbed_ecdh: mbedtls_ecdh_context_mbed,
}
extern "C" {
    #[doc = " \\brief          Check whether a given group can be used for ECDH.\n\n \\param gid      The ECP group ID to check.\n\n \\return         \\c 1 if the group can be used, \\c 0 otherwise"]
    pub fn mbedtls_ecdh_can_do(gid: mbedtls_ecp_group_id) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function generates an ECDH keypair on an elliptic\n                  curve.\n\n                  This function performs the first of two core computations\n                  implemented during the ECDH key exchange. The second core\n                  computation is performed by mbedtls_ecdh_compute_shared().\n\n \\see             ecp.h\n\n \\param grp       The ECP group to use. This must be initialized and have\n                  domain parameters loaded, for example through\n                  mbedtls_ecp_load() or mbedtls_ecp_tls_read_group().\n \\param d         The destination MPI (private key).\n                  This must be initialized.\n \\param Q         The destination point (public key).\n                  This must be initialized.\n \\param f_rng     The RNG function to use. This must not be \\c NULL.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may be\n                  \\c NULL in case \\p f_rng doesn't need a context argument.\n\n \\return          \\c 0 on success.\n \\return          Another \\c MBEDTLS_ERR_ECP_XXX or\n                  \\c MBEDTLS_MPI_XXX error code on failure."]
    pub fn mbedtls_ecdh_gen_public(
        grp: *mut mbedtls_ecp_group,
        d: *mut mbedtls_mpi,
        Q: *mut mbedtls_ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function computes the shared secret.\n\n                  This function performs the second of two core computations\n                  implemented during the ECDH key exchange. The first core\n                  computation is performed by mbedtls_ecdh_gen_public().\n\n \\see             ecp.h\n\n \\note            If \\p f_rng is not NULL, it is used to implement\n                  countermeasures against side-channel attacks.\n                  For more information, see mbedtls_ecp_mul().\n\n \\param grp       The ECP group to use. This must be initialized and have\n                  domain parameters loaded, for example through\n                  mbedtls_ecp_load() or mbedtls_ecp_tls_read_group().\n \\param z         The destination MPI (shared secret).\n                  This must be initialized.\n \\param Q         The public key from another party.\n                  This must be initialized.\n \\param d         Our secret exponent (private key).\n                  This must be initialized.\n \\param f_rng     The RNG function to use. This must not be \\c NULL.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may be\n                  \\c NULL if \\p f_rng is \\c NULL or doesn't need a\n                  context argument.\n\n \\return          \\c 0 on success.\n \\return          Another \\c MBEDTLS_ERR_ECP_XXX or\n                  \\c MBEDTLS_MPI_XXX error code on failure."]
    pub fn mbedtls_ecdh_compute_shared(
        grp: *mut mbedtls_ecp_group,
        z: *mut mbedtls_mpi,
        Q: *const mbedtls_ecp_point,
        d: *const mbedtls_mpi,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function initializes an ECDH context.\n\n \\param ctx       The ECDH context to initialize. This must not be \\c NULL."]
    pub fn mbedtls_ecdh_init(ctx: *mut mbedtls_ecdh_context);
}
extern "C" {
    #[doc = " \\brief           This function sets up the ECDH context with the information\n                  given.\n\n                  This function should be called after mbedtls_ecdh_init() but\n                  before mbedtls_ecdh_make_params(). There is no need to call\n                  this function before mbedtls_ecdh_read_params().\n\n                  This is the first function used by a TLS server for ECDHE\n                  ciphersuites.\n\n \\param ctx       The ECDH context to set up. This must be initialized.\n \\param grp_id    The group id of the group to set up the context for.\n\n \\return          \\c 0 on success."]
    pub fn mbedtls_ecdh_setup(
        ctx: *mut mbedtls_ecdh_context,
        grp_id: mbedtls_ecp_group_id,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function frees a context.\n\n \\param ctx       The context to free. This may be \\c NULL, in which\n                  case this function does nothing. If it is not \\c NULL,\n                  it must point to an initialized ECDH context."]
    pub fn mbedtls_ecdh_free(ctx: *mut mbedtls_ecdh_context);
}
extern "C" {
    #[doc = " \\brief           This function generates an EC key pair and exports its\n                  in the format used in a TLS ServerKeyExchange handshake\n                  message.\n\n                  This is the second function used by a TLS server for ECDHE\n                  ciphersuites. (It is called after mbedtls_ecdh_setup().)\n\n \\see             ecp.h\n\n \\param ctx       The ECDH context to use. This must be initialized\n                  and bound to a group, for example via mbedtls_ecdh_setup().\n \\param olen      The address at which to store the number of Bytes written.\n \\param buf       The destination buffer. This must be a writable buffer of\n                  length \\p blen Bytes.\n \\param blen      The length of the destination buffer \\p buf in Bytes.\n \\param f_rng     The RNG function to use. This must not be \\c NULL.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may be\n                  \\c NULL in case \\p f_rng doesn't need a context argument.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of\n                  operations was reached: see \\c mbedtls_ecp_set_max_ops().\n \\return          Another \\c MBEDTLS_ERR_ECP_XXX error code on failure."]
    pub fn mbedtls_ecdh_make_params(
        ctx: *mut mbedtls_ecdh_context,
        olen: *mut usize,
        buf: *mut crate::c_types::c_uchar,
        blen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function parses the ECDHE parameters in a\n                  TLS ServerKeyExchange handshake message.\n\n \\note            In a TLS handshake, this is the how the client\n                  sets up its ECDHE context from the server's public\n                  ECDHE key material.\n\n \\see             ecp.h\n\n \\param ctx       The ECDHE context to use. This must be initialized.\n \\param buf       On input, \\c *buf must be the start of the input buffer.\n                  On output, \\c *buf is updated to point to the end of the\n                  data that has been read. On success, this is the first byte\n                  past the end of the ServerKeyExchange parameters.\n                  On error, this is the point at which an error has been\n                  detected, which is usually not useful except to debug\n                  failures.\n \\param end       The end of the input buffer.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX error code on failure.\n"]
    pub fn mbedtls_ecdh_read_params(
        ctx: *mut mbedtls_ecdh_context,
        buf: *mut *const crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function sets up an ECDH context from an EC key.\n\n                  It is used by clients and servers in place of the\n                  ServerKeyEchange for static ECDH, and imports ECDH\n                  parameters from the EC key information of a certificate.\n\n \\see             ecp.h\n\n \\param ctx       The ECDH context to set up. This must be initialized.\n \\param key       The EC key to use. This must be initialized.\n \\param side      Defines the source of the key. Possible values are:\n                  - #MBEDTLS_ECDH_OURS: The key is ours.\n                  - #MBEDTLS_ECDH_THEIRS: The key is that of the peer.\n\n \\return          \\c 0 on success.\n \\return          Another \\c MBEDTLS_ERR_ECP_XXX error code on failure.\n"]
    pub fn mbedtls_ecdh_get_params(
        ctx: *mut mbedtls_ecdh_context,
        key: *const mbedtls_ecp_keypair,
        side: mbedtls_ecdh_side,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function generates a public key and exports it\n                  as a TLS ClientKeyExchange payload.\n\n                  This is the second function used by a TLS client for ECDH(E)\n                  ciphersuites.\n\n \\see             ecp.h\n\n \\param ctx       The ECDH context to use. This must be initialized\n                  and bound to a group, the latter usually by\n                  mbedtls_ecdh_read_params().\n \\param olen      The address at which to store the number of Bytes written.\n                  This must not be \\c NULL.\n \\param buf       The destination buffer. This must be a writable buffer\n                  of length \\p blen Bytes.\n \\param blen      The size of the destination buffer \\p buf in Bytes.\n \\param f_rng     The RNG function to use. This must not be \\c NULL.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may be\n                  \\c NULL in case \\p f_rng doesn't need a context argument.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of\n                  operations was reached: see \\c mbedtls_ecp_set_max_ops().\n \\return          Another \\c MBEDTLS_ERR_ECP_XXX error code on failure."]
    pub fn mbedtls_ecdh_make_public(
        ctx: *mut mbedtls_ecdh_context,
        olen: *mut usize,
        buf: *mut crate::c_types::c_uchar,
        blen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief       This function parses and processes the ECDHE payload of a\n              TLS ClientKeyExchange message.\n\n              This is the third function used by a TLS server for ECDH(E)\n              ciphersuites. (It is called after mbedtls_ecdh_setup() and\n              mbedtls_ecdh_make_params().)\n\n \\see         ecp.h\n\n \\param ctx   The ECDH context to use. This must be initialized\n              and bound to a group, for example via mbedtls_ecdh_setup().\n \\param buf   The pointer to the ClientKeyExchange payload. This must\n              be a readable buffer of length \\p blen Bytes.\n \\param blen  The length of the input buffer \\p buf in Bytes.\n\n \\return      \\c 0 on success.\n \\return      An \\c MBEDTLS_ERR_ECP_XXX error code on failure."]
    pub fn mbedtls_ecdh_read_public(
        ctx: *mut mbedtls_ecdh_context,
        buf: *const crate::c_types::c_uchar,
        blen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           This function derives and exports the shared secret.\n\n                  This is the last function used by both TLS client\n                  and servers.\n\n \\note            If \\p f_rng is not NULL, it is used to implement\n                  countermeasures against side-channel attacks.\n                  For more information, see mbedtls_ecp_mul().\n\n \\see             ecp.h\n\n \\param ctx       The ECDH context to use. This must be initialized\n                  and have its own private key generated and the peer's\n                  public key imported.\n \\param olen      The address at which to store the total number of\n                  Bytes written on success. This must not be \\c NULL.\n \\param buf       The buffer to write the generated shared key to. This\n                  must be a writable buffer of size \\p blen Bytes.\n \\param blen      The length of the destination buffer \\p buf in Bytes.\n \\param f_rng     The RNG function to use. This must not be \\c NULL.\n \\param p_rng     The RNG context. This may be \\c NULL if \\p f_rng\n                  doesn't need a context argument.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of\n                  operations was reached: see \\c mbedtls_ecp_set_max_ops().\n \\return          Another \\c MBEDTLS_ERR_ECP_XXX error code on failure."]
    pub fn mbedtls_ecdh_calc_secret(
        ctx: *mut mbedtls_ecdh_context,
        olen: *mut usize,
        buf: *mut crate::c_types::c_uchar,
        blen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    ) -> crate::c_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_ssl_premaster_secret {
    pub _pms_rsa: [crate::c_types::c_uchar; 48usize],
    pub _pms_dhm: [crate::c_types::c_uchar; 1024usize],
    pub _pms_ecdh: [crate::c_types::c_uchar; 66usize],
    pub _pms_psk: [crate::c_types::c_uchar; 100usize],
    pub _pms_dhe_psk: [crate::c_types::c_uchar; 1076usize],
    pub _pms_rsa_psk: [crate::c_types::c_uchar; 100usize],
    pub _pms_ecdhe_psk: [crate::c_types::c_uchar; 118usize],
}
pub const mbedtls_ssl_states_MBEDTLS_SSL_HELLO_REQUEST: mbedtls_ssl_states = 0;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_HELLO: mbedtls_ssl_states = 1;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_HELLO: mbedtls_ssl_states = 2;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_CERTIFICATE: mbedtls_ssl_states = 3;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_KEY_EXCHANGE: mbedtls_ssl_states = 4;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CERTIFICATE_REQUEST: mbedtls_ssl_states = 5;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_HELLO_DONE: mbedtls_ssl_states = 6;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_CERTIFICATE: mbedtls_ssl_states = 7;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_KEY_EXCHANGE: mbedtls_ssl_states = 8;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CERTIFICATE_VERIFY: mbedtls_ssl_states = 9;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC: mbedtls_ssl_states = 10;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_FINISHED: mbedtls_ssl_states = 11;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC: mbedtls_ssl_states = 12;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_FINISHED: mbedtls_ssl_states = 13;
pub const mbedtls_ssl_states_MBEDTLS_SSL_FLUSH_BUFFERS: mbedtls_ssl_states = 14;
pub const mbedtls_ssl_states_MBEDTLS_SSL_HANDSHAKE_WRAPUP: mbedtls_ssl_states = 15;
pub const mbedtls_ssl_states_MBEDTLS_SSL_NEW_SESSION_TICKET: mbedtls_ssl_states = 16;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_HELLO_VERIFY_REQUEST_SENT: mbedtls_ssl_states = 17;
pub const mbedtls_ssl_states_MBEDTLS_SSL_HELLO_RETRY_REQUEST: mbedtls_ssl_states = 18;
pub const mbedtls_ssl_states_MBEDTLS_SSL_ENCRYPTED_EXTENSIONS: mbedtls_ssl_states = 19;
pub const mbedtls_ssl_states_MBEDTLS_SSL_END_OF_EARLY_DATA: mbedtls_ssl_states = 20;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_CERTIFICATE_VERIFY: mbedtls_ssl_states = 21;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_CCS_AFTER_SERVER_FINISHED: mbedtls_ssl_states = 22;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_CCS_BEFORE_2ND_CLIENT_HELLO: mbedtls_ssl_states =
    23;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_CCS_AFTER_SERVER_HELLO: mbedtls_ssl_states = 24;
pub const mbedtls_ssl_states_MBEDTLS_SSL_CLIENT_CCS_AFTER_CLIENT_HELLO: mbedtls_ssl_states = 25;
pub const mbedtls_ssl_states_MBEDTLS_SSL_SERVER_CCS_AFTER_HELLO_RETRY_REQUEST: mbedtls_ssl_states =
    26;
pub const mbedtls_ssl_states_MBEDTLS_SSL_HANDSHAKE_OVER: mbedtls_ssl_states = 27;
pub const mbedtls_ssl_states_MBEDTLS_SSL_TLS1_3_NEW_SESSION_TICKET: mbedtls_ssl_states = 28;
pub const mbedtls_ssl_states_MBEDTLS_SSL_TLS1_3_NEW_SESSION_TICKET_FLUSH: mbedtls_ssl_states = 29;
pub type mbedtls_ssl_states = crate::c_types::c_uint;
#[doc = " \\brief          Callback type: send data on the network.\n\n \\note           That callback may be either blocking or non-blocking.\n\n \\param ctx      Context for the send callback (typically a file descriptor)\n \\param buf      Buffer holding the data to send\n \\param len      Length of the data to send\n\n \\return         The callback must return the number of bytes sent if any,\n                 or a non-zero error code.\n                 If performing non-blocking I/O, \\c MBEDTLS_ERR_SSL_WANT_WRITE\n                 must be returned when the operation would block.\n\n \\note           The callback is allowed to send fewer bytes than requested.\n                 It must always return the number of bytes actually sent."]
pub type mbedtls_ssl_send_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::c_types::c_void,
        buf: *const crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int,
>;
#[doc = " \\brief          Callback type: receive data from the network.\n\n \\note           That callback may be either blocking or non-blocking.\n\n \\param ctx      Context for the receive callback (typically a file\n                 descriptor)\n \\param buf      Buffer to write the received data to\n \\param len      Length of the receive buffer\n\n \\returns        If data has been received, the positive number of bytes received.\n \\returns        \\c 0 if the connection has been closed.\n \\returns        If performing non-blocking I/O, \\c MBEDTLS_ERR_SSL_WANT_READ\n                 must be returned when the operation would block.\n \\returns        Another negative error code on other kinds of failures.\n\n \\note           The callback may receive fewer bytes than the length of the\n                 buffer. It must always return the number of bytes actually\n                 received and written to the buffer."]
pub type mbedtls_ssl_recv_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::c_types::c_void,
        buf: *mut crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int,
>;
#[doc = " \\brief          Callback type: receive data from the network, with timeout\n\n \\note           That callback must block until data is received, or the\n                 timeout delay expires, or the operation is interrupted by a\n                 signal.\n\n \\param ctx      Context for the receive callback (typically a file descriptor)\n \\param buf      Buffer to write the received data to\n \\param len      Length of the receive buffer\n \\param timeout  Maximum number of milliseconds to wait for data\n                 0 means no timeout (potentially waiting forever)\n\n \\return         The callback must return the number of bytes received,\n                 or a non-zero error code:\n                 \\c MBEDTLS_ERR_SSL_TIMEOUT if the operation timed out,\n                 \\c MBEDTLS_ERR_SSL_WANT_READ if interrupted by a signal.\n\n \\note           The callback may receive fewer bytes than the length of the\n                 buffer. It must always return the number of bytes actually\n                 received and written to the buffer."]
pub type mbedtls_ssl_recv_timeout_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::c_types::c_void,
        buf: *mut crate::c_types::c_uchar,
        len: usize,
        timeout: u32,
    ) -> crate::c_types::c_int,
>;
#[doc = " \\brief          Callback type: set a pair of timers/delays to watch\n\n \\param ctx      Context pointer\n \\param int_ms   Intermediate delay in milliseconds\n \\param fin_ms   Final delay in milliseconds\n                 0 cancels the current timer.\n\n \\note           This callback must at least store the necessary information\n                 for the associated \\c mbedtls_ssl_get_timer_t callback to\n                 return correct information.\n\n \\note           If using an event-driven style of programming, an event must\n                 be generated when the final delay is passed. The event must\n                 cause a call to \\c mbedtls_ssl_handshake() with the proper\n                 SSL context to be scheduled. Care must be taken to ensure\n                 that at most one such call happens at a time.\n\n \\note           Only one timer at a time must be running. Calling this\n                 function while a timer is running must cancel it. Cancelled\n                 timers must not generate any event."]
pub type mbedtls_ssl_set_timer_t = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut crate::c_types::c_void, int_ms: u32, fin_ms: u32),
>;
#[doc = " \\brief          Callback type: get status of timers/delays\n\n \\param ctx      Context pointer\n\n \\return         This callback must return:\n                 -1 if cancelled (fin_ms == 0),\n                  0 if none of the delays have passed,\n                  1 if only the intermediate delay has passed,\n                  2 if the final delay has passed."]
pub type mbedtls_ssl_get_timer_t = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut crate::c_types::c_void) -> crate::c_types::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_transform {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_handshake_params {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_sig_hash_set_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_key_cert {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_flight_item {
    _unused: [u8; 0],
}
#[doc = " \\brief          Callback type: server-side session cache getter\n\n                 The session cache is logically a key value store, with\n                 keys being session IDs and values being instances of\n                 mbedtls_ssl_session.\n\n                 This callback retrieves an entry in this key-value store.\n\n \\param data            The address of the session cache structure to query.\n \\param session_id      The buffer holding the session ID to query.\n \\param session_id_len  The length of \\p session_id in Bytes.\n \\param session         The address of the session structure to populate.\n                        It is initialized with mbdtls_ssl_session_init(),\n                        and the callback must always leave it in a state\n                        where it can safely be freed via\n                        mbedtls_ssl_session_free() independent of the\n                        return code of this function.\n\n \\return                \\c 0 on success\n \\return                A non-zero return value on failure.\n"]
pub type mbedtls_ssl_cache_get_t = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut crate::c_types::c_void,
        session_id: *const crate::c_types::c_uchar,
        session_id_len: usize,
        session: *mut mbedtls_ssl_session,
    ) -> crate::c_types::c_int,
>;
#[doc = " \\brief          Callback type: server-side session cache setter\n\n                 The session cache is logically a key value store, with\n                 keys being session IDs and values being instances of\n                 mbedtls_ssl_session.\n\n                 This callback sets an entry in this key-value store.\n\n \\param data            The address of the session cache structure to modify.\n \\param session_id      The buffer holding the session ID to query.\n \\param session_id_len  The length of \\p session_id in Bytes.\n \\param session         The address of the session to be stored in the\n                        session cache.\n\n \\return                \\c 0 on success\n \\return                A non-zero return value on failure."]
pub type mbedtls_ssl_cache_set_t = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut crate::c_types::c_void,
        session_id: *const crate::c_types::c_uchar,
        session_id_len: usize,
        session: *const mbedtls_ssl_session,
    ) -> crate::c_types::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_tls13_application_secrets {
    pub client_application_traffic_secret_N: [crate::c_types::c_uchar; 64usize],
    pub server_application_traffic_secret_N: [crate::c_types::c_uchar; 64usize],
    pub exporter_master_secret: [crate::c_types::c_uchar; 64usize],
    pub resumption_master_secret: [crate::c_types::c_uchar; 64usize],
}
#[doc = "< Context not in use or version not yet negotiated."]
pub const mbedtls_ssl_protocol_version_MBEDTLS_SSL_VERSION_UNKNOWN: mbedtls_ssl_protocol_version =
    0;
#[doc = "< (D)TLS 1.2"]
pub const mbedtls_ssl_protocol_version_MBEDTLS_SSL_VERSION_TLS1_2: mbedtls_ssl_protocol_version =
    771;
#[doc = "< (D)TLS 1.3"]
pub const mbedtls_ssl_protocol_version_MBEDTLS_SSL_VERSION_TLS1_3: mbedtls_ssl_protocol_version =
    772;
#[doc = " Human-friendly representation of the (D)TLS protocol version."]
pub type mbedtls_ssl_protocol_version = crate::c_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_session {
    pub private_mfl_code: crate::c_types::c_uchar,
    pub private_exported: crate::c_types::c_uchar,
    pub private_tls_version: mbedtls_ssl_protocol_version,
    pub private_ciphersuite: crate::c_types::c_int,
    pub private_id_len: usize,
    pub private_id: [crate::c_types::c_uchar; 32usize],
    pub private_master: [crate::c_types::c_uchar; 48usize],
    pub private_peer_cert: *mut mbedtls_x509_crt,
    pub private_verify_result: u32,
    pub private_ticket: *mut crate::c_types::c_uchar,
    pub private_ticket_len: usize,
    pub private_ticket_lifetime: u32,
    pub private_endpoint: u8,
    pub private_ticket_flags: u8,
    pub private_ticket_age_add: u32,
    pub private_resumption_key_len: u8,
    pub private_resumption_key: [crate::c_types::c_uchar; 48usize],
    pub private_hostname: *mut crate::c_types::c_char,
    pub private_encrypt_then_mac: crate::c_types::c_int,
    pub private_app_secrets: mbedtls_ssl_tls13_application_secrets,
}
pub const mbedtls_tls_prf_types_MBEDTLS_SSL_TLS_PRF_NONE: mbedtls_tls_prf_types = 0;
pub const mbedtls_tls_prf_types_MBEDTLS_SSL_TLS_PRF_SHA384: mbedtls_tls_prf_types = 1;
pub const mbedtls_tls_prf_types_MBEDTLS_SSL_TLS_PRF_SHA256: mbedtls_tls_prf_types = 2;
pub const mbedtls_tls_prf_types_MBEDTLS_SSL_HKDF_EXPAND_SHA384: mbedtls_tls_prf_types = 3;
pub const mbedtls_tls_prf_types_MBEDTLS_SSL_HKDF_EXPAND_SHA256: mbedtls_tls_prf_types = 4;
pub type mbedtls_tls_prf_types = crate::c_types::c_uint;
pub const mbedtls_ssl_key_export_type_MBEDTLS_SSL_KEY_EXPORT_TLS12_MASTER_SECRET:
    mbedtls_ssl_key_export_type = 0;
pub const mbedtls_ssl_key_export_type_MBEDTLS_SSL_KEY_EXPORT_TLS1_3_CLIENT_EARLY_SECRET:
    mbedtls_ssl_key_export_type = 1;
pub const mbedtls_ssl_key_export_type_MBEDTLS_SSL_KEY_EXPORT_TLS1_3_EARLY_EXPORTER_SECRET:
    mbedtls_ssl_key_export_type = 2;
pub const mbedtls_ssl_key_export_type_MBEDTLS_SSL_KEY_EXPORT_TLS1_3_CLIENT_HANDSHAKE_TRAFFIC_SECRET : mbedtls_ssl_key_export_type = 3 ;
pub const mbedtls_ssl_key_export_type_MBEDTLS_SSL_KEY_EXPORT_TLS1_3_SERVER_HANDSHAKE_TRAFFIC_SECRET : mbedtls_ssl_key_export_type = 4 ;
pub const mbedtls_ssl_key_export_type_MBEDTLS_SSL_KEY_EXPORT_TLS1_3_CLIENT_APPLICATION_TRAFFIC_SECRET : mbedtls_ssl_key_export_type = 5 ;
pub const mbedtls_ssl_key_export_type_MBEDTLS_SSL_KEY_EXPORT_TLS1_3_SERVER_APPLICATION_TRAFFIC_SECRET : mbedtls_ssl_key_export_type = 6 ;
pub type mbedtls_ssl_key_export_type = crate::c_types::c_uint;
#[doc = " \\brief           Callback type: Export key alongside random values for\n                                 session identification, and PRF for\n                                 implementation of TLS key exporters.\n\n \\param p_expkey   Context for the callback.\n \\param type       The type of the key that is being exported.\n \\param secret     The address of the buffer holding the secret\n                   that's being exporterd.\n \\param secret_len The length of \\p secret in bytes.\n \\param client_random The client random bytes.\n \\param server_random The server random bytes.\n \\param tls_prf_type The identifier for the PRF used in the handshake\n                     to which the key belongs."]
pub type mbedtls_ssl_export_keys_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_expkey: *mut crate::c_types::c_void,
        type_: mbedtls_ssl_key_export_type,
        secret: *const crate::c_types::c_uchar,
        secret_len: usize,
        client_random: *const crate::c_types::c_uchar,
        server_random: *const crate::c_types::c_uchar,
        tls_prf_type: mbedtls_tls_prf_types,
    ),
>;
#[doc = " \\brief           Callback type: generic handshake callback\n\n \\note            Callbacks may use user_data funcs to set/get app user data.\n                  See \\c mbedtls_ssl_get_user_data_p()\n                      \\c mbedtls_ssl_get_user_data_n()\n                      \\c mbedtls_ssl_conf_get_user_data_p()\n                      \\c mbedtls_ssl_conf_get_user_data_n()\n\n \\param ssl       \\c mbedtls_ssl_context on which the callback is run\n\n \\return          The return value of the callback is 0 if successful,\n                  or a specific MBEDTLS_ERR_XXX code, which will cause\n                  the handshake to be aborted."]
pub type mbedtls_ssl_hs_cb_t = ::core::option::Option<
    unsafe extern "C" fn(ssl: *mut mbedtls_ssl_context) -> crate::c_types::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_ssl_user_data_t {
    pub n: usize,
    pub p: *mut crate::c_types::c_void,
}
#[doc = " SSL/TLS configuration to be shared between mbedtls_ssl_context structures."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_config {
    pub private_max_tls_version: mbedtls_ssl_protocol_version,
    pub private_min_tls_version: mbedtls_ssl_protocol_version,
    pub private_endpoint: u8,
    pub private_transport: u8,
    pub private_authmode: u8,
    pub private_allow_legacy_renegotiation: u8,
    pub private_mfl_code: u8,
    pub private_encrypt_then_mac: u8,
    pub private_extended_ms: u8,
    pub private_anti_replay: u8,
    pub private_disable_renegotiation: u8,
    pub private_session_tickets: u8,
    pub private_new_session_tickets_count: u16,
    pub private_cert_req_ca_list: u8,
    pub private_respect_cli_pref: u8,
    pub private_ignore_unexpected_cid: u8,
    pub private_ciphersuite_list: *const crate::c_types::c_int,
    pub private_tls13_kex_modes: crate::c_types::c_int,
    pub private_f_dbg: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: crate::c_types::c_int,
            arg3: *const crate::c_types::c_char,
            arg4: crate::c_types::c_int,
            arg5: *const crate::c_types::c_char,
        ),
    >,
    pub private_p_dbg: *mut crate::c_types::c_void,
    pub private_f_rng: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: *mut crate::c_types::c_uchar,
            arg3: usize,
        ) -> crate::c_types::c_int,
    >,
    pub private_p_rng: *mut crate::c_types::c_void,
    pub private_f_get_cache: mbedtls_ssl_cache_get_t,
    pub private_f_set_cache: mbedtls_ssl_cache_set_t,
    pub private_p_cache: *mut crate::c_types::c_void,
    pub private_f_sni: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: *mut mbedtls_ssl_context,
            arg3: *const crate::c_types::c_uchar,
            arg4: usize,
        ) -> crate::c_types::c_int,
    >,
    pub private_p_sni: *mut crate::c_types::c_void,
    pub private_f_vrfy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: *mut mbedtls_x509_crt,
            arg3: crate::c_types::c_int,
            arg4: *mut u32,
        ) -> crate::c_types::c_int,
    >,
    pub private_p_vrfy: *mut crate::c_types::c_void,
    pub private_f_psk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: *mut mbedtls_ssl_context,
            arg3: *const crate::c_types::c_uchar,
            arg4: usize,
        ) -> crate::c_types::c_int,
    >,
    pub private_p_psk: *mut crate::c_types::c_void,
    pub private_f_cookie_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: *mut *mut crate::c_types::c_uchar,
            arg3: *mut crate::c_types::c_uchar,
            arg4: *const crate::c_types::c_uchar,
            arg5: usize,
        ) -> crate::c_types::c_int,
    >,
    pub private_f_cookie_check: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: *const crate::c_types::c_uchar,
            arg3: usize,
            arg4: *const crate::c_types::c_uchar,
            arg5: usize,
        ) -> crate::c_types::c_int,
    >,
    pub private_p_cookie: *mut crate::c_types::c_void,
    pub private_f_ticket_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: *const mbedtls_ssl_session,
            arg3: *mut crate::c_types::c_uchar,
            arg4: *const crate::c_types::c_uchar,
            arg5: *mut usize,
            arg6: *mut u32,
        ) -> crate::c_types::c_int,
    >,
    pub private_f_ticket_parse: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: *mut mbedtls_ssl_session,
            arg3: *mut crate::c_types::c_uchar,
            arg4: usize,
        ) -> crate::c_types::c_int,
    >,
    pub private_p_ticket: *mut crate::c_types::c_void,
    pub private_cid_len: usize,
    pub private_cert_profile: *const mbedtls_x509_crt_profile,
    pub private_key_cert: *mut mbedtls_ssl_key_cert,
    pub private_ca_chain: *mut mbedtls_x509_crt,
    pub private_ca_crl: *mut mbedtls_x509_crl,
    pub private_sig_hashes: *const crate::c_types::c_int,
    pub private_sig_algs: *const u16,
    pub private_curve_list: *const mbedtls_ecp_group_id,
    pub private_group_list: *const u16,
    pub private_dhm_P: mbedtls_mpi,
    pub private_dhm_G: mbedtls_mpi,
    pub private_psk: *mut crate::c_types::c_uchar,
    pub private_psk_len: usize,
    pub private_psk_identity: *mut crate::c_types::c_uchar,
    pub private_psk_identity_len: usize,
    pub private_alpn_list: *mut *const crate::c_types::c_char,
    pub private_read_timeout: u32,
    pub private_hs_timeout_min: u32,
    pub private_hs_timeout_max: u32,
    pub private_renego_max_records: crate::c_types::c_int,
    pub private_renego_period: [crate::c_types::c_uchar; 8usize],
    pub private_badmac_limit: crate::c_types::c_uint,
    pub private_dhm_min_bitlen: crate::c_types::c_uint,
    pub private_user_data: mbedtls_ssl_user_data_t,
    pub private_f_cert_cb: mbedtls_ssl_hs_cb_t,
    pub private_dn_hints: *const mbedtls_x509_crt,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ssl_context {
    pub private_conf: *const mbedtls_ssl_config,
    pub private_state: crate::c_types::c_int,
    pub private_renego_status: crate::c_types::c_int,
    pub private_renego_records_seen: crate::c_types::c_int,
    pub private_tls_version: mbedtls_ssl_protocol_version,
    pub private_badmac_seen: crate::c_types::c_uint,
    pub private_f_vrfy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: *mut mbedtls_x509_crt,
            arg3: crate::c_types::c_int,
            arg4: *mut u32,
        ) -> crate::c_types::c_int,
    >,
    pub private_p_vrfy: *mut crate::c_types::c_void,
    pub private_f_send: mbedtls_ssl_send_t,
    pub private_f_recv: mbedtls_ssl_recv_t,
    pub private_f_recv_timeout: mbedtls_ssl_recv_timeout_t,
    pub private_p_bio: *mut crate::c_types::c_void,
    pub private_session_in: *mut mbedtls_ssl_session,
    pub private_session_out: *mut mbedtls_ssl_session,
    pub private_session: *mut mbedtls_ssl_session,
    pub private_session_negotiate: *mut mbedtls_ssl_session,
    pub private_handshake: *mut mbedtls_ssl_handshake_params,
    pub private_transform_in: *mut mbedtls_ssl_transform,
    pub private_transform_out: *mut mbedtls_ssl_transform,
    pub private_transform: *mut mbedtls_ssl_transform,
    pub private_transform_negotiate: *mut mbedtls_ssl_transform,
    pub private_transform_application: *mut mbedtls_ssl_transform,
    pub private_p_timer: *mut crate::c_types::c_void,
    pub private_f_set_timer: mbedtls_ssl_set_timer_t,
    pub private_f_get_timer: mbedtls_ssl_get_timer_t,
    pub private_in_buf: *mut crate::c_types::c_uchar,
    pub private_in_ctr: *mut crate::c_types::c_uchar,
    pub private_in_hdr: *mut crate::c_types::c_uchar,
    pub private_in_cid: *mut crate::c_types::c_uchar,
    pub private_in_len: *mut crate::c_types::c_uchar,
    pub private_in_iv: *mut crate::c_types::c_uchar,
    pub private_in_msg: *mut crate::c_types::c_uchar,
    pub private_in_offt: *mut crate::c_types::c_uchar,
    pub private_in_msgtype: crate::c_types::c_int,
    pub private_in_msglen: usize,
    pub private_in_left: usize,
    pub private_in_epoch: u16,
    pub private_next_record_offset: usize,
    pub private_in_window_top: u64,
    pub private_in_window: u64,
    pub private_in_hslen: usize,
    pub private_nb_zero: crate::c_types::c_int,
    pub private_keep_current_message: crate::c_types::c_int,
    pub private_send_alert: crate::c_types::c_uchar,
    pub private_alert_type: crate::c_types::c_uchar,
    pub private_alert_reason: crate::c_types::c_int,
    pub private_disable_datagram_packing: u8,
    pub private_out_buf: *mut crate::c_types::c_uchar,
    pub private_out_ctr: *mut crate::c_types::c_uchar,
    pub private_out_hdr: *mut crate::c_types::c_uchar,
    pub private_out_cid: *mut crate::c_types::c_uchar,
    pub private_out_len: *mut crate::c_types::c_uchar,
    pub private_out_iv: *mut crate::c_types::c_uchar,
    pub private_out_msg: *mut crate::c_types::c_uchar,
    pub private_out_msgtype: crate::c_types::c_int,
    pub private_out_msglen: usize,
    pub private_out_left: usize,
    pub private_cur_out_ctr: [crate::c_types::c_uchar; 8usize],
    pub private_mtu: u16,
    pub private_hostname: *mut crate::c_types::c_char,
    pub private_alpn_chosen: *const crate::c_types::c_char,
    pub private_cli_id: *mut crate::c_types::c_uchar,
    pub private_cli_id_len: usize,
    pub private_secure_renegotiation: crate::c_types::c_int,
    pub private_verify_data_len: usize,
    pub private_own_verify_data: [crate::c_types::c_char; 12usize],
    pub private_peer_verify_data: [crate::c_types::c_char; 12usize],
    pub private_own_cid: [crate::c_types::c_uchar; 32usize],
    pub private_own_cid_len: u8,
    pub private_negotiate_cid: u8,
    pub private_f_export_keys: mbedtls_ssl_export_keys_t,
    pub private_p_export_keys: *mut crate::c_types::c_void,
    pub private_user_data: mbedtls_ssl_user_data_t,
}
extern "C" {
    #[doc = " \\brief               Return the name of the ciphersuite associated with the\n                      given ID\n\n \\param ciphersuite_id SSL ciphersuite ID\n\n \\return              a string containing the ciphersuite name"]
    pub fn mbedtls_ssl_get_ciphersuite_name(
        ciphersuite_id: crate::c_types::c_int,
    ) -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " \\brief               Return the ID of the ciphersuite associated with the\n                      given name\n\n \\param ciphersuite_name SSL ciphersuite name\n\n \\return              the ID with the ciphersuite or 0 if not found"]
    pub fn mbedtls_ssl_get_ciphersuite_id(
        ciphersuite_name: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Initialize an SSL context\n                 Just makes the context ready for mbedtls_ssl_setup() or\n                 mbedtls_ssl_free()\n\n \\param ssl      SSL context"]
    pub fn mbedtls_ssl_init(ssl: *mut mbedtls_ssl_context);
}
extern "C" {
    #[doc = " \\brief          Set up an SSL context for use\n\n \\note           No copy of the configuration context is made, it can be\n                 shared by many mbedtls_ssl_context structures.\n\n \\warning        The conf structure will be accessed during the session.\n                 It must not be modified or freed as long as the session\n                 is active.\n\n \\warning        This function must be called exactly once per context.\n                 Calling mbedtls_ssl_setup again is not supported, even\n                 if no session is active.\n\n \\note           If #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto\n                 subsystem must have been initialized by calling\n                 psa_crypto_init() before calling this function.\n\n \\param ssl      SSL context\n \\param conf     SSL configuration to use\n\n \\return         0 if successful, or MBEDTLS_ERR_SSL_ALLOC_FAILED if\n                 memory allocation failed"]
    pub fn mbedtls_ssl_setup(
        ssl: *mut mbedtls_ssl_context,
        conf: *const mbedtls_ssl_config,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Reset an already initialized SSL context for re-use\n                 while retaining application-set variables, function\n                 pointers and data.\n\n \\param ssl      SSL context\n \\return         0 if successful, or MBEDTLS_ERR_SSL_ALLOC_FAILED or\nMBEDTLS_ERR_SSL_HW_ACCEL_FAILED"]
    pub fn mbedtls_ssl_session_reset(ssl: *mut mbedtls_ssl_context) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the current endpoint type\n\n \\param conf     SSL configuration\n \\param endpoint must be MBEDTLS_SSL_IS_CLIENT or MBEDTLS_SSL_IS_SERVER"]
    pub fn mbedtls_ssl_conf_endpoint(
        conf: *mut mbedtls_ssl_config,
        endpoint: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief           Set the transport type (TLS or DTLS).\n                  Default: TLS\n\n \\note            For DTLS, you must either provide a recv callback that\n                  doesn't block, or one that handles timeouts, see\n                  \\c mbedtls_ssl_set_bio(). You also need to provide timer\n                  callbacks with \\c mbedtls_ssl_set_timer_cb().\n\n \\param conf      SSL configuration\n \\param transport transport type:\n                  MBEDTLS_SSL_TRANSPORT_STREAM for TLS,\n                  MBEDTLS_SSL_TRANSPORT_DATAGRAM for DTLS."]
    pub fn mbedtls_ssl_conf_transport(
        conf: *mut mbedtls_ssl_config,
        transport: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          Set the certificate verification mode\n                 Default: NONE on server, REQUIRED on client\n\n \\param conf     SSL configuration\n \\param authmode can be:\n\n  MBEDTLS_SSL_VERIFY_NONE:      peer certificate is not checked\n                        (default on server)\n                        (insecure on client)\n\n  MBEDTLS_SSL_VERIFY_OPTIONAL:  peer certificate is checked, however the\n                        handshake continues even if verification failed;\n                        mbedtls_ssl_get_verify_result() can be called after the\n                        handshake is complete.\n\n  MBEDTLS_SSL_VERIFY_REQUIRED:  peer *must* present a valid certificate,\n                        handshake is aborted if verification failed.\n                        (default on client)\n\n \\note On client, MBEDTLS_SSL_VERIFY_REQUIRED is the recommended mode.\n With MBEDTLS_SSL_VERIFY_OPTIONAL, the user needs to call mbedtls_ssl_get_verify_result() at\n the right time(s), which may not be obvious, while REQUIRED always perform\n the verification as soon as possible. For example, REQUIRED was protecting\n against the \"triple handshake\" attack even before it was found."]
    pub fn mbedtls_ssl_conf_authmode(
        conf: *mut mbedtls_ssl_config,
        authmode: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          Set the verification callback (Optional).\n\n                 If set, the provided verify callback is called for each\n                 certificate in the peer's CRT chain, including the trusted\n                 root. For more information, please see the documentation of\n                 \\c mbedtls_x509_crt_verify().\n\n \\note           For per context callbacks and contexts, please use\n                 mbedtls_ssl_set_verify() instead.\n\n \\param conf     The SSL configuration to use.\n \\param f_vrfy   The verification callback to use during CRT verification.\n \\param p_vrfy   The opaque context to be passed to the callback."]
    pub fn mbedtls_ssl_conf_verify(
        conf: *mut mbedtls_ssl_config,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut mbedtls_x509_crt,
                arg3: crate::c_types::c_int,
                arg4: *mut u32,
            ) -> crate::c_types::c_int,
        >,
        p_vrfy: *mut crate::c_types::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set the random number generator callback\n\n \\param conf     SSL configuration\n \\param f_rng    RNG function (mandatory)\n \\param p_rng    RNG parameter"]
    pub fn mbedtls_ssl_conf_rng(
        conf: *mut mbedtls_ssl_config,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_rng: *mut crate::c_types::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set the debug callback\n\n                 The callback has the following argument:\n                 void *           opaque context for the callback\n                 int              debug level\n                 const char *     file name\n                 int              line number\n                 const char *     message\n\n \\param conf     SSL configuration\n \\param f_dbg    debug function\n \\param p_dbg    debug parameter"]
    pub fn mbedtls_ssl_conf_dbg(
        conf: *mut mbedtls_ssl_config,
        f_dbg: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: crate::c_types::c_int,
                arg3: *const crate::c_types::c_char,
                arg4: crate::c_types::c_int,
                arg5: *const crate::c_types::c_char,
            ),
        >,
        p_dbg: *mut crate::c_types::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set the underlying BIO callbacks for write, read and\n                 read-with-timeout.\n\n \\param ssl      SSL context\n \\param p_bio    parameter (context) shared by BIO callbacks\n \\param f_send   write callback\n \\param f_recv   read callback\n \\param f_recv_timeout blocking read callback with timeout.\n\n \\note           One of f_recv or f_recv_timeout can be NULL, in which case\n                 the other is used. If both are non-NULL, f_recv_timeout is\n                 used and f_recv is ignored (as if it were NULL).\n\n \\note           The two most common use cases are:\n                 - non-blocking I/O, f_recv != NULL, f_recv_timeout == NULL\n                 - blocking I/O, f_recv == NULL, f_recv_timeout != NULL\n\n \\note           For DTLS, you need to provide either a non-NULL\n                 f_recv_timeout callback, or a f_recv that doesn't block.\n\n \\note           See the documentations of \\c mbedtls_ssl_send_t,\n                 \\c mbedtls_ssl_recv_t and \\c mbedtls_ssl_recv_timeout_t for\n                 the conventions those callbacks must follow.\n\n \\note           On some platforms, net_sockets.c provides\n                 \\c mbedtls_net_send(), \\c mbedtls_net_recv() and\n                 \\c mbedtls_net_recv_timeout() that are suitable to be used\n                 here."]
    pub fn mbedtls_ssl_set_bio(
        ssl: *mut mbedtls_ssl_context,
        p_bio: *mut crate::c_types::c_void,
        f_send: mbedtls_ssl_send_t,
        f_recv: mbedtls_ssl_recv_t,
        f_recv_timeout: mbedtls_ssl_recv_timeout_t,
    );
}
extern "C" {
    #[doc = " \\brief             Configure the use of the Connection ID (CID)\n                    extension in the next handshake.\n\n                    Reference: RFC 9146 (or draft-ietf-tls-dtls-connection-id-05\n                    https://tools.ietf.org/html/draft-ietf-tls-dtls-connection-id-05\n                    for legacy version)\n\n                    The DTLS CID extension allows the reliable association of\n                    DTLS records to DTLS connections across changes in the\n                    underlying transport (changed IP and Port metadata) by\n                    adding explicit connection identifiers (CIDs) to the\n                    headers of encrypted DTLS records. The desired CIDs are\n                    configured by the application layer and are exchanged in\n                    new `ClientHello` / `ServerHello` extensions during the\n                    handshake, where each side indicates the CID it wants the\n                    peer to use when writing encrypted messages. The CIDs are\n                    put to use once records get encrypted: the stack discards\n                    any incoming records that don't include the configured CID\n                    in their header, and adds the peer's requested CID to the\n                    headers of outgoing messages.\n\n                    This API enables or disables the use of the CID extension\n                    in the next handshake and sets the value of the CID to\n                    be used for incoming messages.\n\n \\param ssl         The SSL context to configure. This must be initialized.\n \\param enable      This value determines whether the CID extension should\n                    be used or not. Possible values are:\n                    - MBEDTLS_SSL_CID_ENABLED to enable the use of the CID.\n                    - MBEDTLS_SSL_CID_DISABLED (default) to disable the use\n                      of the CID.\n \\param own_cid     The address of the readable buffer holding the CID we want\n                    the peer to use when sending encrypted messages to us.\n                    This may be \\c NULL if \\p own_cid_len is \\c 0.\n                    This parameter is unused if \\p enabled is set to\n                    MBEDTLS_SSL_CID_DISABLED.\n \\param own_cid_len The length of \\p own_cid.\n                    This parameter is unused if \\p enabled is set to\n                    MBEDTLS_SSL_CID_DISABLED.\n\n \\note              The value of \\p own_cid_len must match the value of the\n                    \\c len parameter passed to mbedtls_ssl_conf_cid()\n                    when configuring the ::mbedtls_ssl_config that \\p ssl\n                    is bound to.\n\n \\note              This CID configuration applies to subsequent handshakes\n                    performed on the SSL context \\p ssl, but does not trigger\n                    one. You still have to call `mbedtls_ssl_handshake()`\n                    (for the initial handshake) or `mbedtls_ssl_renegotiate()`\n                    (for a renegotiation handshake) explicitly after a\n                    successful call to this function to run the handshake.\n\n \\note              This call cannot guarantee that the use of the CID\n                    will be successfully negotiated in the next handshake,\n                    because the peer might not support it. Specifically:\n                    - On the Client, enabling the use of the CID through\n                      this call implies that the `ClientHello` in the next\n                      handshake will include the CID extension, thereby\n                      offering the use of the CID to the server. Only if\n                      the `ServerHello` contains the CID extension, too,\n                      the CID extension will actually be put to use.\n                    - On the Server, enabling the use of the CID through\n                      this call implies that the server will look for\n                      the CID extension in a `ClientHello` from the client,\n                      and, if present, reply with a CID extension in its\n                      `ServerHello`.\n\n \\note              To check whether the use of the CID was negotiated\n                    after the subsequent handshake has completed, please\n                    use the API mbedtls_ssl_get_peer_cid().\n\n \\warning           If the use of the CID extension is enabled in this call\n                    and the subsequent handshake negotiates its use, Mbed TLS\n                    will silently drop every packet whose CID does not match\n                    the CID configured in \\p own_cid. It is the responsibility\n                    of the user to adapt the underlying transport to take care\n                    of CID-based demultiplexing before handing datagrams to\n                    Mbed TLS.\n\n \\return            \\c 0 on success. In this case, the CID configuration\n                    applies to the next handshake.\n \\return            A negative error code on failure."]
    pub fn mbedtls_ssl_set_cid(
        ssl: *mut mbedtls_ssl_context,
        enable: crate::c_types::c_int,
        own_cid: *const crate::c_types::c_uchar,
        own_cid_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief              Get information about our request for usage of the CID\n                     extension in the current connection.\n\n \\param ssl          The SSL context to query.\n \\param enabled      The address at which to store whether the CID extension\n                     is requested to be used or not. If the CID is\n                     requested, `*enabled` is set to\n                     MBEDTLS_SSL_CID_ENABLED; otherwise, it is set to\n                     MBEDTLS_SSL_CID_DISABLED.\n \\param own_cid      The address of the buffer in which to store our own\n                     CID (if the CID extension is requested). This may be\n                     \\c NULL in case the value of our CID isn't needed. If\n                     it is not \\c NULL, \\p own_cid_len must not be \\c NULL.\n \\param own_cid_len  The address at which to store the size of our own CID\n                     (if the CID extension is requested). This is also the\n                     number of Bytes in \\p own_cid that have been written.\n                     This may be \\c NULL in case the length of our own CID\n                     isn't needed. If it is \\c NULL, \\p own_cid must be\n                     \\c NULL, too.\n\n\\note                If we are requesting an empty CID this function sets\n                     `*enabled` to #MBEDTLS_SSL_CID_DISABLED (the rationale\n                     for this is that the resulting outcome is the\n                     same as if the CID extensions wasn't requested).\n\n \\return            \\c 0 on success.\n \\return            A negative error code on failure."]
    pub fn mbedtls_ssl_get_own_cid(
        ssl: *mut mbedtls_ssl_context,
        enabled: *mut crate::c_types::c_int,
        own_cid: *mut crate::c_types::c_uchar,
        own_cid_len: *mut usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief              Get information about the use of the CID extension\n                     in the current connection.\n\n \\param ssl          The SSL context to query.\n \\param enabled      The address at which to store whether the CID extension\n                     is currently in use or not. If the CID is in use,\n                     `*enabled` is set to MBEDTLS_SSL_CID_ENABLED;\n                     otherwise, it is set to MBEDTLS_SSL_CID_DISABLED.\n \\param peer_cid     The address of the buffer in which to store the CID\n                     chosen by the peer (if the CID extension is used).\n                     This may be \\c NULL in case the value of peer CID\n                     isn't needed. If it is not \\c NULL, \\p peer_cid_len\n                     must not be \\c NULL.\n \\param peer_cid_len The address at which to store the size of the CID\n                     chosen by the peer (if the CID extension is used).\n                     This is also the number of Bytes in \\p peer_cid that\n                     have been written.\n                     This may be \\c NULL in case the length of the peer CID\n                     isn't needed. If it is \\c NULL, \\p peer_cid must be\n                     \\c NULL, too.\n\n \\note               This applies to the state of the CID negotiated in\n                     the last complete handshake. If a handshake is in\n                     progress, this function will attempt to complete\n                     the handshake first.\n\n \\note               If CID extensions have been exchanged but both client\n                     and server chose to use an empty CID, this function\n                     sets `*enabled` to #MBEDTLS_SSL_CID_DISABLED\n                     (the rationale for this is that the resulting\n                     communication is the same as if the CID extensions\n                     hadn't been used).\n\n \\return            \\c 0 on success.\n \\return            A negative error code on failure."]
    pub fn mbedtls_ssl_get_peer_cid(
        ssl: *mut mbedtls_ssl_context,
        enabled: *mut crate::c_types::c_int,
        peer_cid: *mut crate::c_types::c_uchar,
        peer_cid_len: *mut usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the Maximum Transport Unit (MTU).\n                 Special value: 0 means unset (no limit).\n                 This represents the maximum size of a datagram payload\n                 handled by the transport layer (usually UDP) as determined\n                 by the network link and stack. In practice, this controls\n                 the maximum size datagram the DTLS layer will pass to the\n                 \\c f_send() callback set using \\c mbedtls_ssl_set_bio().\n\n \\note           The limit on datagram size is converted to a limit on\n                 record payload by subtracting the current overhead of\n                 encapsulation and encryption/authentication if any.\n\n \\note           This can be called at any point during the connection, for\n                 example when a Path Maximum Transfer Unit (PMTU)\n                 estimate becomes available from other sources,\n                 such as lower (or higher) protocol layers.\n\n \\note           This setting only controls the size of the packets we send,\n                 and does not restrict the size of the datagrams we're\n                 willing to receive. Client-side, you can request the\n                 server to use smaller records with \\c\n                 mbedtls_ssl_conf_max_frag_len().\n\n \\note           If both a MTU and a maximum fragment length have been\n                 configured (or negotiated with the peer), the resulting\n                 lower limit on record payload (see first note) is used.\n\n \\note           This can only be used to decrease the maximum size\n                 of datagrams (hence records, see first note) sent. It\n                 cannot be used to increase the maximum size of records over\n                 the limit set by #MBEDTLS_SSL_OUT_CONTENT_LEN.\n\n \\note           Values lower than the current record layer expansion will\n                 result in an error when trying to send data.\n\n \\param ssl      SSL context\n \\param mtu      Value of the path MTU in bytes"]
    pub fn mbedtls_ssl_set_mtu(ssl: *mut mbedtls_ssl_context, mtu: u16);
}
extern "C" {
    #[doc = " \\brief          Set a connection-specific verification callback (optional).\n\n                 If set, the provided verify callback is called for each\n                 certificate in the peer's CRT chain, including the trusted\n                 root. For more information, please see the documentation of\n                 \\c mbedtls_x509_crt_verify().\n\n \\note           This call is analogous to mbedtls_ssl_conf_verify() but\n                 binds the verification callback and context to an SSL context\n                 as opposed to an SSL configuration.\n                 If mbedtls_ssl_conf_verify() and mbedtls_ssl_set_verify()\n                 are both used, mbedtls_ssl_set_verify() takes precedence.\n\n \\param ssl      The SSL context to use.\n \\param f_vrfy   The verification callback to use during CRT verification.\n \\param p_vrfy   The opaque context to be passed to the callback."]
    pub fn mbedtls_ssl_set_verify(
        ssl: *mut mbedtls_ssl_context,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut mbedtls_x509_crt,
                arg3: crate::c_types::c_int,
                arg4: *mut u32,
            ) -> crate::c_types::c_int,
        >,
        p_vrfy: *mut crate::c_types::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set the timeout period for mbedtls_ssl_read()\n                 (Default: no timeout.)\n\n \\param conf     SSL configuration context\n \\param timeout  Timeout value in milliseconds.\n                 Use 0 for no timeout (default).\n\n \\note           With blocking I/O, this will only work if a non-NULL\n                 \\c f_recv_timeout was set with \\c mbedtls_ssl_set_bio().\n                 With non-blocking I/O, this will only work if timer\n                 callbacks were set with \\c mbedtls_ssl_set_timer_cb().\n\n \\note           With non-blocking I/O, you may also skip this function\n                 altogether and handle timeouts at the application layer."]
    pub fn mbedtls_ssl_conf_read_timeout(conf: *mut mbedtls_ssl_config, timeout: u32);
}
extern "C" {
    #[doc = " \\brief          Check whether a buffer contains a valid and authentic record\n                 that has not been seen before. (DTLS only).\n\n                 This function does not change the user-visible state\n                 of the SSL context. Its sole purpose is to provide\n                 an indication of the legitimacy of an incoming record.\n\n                 This can be useful e.g. in distributed server environments\n                 using the DTLS Connection ID feature, in which connections\n                 might need to be passed between service instances on a change\n                 of peer address, but where such disruptive operations should\n                 only happen after the validity of incoming records has been\n                 confirmed.\n\n \\param ssl      The SSL context to use.\n \\param buf      The address of the buffer holding the record to be checked.\n                 This must be a read/write buffer of length \\p buflen Bytes.\n \\param buflen   The length of \\p buf in Bytes.\n\n \\note           This routine only checks whether the provided buffer begins\n                 with a valid and authentic record that has not been seen\n                 before, but does not check potential data following the\n                 initial record. In particular, it is possible to pass DTLS\n                 datagrams containing multiple records, in which case only\n                 the first record is checked.\n\n \\note           This function modifies the input buffer \\p buf. If you need\n                 to preserve the original record, you have to maintain a copy.\n\n \\return         \\c 0 if the record is valid and authentic and has not been\n                 seen before.\n \\return         MBEDTLS_ERR_SSL_INVALID_MAC if the check completed\n                 successfully but the record was found to be not authentic.\n \\return         MBEDTLS_ERR_SSL_INVALID_RECORD if the check completed\n                 successfully but the record was found to be invalid for\n                 a reason different from authenticity checking.\n \\return         MBEDTLS_ERR_SSL_UNEXPECTED_RECORD if the check completed\n                 successfully but the record was found to be unexpected\n                 in the state of the SSL context, including replayed records.\n \\return         Another negative error code on different kinds of failure.\n                 In this case, the SSL context becomes unusable and needs\n                 to be freed or reset before reuse."]
    pub fn mbedtls_ssl_check_record(
        ssl: *const mbedtls_ssl_context,
        buf: *mut crate::c_types::c_uchar,
        buflen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the timer callbacks (Mandatory for DTLS.)\n\n \\param ssl      SSL context\n \\param p_timer  parameter (context) shared by timer callbacks\n \\param f_set_timer   set timer callback\n \\param f_get_timer   get timer callback. Must return:\n\n \\note           See the documentation of \\c mbedtls_ssl_set_timer_t and\n                 \\c mbedtls_ssl_get_timer_t for the conventions this pair of\n                 callbacks must follow.\n\n \\note           On some platforms, timing.c provides\n                 \\c mbedtls_timing_set_delay() and\n                 \\c mbedtls_timing_get_delay() that are suitable for using\n                 here, except if using an event-driven style.\n\n \\note           See also the \"DTLS tutorial\" article in our knowledge base.\n                 https://mbed-tls.readthedocs.io/en/latest/kb/how-to/dtls-tutorial"]
    pub fn mbedtls_ssl_set_timer_cb(
        ssl: *mut mbedtls_ssl_context,
        p_timer: *mut crate::c_types::c_void,
        f_set_timer: mbedtls_ssl_set_timer_t,
        f_get_timer: mbedtls_ssl_get_timer_t,
    );
}
#[doc = " \\brief           Callback type: generate and write session ticket\n\n \\note            This describes what a callback implementation should do.\n                  This callback should generate an encrypted and\n                  authenticated ticket for the session and write it to the\n                  output buffer. Here, ticket means the opaque ticket part\n                  of the NewSessionTicket structure of RFC 5077.\n\n \\param p_ticket  Context for the callback\n \\param session   SSL session to be written in the ticket\n \\param start     Start of the output buffer\n \\param end       End of the output buffer\n \\param tlen      On exit, holds the length written\n \\param lifetime  On exit, holds the lifetime of the ticket in seconds\n\n \\return          0 if successful, or\n                  a specific MBEDTLS_ERR_XXX code."]
pub type mbedtls_ssl_ticket_write_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_ticket: *mut crate::c_types::c_void,
        session: *const mbedtls_ssl_session,
        start: *mut crate::c_types::c_uchar,
        end: *const crate::c_types::c_uchar,
        tlen: *mut usize,
        lifetime: *mut u32,
    ) -> crate::c_types::c_int,
>;
#[doc = " \\brief           Callback type: parse and load session ticket\n\n \\note            This describes what a callback implementation should do.\n                  This callback should parse a session ticket as generated\n                  by the corresponding mbedtls_ssl_ticket_write_t function,\n                  and, if the ticket is authentic and valid, load the\n                  session.\n\n \\note            The implementation is allowed to modify the first len\n                  bytes of the input buffer, eg to use it as a temporary\n                  area for the decrypted ticket contents.\n\n \\param p_ticket  Context for the callback\n \\param session   SSL session to be loaded\n \\param buf       Start of the buffer containing the ticket\n \\param len       Length of the ticket.\n\n \\return          0 if successful, or\n                  MBEDTLS_ERR_SSL_INVALID_MAC if not authentic, or\n                  MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED if expired, or\n                  any other non-zero code for other failures."]
pub type mbedtls_ssl_ticket_parse_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_ticket: *mut crate::c_types::c_void,
        session: *mut mbedtls_ssl_session,
        buf: *mut crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int,
>;
extern "C" {
    #[doc = " \\brief           Configure SSL session ticket callbacks (server only).\n                  (Default: none.)\n\n \\note            On server, session tickets are enabled by providing\n                  non-NULL callbacks.\n\n \\note            On client, use \\c mbedtls_ssl_conf_session_tickets().\n\n \\param conf      SSL configuration context\n \\param f_ticket_write    Callback for writing a ticket\n \\param f_ticket_parse    Callback for parsing a ticket\n \\param p_ticket          Context shared by the two callbacks"]
    pub fn mbedtls_ssl_conf_session_tickets_cb(
        conf: *mut mbedtls_ssl_config,
        f_ticket_write: mbedtls_ssl_ticket_write_t,
        f_ticket_parse: mbedtls_ssl_ticket_parse_t,
        p_ticket: *mut crate::c_types::c_void,
    );
}
extern "C" {
    #[doc = " \\brief   Configure a key export callback.\n          (Default: none.)\n\n          This API can be used for two purposes:\n          - Debugging: Use this API to e.g. generate an NSSKeylog\n            file and use it to inspect encrypted traffic in tools\n            such as Wireshark.\n          - Application-specific export: Use this API to implement\n            key exporters, e.g. for EAP-TLS or DTLS-SRTP.\n\n\n \\param ssl            The SSL context to which the export\n                       callback should be attached.\n \\param f_export_keys  The callback for the key export.\n \\param p_export_keys  The opaque context pointer to be passed to the\n                       callback \\p f_export_keys."]
    pub fn mbedtls_ssl_set_export_keys_cb(
        ssl: *mut mbedtls_ssl_context,
        f_export_keys: mbedtls_ssl_export_keys_t,
        p_export_keys: *mut crate::c_types::c_void,
    );
}
#[doc = " \\brief          Callback type: generate a cookie\n\n \\param ctx      Context for the callback\n \\param p        Buffer to write to,\n                 must be updated to point right after the cookie\n \\param end      Pointer to one past the end of the output buffer\n \\param info     Client ID info that was passed to\n                 \\c mbedtls_ssl_set_client_transport_id()\n \\param ilen     Length of info in bytes\n\n \\return         The callback must return 0 on success,\n                 or a negative error code."]
pub type mbedtls_ssl_cookie_write_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::c_types::c_void,
        p: *mut *mut crate::c_types::c_uchar,
        end: *mut crate::c_types::c_uchar,
        info: *const crate::c_types::c_uchar,
        ilen: usize,
    ) -> crate::c_types::c_int,
>;
#[doc = " \\brief          Callback type: verify a cookie\n\n \\param ctx      Context for the callback\n \\param cookie   Cookie to verify\n \\param clen     Length of cookie\n \\param info     Client ID info that was passed to\n                 \\c mbedtls_ssl_set_client_transport_id()\n \\param ilen     Length of info in bytes\n\n \\return         The callback must return 0 if cookie is valid,\n                 or a negative error code."]
pub type mbedtls_ssl_cookie_check_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut crate::c_types::c_void,
        cookie: *const crate::c_types::c_uchar,
        clen: usize,
        info: *const crate::c_types::c_uchar,
        ilen: usize,
    ) -> crate::c_types::c_int,
>;
extern "C" {
    #[doc = " \\brief           Register callbacks for DTLS cookies\n                  (Server only. DTLS only.)\n\n                  Default: dummy callbacks that fail, in order to force you to\n                  register working callbacks (and initialize their context).\n\n                  To disable HelloVerifyRequest, register NULL callbacks.\n\n \\warning         Disabling hello verification allows your server to be used\n                  for amplification in DoS attacks against other hosts.\n                  Only disable if you known this can't happen in your\n                  particular environment.\n\n \\note            See comments on \\c mbedtls_ssl_handshake() about handling\n                  the MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED that is expected\n                  on the first handshake attempt when this is enabled.\n\n \\note            This is also necessary to handle client reconnection from\n                  the same port as described in RFC 6347 section 4.2.8 (only\n                  the variant with cookies is supported currently). See\n                  comments on \\c mbedtls_ssl_read() for details.\n\n \\param conf              SSL configuration\n \\param f_cookie_write    Cookie write callback\n \\param f_cookie_check    Cookie check callback\n \\param p_cookie          Context for both callbacks"]
    pub fn mbedtls_ssl_conf_dtls_cookies(
        conf: *mut mbedtls_ssl_config,
        f_cookie_write: mbedtls_ssl_cookie_write_t,
        f_cookie_check: mbedtls_ssl_cookie_check_t,
        p_cookie: *mut crate::c_types::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set client's transport-level identification info.\n                 (Server only. DTLS only.)\n\n                 This is usually the IP address (and port), but could be\n                 anything identify the client depending on the underlying\n                 network stack. Used for HelloVerifyRequest with DTLS.\n                 This is *not* used to route the actual packets.\n\n \\param ssl      SSL context\n \\param info     Transport-level info identifying the client (eg IP + port)\n \\param ilen     Length of info in bytes\n\n \\note           An internal copy is made, so the info buffer can be reused.\n\n \\return         0 on success,\n                 MBEDTLS_ERR_SSL_BAD_INPUT_DATA if used on client,\n                 MBEDTLS_ERR_SSL_ALLOC_FAILED if out of memory."]
    pub fn mbedtls_ssl_set_client_transport_id(
        ssl: *mut mbedtls_ssl_context,
        info: *const crate::c_types::c_uchar,
        ilen: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Enable or disable anti-replay protection for DTLS.\n                 (DTLS only, no effect on TLS.)\n                 Default: enabled.\n\n \\param conf     SSL configuration\n \\param mode     MBEDTLS_SSL_ANTI_REPLAY_ENABLED or MBEDTLS_SSL_ANTI_REPLAY_DISABLED.\n\n \\warning        Disabling this is a security risk unless the application\n                 protocol handles duplicated packets in a safe way. You\n                 should not disable this without careful consideration.\n                 However, if your application already detects duplicated\n                 packets and needs information about them to adjust its\n                 transmission strategy, then you'll want to disable this."]
    pub fn mbedtls_ssl_conf_dtls_anti_replay(
        conf: *mut mbedtls_ssl_config,
        mode: crate::c_types::c_char,
    );
}
extern "C" {
    #[doc = " \\brief          Set a limit on the number of records with a bad MAC\n                 before terminating the connection.\n                 (DTLS only, no effect on TLS.)\n                 Default: 0 (disabled).\n\n \\param conf     SSL configuration\n \\param limit    Limit, or 0 to disable.\n\n \\note           If the limit is N, then the connection is terminated when\n                 the Nth non-authentic record is seen.\n\n \\note           Records with an invalid header are not counted, only the\n                 ones going through the authentication-decryption phase.\n\n \\note           This is a security trade-off related to the fact that it's\n                 often relatively easy for an active attacker to inject UDP\n                 datagrams. On one hand, setting a low limit here makes it\n                 easier for such an attacker to forcibly terminated a\n                 connection. On the other hand, a high limit or no limit\n                 might make us waste resources checking authentication on\n                 many bogus packets."]
    pub fn mbedtls_ssl_conf_dtls_badmac_limit(
        conf: *mut mbedtls_ssl_config,
        limit: crate::c_types::c_uint,
    );
}
extern "C" {
    #[doc = " \\brief          Allow or disallow packing of multiple handshake records\n                 within a single datagram.\n\n \\param ssl           The SSL context to configure.\n \\param allow_packing This determines whether datagram packing may\n                      be used or not. A value of \\c 0 means that every\n                      record will be sent in a separate datagram; a\n                      value of \\c 1 means that, if space permits,\n                      multiple handshake messages (including CCS) belonging to\n                      a single flight may be packed within a single datagram.\n\n \\note           This is enabled by default and should only be disabled\n                 for test purposes, or if datagram packing causes\n                 interoperability issues with peers that don't support it.\n\n \\note           Allowing datagram packing reduces the network load since\n                 there's less overhead if multiple messages share the same\n                 datagram. Also, it increases the handshake efficiency\n                 since messages belonging to a single datagram will not\n                 be reordered in transit, and so future message buffering\n                 or flight retransmission (if no buffering is used) as\n                 means to deal with reordering are needed less frequently.\n\n \\note           Application records are not affected by this option and\n                 are currently always sent in separate datagrams.\n"]
    pub fn mbedtls_ssl_set_datagram_packing(
        ssl: *mut mbedtls_ssl_context,
        allow_packing: crate::c_types::c_uint,
    );
}
extern "C" {
    #[doc = " \\brief          Set retransmit timeout values for the DTLS handshake.\n                 (DTLS only, no effect on TLS.)\n\n \\param conf     SSL configuration\n \\param min      Initial timeout value in milliseconds.\n                 Default: 1000 (1 second).\n \\param max      Maximum timeout value in milliseconds.\n                 Default: 60000 (60 seconds).\n\n \\note           Default values are from RFC 6347 section 4.2.4.1.\n\n \\note           The 'min' value should typically be slightly above the\n                 expected round-trip time to your peer, plus whatever time\n                 it takes for the peer to process the message. For example,\n                 if your RTT is about 600ms and you peer needs up to 1s to\n                 do the cryptographic operations in the handshake, then you\n                 should set 'min' slightly above 1600. Lower values of 'min'\n                 might cause spurious resends which waste network resources,\n                 while larger value of 'min' will increase overall latency\n                 on unreliable network links.\n\n \\note           The more unreliable your network connection is, the larger\n                 your max / min ratio needs to be in order to achieve\n                 reliable handshakes.\n\n \\note           Messages are retransmitted up to log2(ceil(max/min)) times.\n                 For example, if min = 1s and max = 5s, the retransmit plan\n                 goes: send ... 1s -> resend ... 2s -> resend ... 4s ->\n                 resend ... 5s -> give up and return a timeout error."]
    pub fn mbedtls_ssl_conf_handshake_timeout(conf: *mut mbedtls_ssl_config, min: u32, max: u32);
}
extern "C" {
    #[doc = " \\brief          Set the session cache callbacks (server-side only)\n                 If not set, no session resuming is done (except if session\n                 tickets are enabled too).\n\n                 The session cache has the responsibility to check for stale\n                 entries based on timeout. See RFC 5246 for recommendations.\n\n                 Warning: session.peer_cert is cleared by the SSL/TLS layer on\n                 connection shutdown, so do not cache the pointer! Either set\n                 it to NULL or make a full copy of the certificate.\n\n                 The get callback is called once during the initial handshake\n                 to enable session resuming. The get function has the\n                 following parameters: (void *parameter, mbedtls_ssl_session *session)\n                 If a valid entry is found, it should fill the master of\n                 the session object with the cached values and return 0,\n                 return 1 otherwise. Optionally peer_cert can be set as well\n                 if it is properly present in cache entry.\n\n                 The set callback is called once during the initial handshake\n                 to enable session resuming after the entire handshake has\n                 been finished. The set function has the following parameters:\n                 (void *parameter, const mbedtls_ssl_session *session). The function\n                 should create a cache entry for future retrieval based on\n                 the data in the session structure and should keep in mind\n                 that the mbedtls_ssl_session object presented (and all its referenced\n                 data) is cleared by the SSL/TLS layer when the connection is\n                 terminated. It is recommended to add metadata to determine if\n                 an entry is still valid in the future. Return 0 if\n                 successfully cached, return 1 otherwise.\n\n \\param conf           SSL configuration\n \\param p_cache        parameter (context) for both callbacks\n \\param f_get_cache    session get callback\n \\param f_set_cache    session set callback"]
    pub fn mbedtls_ssl_conf_session_cache(
        conf: *mut mbedtls_ssl_config,
        p_cache: *mut crate::c_types::c_void,
        f_get_cache: mbedtls_ssl_cache_get_t,
        f_set_cache: mbedtls_ssl_cache_set_t,
    );
}
extern "C" {
    #[doc = " \\brief          Load a session for session resumption.\n\n                 Sessions loaded through this call will be considered\n                 for session resumption in the next handshake.\n\n \\note           Even if this call succeeds, it is not guaranteed that\n                 the next handshake will indeed be shortened through the\n                 use of session resumption: The server is always free\n                 to reject any attempt for resumption and fall back to\n                 a full handshake.\n\n \\note           This function can handle a variety of mechanisms for session\n                 resumption: For TLS 1.2, both session ID-based resumption and\n                 ticket-based resumption will be considered. For TLS 1.3,\n                 once implemented, sessions equate to tickets, and loading\n                 one or more sessions via this call will lead to their\n                 corresponding tickets being advertised as resumption PSKs\n                 by the client.\n\n \\note           Calling this function multiple times will only be useful\n                 once TLS 1.3 is supported. For TLS 1.2 connections, this\n                 function should be called at most once.\n\n \\param ssl      The SSL context representing the connection which should\n                 be attempted to be setup using session resumption. This\n                 must be initialized via mbedtls_ssl_init() and bound to\n                 an SSL configuration via mbedtls_ssl_setup(), but\n                 the handshake must not yet have been started.\n \\param session  The session to be considered for session resumption.\n                 This must be a session previously exported via\n                 mbedtls_ssl_get_session(), and potentially serialized and\n                 deserialized through mbedtls_ssl_session_save() and\n                 mbedtls_ssl_session_load() in the meantime.\n\n \\return         \\c 0 if successful.\n \\return         \\c MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE if the session\n                 could not be loaded because of an implementation limitation.\n                 This error is non-fatal, and has no observable effect on\n                 the SSL context or the session that was attempted to be loaded.\n \\return         Another negative error code on other kinds of failure.\n\n \\sa             mbedtls_ssl_get_session()\n \\sa             mbedtls_ssl_session_load()"]
    pub fn mbedtls_ssl_set_session(
        ssl: *mut mbedtls_ssl_context,
        session: *const mbedtls_ssl_session,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Load serialized session data into a session structure.\n                 On client, this can be used for loading saved sessions\n                 before resuming them with mbedtls_ssl_set_session().\n                 On server, this can be used for alternative implementations\n                 of session cache or session tickets.\n\n \\warning        If a peer certificate chain is associated with the session,\n                 the serialized state will only contain the peer's\n                 end-entity certificate and the result of the chain\n                 verification (unless verification was disabled), but not\n                 the rest of the chain.\n\n \\see            mbedtls_ssl_session_save()\n \\see            mbedtls_ssl_set_session()\n\n \\param session  The session structure to be populated. It must have been\n                 initialised with mbedtls_ssl_session_init() but not\n                 populated yet.\n \\param buf      The buffer holding the serialized session data. It must be a\n                 readable buffer of at least \\p len bytes.\n \\param len      The size of the serialized data in bytes.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_SSL_ALLOC_FAILED if memory allocation failed.\n \\return         #MBEDTLS_ERR_SSL_BAD_INPUT_DATA if input data is invalid.\n \\return         #MBEDTLS_ERR_SSL_VERSION_MISMATCH if the serialized data\n                 was generated in a different version or configuration of\n                 Mbed TLS.\n \\return         Another negative value for other kinds of errors (for\n                 example, unsupported features in the embedded certificate)."]
    pub fn mbedtls_ssl_session_load(
        session: *mut mbedtls_ssl_session,
        buf: *const crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Save session structure as serialized data in a buffer.\n                 On client, this can be used for saving session data,\n                 potentially in non-volatile storage, for resuming later.\n                 On server, this can be used for alternative implementations\n                 of session cache or session tickets.\n\n \\see            mbedtls_ssl_session_load()\n\n \\param session  The session structure to be saved.\n \\param buf      The buffer to write the serialized data to. It must be a\n                 writeable buffer of at least \\p len bytes, or may be \\c\n                 NULL if \\p len is \\c 0.\n \\param buf_len  The number of bytes available for writing in \\p buf.\n \\param olen     The size in bytes of the data that has been or would have\n                 been written. It must point to a valid \\c size_t.\n\n \\note           \\p olen is updated to the correct value regardless of\n                 whether \\p buf_len was large enough. This makes it possible\n                 to determine the necessary size by calling this function\n                 with \\p buf set to \\c NULL and \\p buf_len to \\c 0.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL if \\p buf is too small."]
    pub fn mbedtls_ssl_session_save(
        session: *const mbedtls_ssl_session,
        buf: *mut crate::c_types::c_uchar,
        buf_len: usize,
        olen: *mut usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               Set the list of allowed ciphersuites and the preference\n                      order. First in the list has the highest preference.\n\n                      For TLS 1.2, the notion of ciphersuite determines both\n                      the key exchange mechanism and the suite of symmetric\n                      algorithms to be used during and after the handshake.\n\n                      For TLS 1.3 (in development), the notion of ciphersuite\n                      only determines the suite of symmetric algorithms to be\n                      used during and after the handshake, while key exchange\n                      mechanisms are configured separately.\n\n                      In Mbed TLS, ciphersuites for both TLS 1.2 and TLS 1.3\n                      are configured via this function. For users of TLS 1.3,\n                      there will be separate API for the configuration of key\n                      exchange mechanisms.\n\n                      The list of ciphersuites passed to this function may\n                      contain a mixture of TLS 1.2 and TLS 1.3 ciphersuite\n                      identifiers. This is useful if negotiation of TLS 1.3\n                      should be attempted, but a fallback to TLS 1.2 would\n                      be tolerated.\n\n \\note                By default, the server chooses its preferred\n                      ciphersuite among those that the client supports. If\n                      mbedtls_ssl_conf_preference_order() is called to prefer\n                      the client's preferences, the server instead chooses\n                      the client's preferred ciphersuite among those that\n                      the server supports.\n\n \\warning             The ciphersuites array \\p ciphersuites is not copied.\n                      It must remain valid for the lifetime of the SSL\n                      configuration \\p conf.\n\n \\param conf          The SSL configuration to modify.\n \\param ciphersuites  A 0-terminated list of IANA identifiers of supported\n                      ciphersuites, accessible through \\c MBEDTLS_TLS_XXX\n                      and \\c MBEDTLS_TLS1_3_XXX macros defined in\n                      ssl_ciphersuites.h."]
    pub fn mbedtls_ssl_conf_ciphersuites(
        conf: *mut mbedtls_ssl_config,
        ciphersuites: *const crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief Set the supported key exchange modes for TLS 1.3 connections.\n\n        In contrast to TLS 1.2, the ciphersuite concept in TLS 1.3 does not\n        include the choice of key exchange mechanism. It is therefore not\n        covered by the API mbedtls_ssl_conf_ciphersuites(). See the\n        documentation of mbedtls_ssl_conf_ciphersuites() for more\n        information on the ciphersuite concept in TLS 1.2 and TLS 1.3.\n\n        The present function is specific to TLS 1.3 and allows users to\n        configure the set of supported key exchange mechanisms in TLS 1.3.\n\n \\param conf       The SSL configuration the change should apply to.\n \\param kex_modes  A bitwise combination of one or more of the following:\n                   - MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK\n                     This flag enables pure-PSK key exchanges.\n                   - MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK_EPHEMERAL\n                     This flag enables combined PSK-ephemeral key exchanges.\n                   - MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_EPHEMERAL\n                     This flag enables pure-ephemeral key exchanges.\n                   For convenience, the following pre-defined macros are\n                   available for combinations of the above:\n                   - MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_ALL\n                     Includes all of pure-PSK, PSK-ephemeral and pure-ephemeral.\n                   - MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_PSK_ALL\n                     Includes both pure-PSK and combined PSK-ephemeral\n                     key exchanges, but excludes pure-ephemeral key exchanges.\n                   - MBEDTLS_SSL_TLS1_3_KEY_EXCHANGE_MODE_EPHEMERAL_ALL\n                     Includes both pure-ephemeral and combined PSK-ephemeral\n                     key exchanges.\n\n \\note  If a PSK-based key exchange mode shall be supported, applications\n        must also use the APIs mbedtls_ssl_conf_psk() or\n        mbedtls_ssl_conf_psk_cb() or mbedtls_ssl_conf_psk_opaque()\n        to configure the PSKs to be used.\n\n \\note  If a pure-ephemeral key exchange mode shall be supported,\n        server-side applications must also provide a certificate via\n        mbedtls_ssl_conf_own_cert().\n"]
    pub fn mbedtls_ssl_conf_tls13_key_exchange_modes(
        conf: *mut mbedtls_ssl_config,
        kex_modes: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief               Specify the length of Connection IDs for incoming\n                      encrypted DTLS records, as well as the behaviour\n                      on unexpected CIDs.\n\n                      By default, the CID length is set to \\c 0,\n                      and unexpected CIDs are silently ignored.\n\n \\param conf          The SSL configuration to modify.\n \\param len           The length in Bytes of the CID fields in encrypted\n                      DTLS records using the CID mechanism. This must\n                      not be larger than #MBEDTLS_SSL_CID_OUT_LEN_MAX.\n \\param ignore_other_cids This determines the stack's behaviour when\n                          receiving a record with an unexpected CID.\n                          Possible values are:\n                          - #MBEDTLS_SSL_UNEXPECTED_CID_IGNORE\n                            In this case, the record is silently ignored.\n                          - #MBEDTLS_SSL_UNEXPECTED_CID_FAIL\n                            In this case, the stack fails with the specific\n                            error code #MBEDTLS_ERR_SSL_UNEXPECTED_CID.\n\n \\note                The CID specification allows implementations to either\n                      use a common length for all incoming connection IDs or\n                      allow variable-length incoming IDs. Mbed TLS currently\n                      requires a common length for all connections sharing the\n                      same SSL configuration; this allows simpler parsing of\n                      record headers.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_SSL_BAD_INPUT_DATA if \\p own_cid_len\n                      is too large."]
    pub fn mbedtls_ssl_conf_cid(
        conf: *mut mbedtls_ssl_config,
        len: usize,
        ignore_other_cids: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the X.509 security profile used for verification\n\n \\note           The restrictions are enforced for all certificates in the\n                 chain. However, signatures in the handshake are not covered\n                 by this setting but by \\b mbedtls_ssl_conf_sig_hashes().\n\n \\param conf     SSL configuration\n \\param profile  Profile to use"]
    pub fn mbedtls_ssl_conf_cert_profile(
        conf: *mut mbedtls_ssl_config,
        profile: *const mbedtls_x509_crt_profile,
    );
}
extern "C" {
    #[doc = " \\brief          Set the data required to verify peer certificate\n\n \\note           See \\c mbedtls_x509_crt_verify() for notes regarding the\n                 parameters ca_chain (maps to trust_ca for that function)\n                 and ca_crl.\n\n \\param conf     SSL configuration\n \\param ca_chain trusted CA chain (meaning all fully trusted top-level CAs)\n \\param ca_crl   trusted CA CRLs"]
    pub fn mbedtls_ssl_conf_ca_chain(
        conf: *mut mbedtls_ssl_config,
        ca_chain: *mut mbedtls_x509_crt,
        ca_crl: *mut mbedtls_x509_crl,
    );
}
extern "C" {
    #[doc = " \\brief          Set own certificate chain and private key\n\n \\note           own_cert should contain in order from the bottom up your\n                 certificate chain. The top certificate (self-signed)\n                 can be omitted.\n\n \\note           On server, this function can be called multiple times to\n                 provision more than one cert/key pair (eg one ECDSA, one\n                 RSA with SHA-256, one RSA with SHA-1). An adequate\n                 certificate will be selected according to the client's\n                 advertised capabilities. In case multiple certificates are\n                 adequate, preference is given to the one set by the first\n                 call to this function, then second, etc.\n\n \\note           On client, only the first call has any effect. That is,\n                 only one client certificate can be provisioned. The\n                 server's preferences in its CertificateRequest message will\n                 be ignored and our only cert will be sent regardless of\n                 whether it matches those preferences - the server can then\n                 decide what it wants to do with it.\n\n \\note           The provided \\p pk_key needs to match the public key in the\n                 first certificate in \\p own_cert, or all handshakes using\n                 that certificate will fail. It is your responsibility\n                 to ensure that; this function will not perform any check.\n                 You may use mbedtls_pk_check_pair() in order to perform\n                 this check yourself, but be aware that this function can\n                 be computationally expensive on some key types.\n\n \\param conf     SSL configuration\n \\param own_cert own public certificate chain\n \\param pk_key   own private key\n\n \\return         0 on success or MBEDTLS_ERR_SSL_ALLOC_FAILED"]
    pub fn mbedtls_ssl_conf_own_cert(
        conf: *mut mbedtls_ssl_config,
        own_cert: *mut mbedtls_x509_crt,
        pk_key: *mut mbedtls_pk_context,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Configure pre-shared keys (PSKs) and their\n                 identities to be used in PSK-based ciphersuites.\n\n                 Only one PSK can be registered, through either\n                 mbedtls_ssl_conf_psk() or mbedtls_ssl_conf_psk_opaque().\n                 If you attempt to register more than one PSK, this function\n                 fails, though this may change in future versions, which\n                 may add support for multiple PSKs.\n\n \\note           This is mainly useful for clients. Servers will usually\n                 want to use \\c mbedtls_ssl_conf_psk_cb() instead.\n\n \\note           A PSK set by \\c mbedtls_ssl_set_hs_psk() in the PSK callback\n                 takes precedence over a PSK configured by this function.\n\n \\param conf     The SSL configuration to register the PSK with.\n \\param psk      The pointer to the pre-shared key to use.\n \\param psk_len  The length of the pre-shared key in bytes.\n \\param psk_identity      The pointer to the pre-shared key identity.\n \\param psk_identity_len  The length of the pre-shared key identity\n                          in bytes.\n\n \\note           The PSK and its identity are copied internally and\n                 hence need not be preserved by the caller for the lifetime\n                 of the SSL configuration.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE if no more PSKs\n                 can be configured. In this case, the old PSK(s) remain intact.\n \\return         Another negative error code on other kinds of failure."]
    pub fn mbedtls_ssl_conf_psk(
        conf: *mut mbedtls_ssl_config,
        psk: *const crate::c_types::c_uchar,
        psk_len: usize,
        psk_identity: *const crate::c_types::c_uchar,
        psk_identity_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the pre-shared Key (PSK) for the current handshake.\n\n \\note           This should only be called inside the PSK callback,\n                 i.e. the function passed to \\c mbedtls_ssl_conf_psk_cb().\n\n \\note           A PSK set by this function takes precedence over a PSK\n                 configured by \\c mbedtls_ssl_conf_psk().\n\n \\param ssl      The SSL context to configure a PSK for.\n \\param psk      The pointer to the pre-shared key.\n \\param psk_len  The length of the pre-shared key in bytes.\n\n \\return         \\c 0 if successful.\n \\return         An \\c MBEDTLS_ERR_SSL_XXX error code on failure."]
    pub fn mbedtls_ssl_set_hs_psk(
        ssl: *mut mbedtls_ssl_context,
        psk: *const crate::c_types::c_uchar,
        psk_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the PSK callback (server-side only).\n\n                 If set, the PSK callback is called for each\n                 handshake where a PSK-based ciphersuite was negotiated.\n                 The caller provides the identity received and wants to\n                 receive the actual PSK data and length.\n\n                 The callback has the following parameters:\n                 - \\c void*: The opaque pointer \\p p_psk.\n                 - \\c mbedtls_ssl_context*: The SSL context to which\n                                            the operation applies.\n                 - \\c const unsigned char*: The PSK identity\n                                            selected by the client.\n                 - \\c size_t: The length of the PSK identity\n                              selected by the client.\n\n                 If a valid PSK identity is found, the callback should use\n                 \\c mbedtls_ssl_set_hs_psk() or\n                 \\c mbedtls_ssl_set_hs_psk_opaque()\n                 on the SSL context to set the correct PSK and return \\c 0.\n                 Any other return value will result in a denied PSK identity.\n\n \\note           A dynamic PSK (i.e. set by the PSK callback) takes\n                 precedence over a static PSK (i.e. set by\n                 \\c mbedtls_ssl_conf_psk() or\n                 \\c mbedtls_ssl_conf_psk_opaque()).\n                 This means that if you set a PSK callback using this\n                 function, you don't need to set a PSK using\n                 \\c mbedtls_ssl_conf_psk() or\n                 \\c mbedtls_ssl_conf_psk_opaque()).\n\n \\param conf     The SSL configuration to register the callback with.\n \\param f_psk    The callback for selecting and setting the PSK based\n                 in the PSK identity chosen by the client.\n \\param p_psk    A pointer to an opaque structure to be passed to\n                 the callback, for example a PSK store."]
    pub fn mbedtls_ssl_conf_psk_cb(
        conf: *mut mbedtls_ssl_config,
        f_psk: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut mbedtls_ssl_context,
                arg3: *const crate::c_types::c_uchar,
                arg4: usize,
            ) -> crate::c_types::c_int,
        >,
        p_psk: *mut crate::c_types::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set the Diffie-Hellman public P and G values\n                 from big-endian binary presentations.\n                 (Default values: MBEDTLS_DHM_RFC3526_MODP_2048_[PG]_BIN)\n\n \\param conf     SSL configuration\n \\param dhm_P    Diffie-Hellman-Merkle modulus in big-endian binary form\n \\param P_len    Length of DHM modulus\n \\param dhm_G    Diffie-Hellman-Merkle generator in big-endian binary form\n \\param G_len    Length of DHM generator\n\n \\return         0 if successful"]
    pub fn mbedtls_ssl_conf_dh_param_bin(
        conf: *mut mbedtls_ssl_config,
        dhm_P: *const crate::c_types::c_uchar,
        P_len: usize,
        dhm_G: *const crate::c_types::c_uchar,
        G_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the Diffie-Hellman public P and G values,\n                 read from existing context (server-side only)\n\n \\param conf     SSL configuration\n \\param dhm_ctx  Diffie-Hellman-Merkle context\n\n \\return         0 if successful"]
    pub fn mbedtls_ssl_conf_dh_param_ctx(
        conf: *mut mbedtls_ssl_config,
        dhm_ctx: *mut mbedtls_dhm_context,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the minimum length for Diffie-Hellman parameters.\n                 (Client-side only.)\n                 (Default: 1024 bits.)\n\n \\param conf     SSL configuration\n \\param bitlen   Minimum bit length of the DHM prime"]
    pub fn mbedtls_ssl_conf_dhm_min_bitlen(
        conf: *mut mbedtls_ssl_config,
        bitlen: crate::c_types::c_uint,
    );
}
extern "C" {
    #[doc = " \\brief          Set the allowed curves in order of preference.\n\n                 On server: this only affects selection of the ECDHE curve;\n                 the curves used for ECDH and ECDSA are determined by the\n                 list of available certificates instead.\n\n                 On client: this affects the list of curves offered for any\n                 use. The server can override our preference order.\n\n                 Both sides: limits the set of curves accepted for use in\n                 ECDHE and in the peer's end-entity certificate.\n\n \\deprecated     Superseded by mbedtls_ssl_conf_groups().\n\n \\note           This has no influence on which curves are allowed inside the\n                 certificate chains, see \\c mbedtls_ssl_conf_cert_profile()\n                 for that. For the end-entity certificate however, the key\n                 will be accepted only if it is allowed both by this list\n                 and by the cert profile.\n\n \\note           This list should be ordered by decreasing preference\n                 (preferred curve first).\n\n \\note           The default list is the same set of curves that\n                 #mbedtls_x509_crt_profile_default allows, plus\n                 ECDHE-only curves selected according to the same criteria.\n                 The order favors curves with the lowest resource usage.\n\n \\note           New minor versions of Mbed TLS may extend this list,\n                 for example if new curves are added to the library.\n                 New minor versions of Mbed TLS will not remove items\n                 from this list unless serious security concerns require it.\n                 New minor versions of Mbed TLS may change the order in\n                 keeping with the general principle of favoring the lowest\n                 resource usage.\n\n \\param conf     SSL configuration\n \\param curves   Ordered list of allowed curves,\n                 terminated by MBEDTLS_ECP_DP_NONE."]
    pub fn mbedtls_ssl_conf_curves(
        conf: *mut mbedtls_ssl_config,
        curves: *const mbedtls_ecp_group_id,
    );
}
extern "C" {
    #[doc = " \\brief          Set the allowed groups in order of preference.\n\n                 On server: This only affects the choice of key agreement mechanism\n\n                 On client: this affects the list of groups offered for any\n                 use. The server can override our preference order.\n\n                 Both sides: limits the set of groups accepted for use in\n                 key sharing.\n\n \\note           This function replaces the deprecated mbedtls_ssl_conf_curves(),\n                 which only allows ECP curves to be configured.\n\n \\note           The most recent invocation of either mbedtls_ssl_conf_curves()\n                 or mbedtls_ssl_conf_groups() nullifies all previous invocations\n                 of both.\n\n \\note           This list should be ordered by decreasing preference\n                 (preferred group first).\n\n \\note           When this function is not called, a default list is used,\n                 consisting of all supported curves at 255 bits and above,\n                 and all supported finite fields at 2048 bits and above.\n                 The order favors groups with the lowest resource usage.\n\n \\note           New minor versions of Mbed TLS will not remove items\n                 from the default list unless serious security concerns require it.\n                 New minor versions of Mbed TLS may change the order in\n                 keeping with the general principle of favoring the lowest\n                 resource usage.\n\n \\param conf     SSL configuration\n \\param groups   List of allowed groups ordered by preference, terminated by 0.\n                 Must contain valid IANA NamedGroup IDs (provided via either an integer\n                 or using MBEDTLS_TLS1_3_NAMED_GROUP_XXX macros)."]
    pub fn mbedtls_ssl_conf_groups(conf: *mut mbedtls_ssl_config, groups: *const u16);
}
extern "C" {
    #[doc = " \\brief          Set the allowed hashes for signatures during the handshake.\n\n \\note           This only affects which hashes are offered and can be used\n                 for signatures during the handshake. Hashes for message\n                 authentication and the TLS PRF are controlled by the\n                 ciphersuite, see \\c mbedtls_ssl_conf_ciphersuites(). Hashes\n                 used for certificate signature are controlled by the\n                 verification profile, see \\c mbedtls_ssl_conf_cert_profile().\n\n \\note           This list should be ordered by decreasing preference\n                 (preferred hash first).\n\n \\note           By default, all supported hashes whose length is at least\n                 256 bits are allowed. This is the same set as the default\n                 for certificate verification\n                 (#mbedtls_x509_crt_profile_default).\n                 The preference order is currently unspecified and may\n                 change in future versions.\n\n \\note           New minor versions of Mbed TLS may extend this list,\n                 for example if new curves are added to the library.\n                 New minor versions of Mbed TLS will not remove items\n                 from this list unless serious security concerns require it.\n\n \\param conf     SSL configuration\n \\param hashes   Ordered list of allowed signature hashes,\n                 terminated by \\c MBEDTLS_MD_NONE."]
    pub fn mbedtls_ssl_conf_sig_hashes(
        conf: *mut mbedtls_ssl_config,
        hashes: *const crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          Configure allowed signature algorithms for use in TLS 1.3\n\n \\param conf     The SSL configuration to use.\n \\param sig_algs List of allowed IANA values for TLS 1.3 signature algorithms,\n                 terminated by \\c MBEDTLS_TLS1_3_SIG_NONE. The list must remain\n                 available throughout the lifetime of the conf object. Supported\n                 values are available as \\c MBEDTLS_TLS1_3_SIG_XXXX"]
    pub fn mbedtls_ssl_conf_sig_algs(conf: *mut mbedtls_ssl_config, sig_algs: *const u16);
}
extern "C" {
    #[doc = " \\brief          Set or reset the hostname to check against the received\n                 server certificate. It sets the ServerName TLS extension,\n                 too, if that extension is enabled. (client-side only)\n\n \\param ssl      SSL context\n \\param hostname the server hostname, may be NULL to clear hostname\n\n \\note           Maximum hostname length MBEDTLS_SSL_MAX_HOST_NAME_LEN.\n\n \\return         0 if successful, MBEDTLS_ERR_SSL_ALLOC_FAILED on\n                 allocation failure, MBEDTLS_ERR_SSL_BAD_INPUT_DATA on\n                 too long input hostname.\n\n                 Hostname set to the one provided on success (cleared\n                 when NULL). On allocation failure hostname is cleared.\n                 On too long input failure, old hostname is unchanged."]
    pub fn mbedtls_ssl_set_hostname(
        ssl: *mut mbedtls_ssl_context,
        hostname: *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Retrieve SNI extension value for the current handshake.\n                 Available in \\p f_cert_cb of \\c mbedtls_ssl_conf_cert_cb(),\n                 this is the same value passed to \\p f_sni callback of\n                 \\c mbedtls_ssl_conf_sni() and may be used instead of\n                 \\c mbedtls_ssl_conf_sni().\n\n \\param ssl      SSL context\n \\param name_len pointer into which to store length of returned value.\n                 0 if SNI extension is not present or not yet processed.\n\n \\return         const pointer to SNI extension value.\n                 - value is valid only when called in \\p f_cert_cb\n                   registered with \\c mbedtls_ssl_conf_cert_cb().\n                 - value is NULL if SNI extension is not present.\n                 - value is not '\\0'-terminated.  Use \\c name_len for len.\n                 - value must not be freed."]
    pub fn mbedtls_ssl_get_hs_sni(
        ssl: *mut mbedtls_ssl_context,
        name_len: *mut usize,
    ) -> *const crate::c_types::c_uchar;
}
extern "C" {
    #[doc = " \\brief          Set own certificate and key for the current handshake\n\n \\note           Same as \\c mbedtls_ssl_conf_own_cert() but for use within\n                 the SNI callback or the certificate selection callback.\n\n \\note           Passing null \\c own_cert clears the certificate list for\n                 the current handshake.\n\n \\param ssl      SSL context\n \\param own_cert own public certificate chain\n \\param pk_key   own private key\n\n \\return         0 on success or MBEDTLS_ERR_SSL_ALLOC_FAILED"]
    pub fn mbedtls_ssl_set_hs_own_cert(
        ssl: *mut mbedtls_ssl_context,
        own_cert: *mut mbedtls_x509_crt,
        pk_key: *mut mbedtls_pk_context,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Set the data required to verify peer certificate for the\n                 current handshake\n\n \\note           Same as \\c mbedtls_ssl_conf_ca_chain() but for use within\n                 the SNI callback or the certificate selection callback.\n\n \\param ssl      SSL context\n \\param ca_chain trusted CA chain (meaning all fully trusted top-level CAs)\n \\param ca_crl   trusted CA CRLs"]
    pub fn mbedtls_ssl_set_hs_ca_chain(
        ssl: *mut mbedtls_ssl_context,
        ca_chain: *mut mbedtls_x509_crt,
        ca_crl: *mut mbedtls_x509_crl,
    );
}
extern "C" {
    #[doc = " \\brief          Set DN hints sent to client in CertificateRequest message\n\n \\note           Same as \\c mbedtls_ssl_conf_dn_hints() but for use within\n                 the SNI callback or the certificate selection callback.\n\n \\param ssl      SSL context\n \\param crt      crt chain whose subject DNs are issuer DNs of client certs\n                 from which the client should select client peer certificate."]
    pub fn mbedtls_ssl_set_hs_dn_hints(ssl: *mut mbedtls_ssl_context, crt: *const mbedtls_x509_crt);
}
extern "C" {
    #[doc = " \\brief          Set authmode for the current handshake.\n\n \\note           Same as \\c mbedtls_ssl_conf_authmode() but for use within\n                 the SNI callback or the certificate selection callback.\n\n \\param ssl      SSL context\n \\param authmode MBEDTLS_SSL_VERIFY_NONE, MBEDTLS_SSL_VERIFY_OPTIONAL or\n                 MBEDTLS_SSL_VERIFY_REQUIRED"]
    pub fn mbedtls_ssl_set_hs_authmode(
        ssl: *mut mbedtls_ssl_context,
        authmode: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          Set server side ServerName TLS extension callback\n                 (optional, server-side only).\n\n                 If set, the ServerName callback is called whenever the\n                 server receives a ServerName TLS extension from the client\n                 during a handshake. The ServerName callback has the\n                 following parameters: (void *parameter, mbedtls_ssl_context *ssl,\n                 const unsigned char *hostname, size_t len). If a suitable\n                 certificate is found, the callback must set the\n                 certificate(s) and key(s) to use with \\c\n                 mbedtls_ssl_set_hs_own_cert() (can be called repeatedly),\n                 and may optionally adjust the CA and associated CRL with \\c\n                 mbedtls_ssl_set_hs_ca_chain() as well as the client\n                 authentication mode with \\c mbedtls_ssl_set_hs_authmode(),\n                 then must return 0. If no matching name is found, the\n                 callback may return non-zero to abort the handshake.\n\n \\param conf     SSL configuration\n \\param f_sni    verification function\n \\param p_sni    verification parameter"]
    pub fn mbedtls_ssl_conf_sni(
        conf: *mut mbedtls_ssl_config,
        f_sni: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut mbedtls_ssl_context,
                arg3: *const crate::c_types::c_uchar,
                arg4: usize,
            ) -> crate::c_types::c_int,
        >,
        p_sni: *mut crate::c_types::c_void,
    );
}
extern "C" {
    #[doc = " \\brief          Set the supported Application Layer Protocols.\n\n \\param conf     SSL configuration\n \\param protos   Pointer to a NULL-terminated list of supported protocols,\n                 in decreasing preference order. The pointer to the list is\n                 recorded by the library for later reference as required, so\n                 the lifetime of the table must be at least as long as the\n                 lifetime of the SSL configuration structure.\n\n \\return         0 on success, or MBEDTLS_ERR_SSL_BAD_INPUT_DATA."]
    pub fn mbedtls_ssl_conf_alpn_protocols(
        conf: *mut mbedtls_ssl_config,
        protos: *mut *const crate::c_types::c_char,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Get the name of the negotiated Application Layer Protocol.\n                 This function should be called after the handshake is\n                 completed.\n\n \\param ssl      SSL context\n\n \\return         Protocol name, or NULL if no protocol was negotiated."]
    pub fn mbedtls_ssl_get_alpn_protocol(
        ssl: *const mbedtls_ssl_context,
    ) -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " \\brief          Set the maximum supported version sent from the client side\n                 and/or accepted at the server side.\n\n                 See also the documentation of mbedtls_ssl_conf_min_version().\n\n \\note           This ignores ciphersuites from higher versions.\n\n \\note           This function is deprecated and has been replaced by\n                 \\c mbedtls_ssl_conf_max_tls_version().\n\n \\param conf     SSL configuration\n \\param major    Major version number (#MBEDTLS_SSL_MAJOR_VERSION_3)\n \\param minor    Minor version number\n                 (#MBEDTLS_SSL_MINOR_VERSION_3 for (D)TLS 1.2,\n                 #MBEDTLS_SSL_MINOR_VERSION_4 for TLS 1.3)"]
    pub fn mbedtls_ssl_conf_max_version(
        conf: *mut mbedtls_ssl_config,
        major: crate::c_types::c_int,
        minor: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          Set the minimum accepted SSL/TLS protocol version\n\n \\note           By default, all supported versions are accepted.\n                 Future versions of the library may disable older\n                 protocol versions by default if they become deprecated.\n\n \\note           The following versions are supported (if enabled at\n                 compile time):\n                 - (D)TLS 1.2: \\p major = #MBEDTLS_SSL_MAJOR_VERSION_3,\n                   \\p minor = #MBEDTLS_SSL_MINOR_VERSION_3\n                 - TLS 1.3: \\p major = #MBEDTLS_SSL_MAJOR_VERSION_3,\n                   \\p minor = #MBEDTLS_SSL_MINOR_VERSION_4\n\n                 Note that the numbers in the constant names are the\n                 TLS internal protocol numbers, and the minor versions\n                 differ by one from the human-readable versions!\n\n \\note           Input outside of the SSL_MAX_XXXXX_VERSION and\n                 SSL_MIN_XXXXX_VERSION range is ignored.\n\n \\note           After the handshake, you can call\n                 mbedtls_ssl_get_version_number() to see what version was\n                 negotiated.\n\n \\note           This function is deprecated and has been replaced by\n                 \\c mbedtls_ssl_conf_min_tls_version().\n\n \\param conf     SSL configuration\n \\param major    Major version number (#MBEDTLS_SSL_MAJOR_VERSION_3)\n \\param minor    Minor version number\n                 (#MBEDTLS_SSL_MINOR_VERSION_3 for (D)TLS 1.2,\n                 #MBEDTLS_SSL_MINOR_VERSION_4 for TLS 1.3)"]
    pub fn mbedtls_ssl_conf_min_version(
        conf: *mut mbedtls_ssl_config,
        major: crate::c_types::c_int,
        minor: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief           Enable or disable Encrypt-then-MAC\n                  (Default: MBEDTLS_SSL_ETM_ENABLED)\n\n \\note            This should always be enabled, it is a security\n                  improvement, and should not cause any interoperability\n                  issue (used only if the peer supports it too).\n\n \\param conf      SSL configuration\n \\param etm       MBEDTLS_SSL_ETM_ENABLED or MBEDTLS_SSL_ETM_DISABLED"]
    pub fn mbedtls_ssl_conf_encrypt_then_mac(
        conf: *mut mbedtls_ssl_config,
        etm: crate::c_types::c_char,
    );
}
extern "C" {
    #[doc = " \\brief           Enable or disable Extended Master Secret negotiation.\n                  (Default: MBEDTLS_SSL_EXTENDED_MS_ENABLED)\n\n \\note            This should always be enabled, it is a security fix to the\n                  protocol, and should not cause any interoperability issue\n                  (used only if the peer supports it too).\n\n \\param conf      SSL configuration\n \\param ems       MBEDTLS_SSL_EXTENDED_MS_ENABLED or MBEDTLS_SSL_EXTENDED_MS_DISABLED"]
    pub fn mbedtls_ssl_conf_extended_master_secret(
        conf: *mut mbedtls_ssl_config,
        ems: crate::c_types::c_char,
    );
}
extern "C" {
    #[doc = " \\brief          Whether to send a list of acceptable CAs in\n                 CertificateRequest messages.\n                 (Default: do send)\n\n \\param conf     SSL configuration\n \\param cert_req_ca_list   MBEDTLS_SSL_CERT_REQ_CA_LIST_ENABLED or\n                          MBEDTLS_SSL_CERT_REQ_CA_LIST_DISABLED"]
    pub fn mbedtls_ssl_conf_cert_req_ca_list(
        conf: *mut mbedtls_ssl_config,
        cert_req_ca_list: crate::c_types::c_char,
    );
}
extern "C" {
    #[doc = " \\brief          Set the maximum fragment length to emit and/or negotiate.\n                 (Typical: the smaller of #MBEDTLS_SSL_IN_CONTENT_LEN and\n                 #MBEDTLS_SSL_OUT_CONTENT_LEN, usually `2^14` bytes)\n                 (Server: set maximum fragment length to emit,\n                 usually negotiated by the client during handshake)\n                 (Client: set maximum fragment length to emit *and*\n                 negotiate with the server during handshake)\n                 (Default: #MBEDTLS_SSL_MAX_FRAG_LEN_NONE)\n\n \\note           On the client side, the maximum fragment length extension\n                 *will not* be used, unless the maximum fragment length has\n                 been set via this function to a value different than\n                 #MBEDTLS_SSL_MAX_FRAG_LEN_NONE.\n\n \\note           With TLS, this currently only affects ApplicationData (sent\n                 with \\c mbedtls_ssl_read()), not handshake messages.\n                 With DTLS, this affects both ApplicationData and handshake.\n\n \\note           This sets the maximum length for a record's payload,\n                 excluding record overhead that will be added to it, see\n                 \\c mbedtls_ssl_get_record_expansion().\n\n \\note           For DTLS, it is also possible to set a limit for the total\n                 size of datagrams passed to the transport layer, including\n                 record overhead, see \\c mbedtls_ssl_set_mtu().\n\n \\param conf     SSL configuration\n \\param mfl_code Code for maximum fragment length (allowed values:\n                 MBEDTLS_SSL_MAX_FRAG_LEN_512,  MBEDTLS_SSL_MAX_FRAG_LEN_1024,\n                 MBEDTLS_SSL_MAX_FRAG_LEN_2048, MBEDTLS_SSL_MAX_FRAG_LEN_4096)\n\n \\return         0 if successful or MBEDTLS_ERR_SSL_BAD_INPUT_DATA"]
    pub fn mbedtls_ssl_conf_max_frag_len(
        conf: *mut mbedtls_ssl_config,
        mfl_code: crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Pick the ciphersuites order according to the second parameter\n                 in the SSL Server module (MBEDTLS_SSL_SRV_C).\n                 (Default, if never called: MBEDTLS_SSL_SRV_CIPHERSUITE_ORDER_SERVER)\n\n \\param conf     SSL configuration\n \\param order    Server or client (MBEDTLS_SSL_SRV_CIPHERSUITE_ORDER_SERVER\n                                or MBEDTLS_SSL_SRV_CIPHERSUITE_ORDER_CLIENT)"]
    pub fn mbedtls_ssl_conf_preference_order(
        conf: *mut mbedtls_ssl_config,
        order: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          Enable / Disable session tickets (client only).\n                 (Default: MBEDTLS_SSL_SESSION_TICKETS_ENABLED.)\n\n \\note           On server, use \\c mbedtls_ssl_conf_session_tickets_cb().\n\n \\param conf     SSL configuration\n \\param use_tickets   Enable or disable (MBEDTLS_SSL_SESSION_TICKETS_ENABLED or\n                                         MBEDTLS_SSL_SESSION_TICKETS_DISABLED)"]
    pub fn mbedtls_ssl_conf_session_tickets(
        conf: *mut mbedtls_ssl_config,
        use_tickets: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief   Number of NewSessionTicket messages for the server to send\n          after handshake completion.\n\n \\note    The default value is\n          \\c MBEDTLS_SSL_TLS1_3_DEFAULT_NEW_SESSION_TICKETS.\n\n \\note    In case of a session resumption, this setting only partially apply.\n          At most one ticket is sent in that case to just renew the pool of\n          tickets of the client. The rationale is to avoid the number of\n          tickets on the server to become rapidly out of control when the\n          server has the same configuration for all its connection instances.\n\n \\param conf    SSL configuration\n \\param num_tickets    Number of NewSessionTicket.\n"]
    pub fn mbedtls_ssl_conf_new_session_tickets(conf: *mut mbedtls_ssl_config, num_tickets: u16);
}
extern "C" {
    #[doc = " \\brief          Enable / Disable renegotiation support for connection when\n                 initiated by peer\n                 (Default: MBEDTLS_SSL_RENEGOTIATION_DISABLED)\n\n \\warning        It is recommended to always disable renegotiation unless you\n                 know you need it and you know what you're doing. In the\n                 past, there have been several issues associated with\n                 renegotiation or a poor understanding of its properties.\n\n \\note           Server-side, enabling renegotiation also makes the server\n                 susceptible to a resource DoS by a malicious client.\n\n \\param conf    SSL configuration\n \\param renegotiation     Enable or disable (MBEDTLS_SSL_RENEGOTIATION_ENABLED or\n                                             MBEDTLS_SSL_RENEGOTIATION_DISABLED)"]
    pub fn mbedtls_ssl_conf_renegotiation(
        conf: *mut mbedtls_ssl_config,
        renegotiation: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          Prevent or allow legacy renegotiation.\n                 (Default: MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION)\n\n                 MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION allows connections to\n                 be established even if the peer does not support\n                 secure renegotiation, but does not allow renegotiation\n                 to take place if not secure.\n                 (Interoperable and secure option)\n\n                 MBEDTLS_SSL_LEGACY_ALLOW_RENEGOTIATION allows renegotiations\n                 with non-upgraded peers. Allowing legacy renegotiation\n                 makes the connection vulnerable to specific man in the\n                 middle attacks. (See RFC 5746)\n                 (Most interoperable and least secure option)\n\n                 MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE breaks off connections\n                 if peer does not support secure renegotiation. Results\n                 in interoperability issues with non-upgraded peers\n                 that do not support renegotiation altogether.\n                 (Most secure option, interoperability issues)\n\n \\param conf     SSL configuration\n \\param allow_legacy  Prevent or allow (SSL_NO_LEGACY_RENEGOTIATION,\n                                        SSL_ALLOW_LEGACY_RENEGOTIATION or\n                                        MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE)"]
    pub fn mbedtls_ssl_conf_legacy_renegotiation(
        conf: *mut mbedtls_ssl_config,
        allow_legacy: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          Enforce renegotiation requests.\n                 (Default: enforced, max_records = 16)\n\n                 When we request a renegotiation, the peer can comply or\n                 ignore the request. This function allows us to decide\n                 whether to enforce our renegotiation requests by closing\n                 the connection if the peer doesn't comply.\n\n                 However, records could already be in transit from the peer\n                 when the request is emitted. In order to increase\n                 reliability, we can accept a number of records before the\n                 expected handshake records.\n\n                 The optimal value is highly dependent on the specific usage\n                 scenario.\n\n \\note           With DTLS and server-initiated renegotiation, the\n                 HelloRequest is retransmitted every time mbedtls_ssl_read() times\n                 out or receives Application Data, until:\n                 - max_records records have beens seen, if it is >= 0, or\n                 - the number of retransmits that would happen during an\n                 actual handshake has been reached.\n                 Please remember the request might be lost a few times\n                 if you consider setting max_records to a really low value.\n\n \\warning        On client, the grace period can only happen during\n                 mbedtls_ssl_read(), as opposed to mbedtls_ssl_write() and mbedtls_ssl_renegotiate()\n                 which always behave as if max_record was 0. The reason is,\n                 if we receive application data from the server, we need a\n                 place to write it, which only happens during mbedtls_ssl_read().\n\n \\param conf     SSL configuration\n \\param max_records Use MBEDTLS_SSL_RENEGOTIATION_NOT_ENFORCED if you don't want to\n                 enforce renegotiation, or a non-negative value to enforce\n                 it but allow for a grace period of max_records records."]
    pub fn mbedtls_ssl_conf_renegotiation_enforced(
        conf: *mut mbedtls_ssl_config,
        max_records: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief          Set record counter threshold for periodic renegotiation.\n                 (Default: 2^48 - 1)\n\n                 Renegotiation is automatically triggered when a record\n                 counter (outgoing or incoming) crosses the defined\n                 threshold. The default value is meant to prevent the\n                 connection from being closed when the counter is about to\n                 reached its maximal value (it is not allowed to wrap).\n\n                 Lower values can be used to enforce policies such as \"keys\n                 must be refreshed every N packets with cipher X\".\n\n                 The renegotiation period can be disabled by setting\n                 conf->disable_renegotiation to\n                 MBEDTLS_SSL_RENEGOTIATION_DISABLED.\n\n \\note           When the configured transport is\n                 MBEDTLS_SSL_TRANSPORT_DATAGRAM the maximum renegotiation\n                 period is 2^48 - 1, and for MBEDTLS_SSL_TRANSPORT_STREAM,\n                 the maximum renegotiation period is 2^64 - 1.\n\n \\param conf     SSL configuration\n \\param period   The threshold value: a big-endian 64-bit number."]
    pub fn mbedtls_ssl_conf_renegotiation_period(
        conf: *mut mbedtls_ssl_config,
        period: *const crate::c_types::c_uchar,
    );
}
extern "C" {
    #[doc = " \\brief          Check if there is data already read from the\n                 underlying transport but not yet processed.\n\n \\param ssl      SSL context\n\n \\return         0 if nothing's pending, 1 otherwise.\n\n \\note           This is different in purpose and behaviour from\n                 \\c mbedtls_ssl_get_bytes_avail in that it considers\n                 any kind of unprocessed data, not only unread\n                 application data. If \\c mbedtls_ssl_get_bytes\n                 returns a non-zero value, this function will\n                 also signal pending data, but the converse does\n                 not hold. For example, in DTLS there might be\n                 further records waiting to be processed from\n                 the current underlying transport's datagram.\n\n \\note           If this function returns 1 (data pending), this\n                 does not imply that a subsequent call to\n                 \\c mbedtls_ssl_read will provide any data;\n                 e.g., the unprocessed data might turn out\n                 to be an alert or a handshake message.\n\n \\note           This function is useful in the following situation:\n                 If the SSL/TLS module successfully returns from an\n                 operation - e.g. a handshake or an application record\n                 read - and you're awaiting incoming data next, you\n                 must not immediately idle on the underlying transport\n                 to have data ready, but you need to check the value\n                 of this function first. The reason is that the desired\n                 data might already be read but not yet processed.\n                 If, in contrast, a previous call to the SSL/TLS module\n                 returned MBEDTLS_ERR_SSL_WANT_READ, it is not necessary\n                 to call this function, as the latter error code entails\n                 that all internal data has been processed.\n"]
    pub fn mbedtls_ssl_check_pending(ssl: *const mbedtls_ssl_context) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Return the number of application data bytes\n                 remaining to be read from the current record.\n\n \\param ssl      SSL context\n\n \\return         How many bytes are available in the application\n                 data record read buffer.\n\n \\note           When working over a datagram transport, this is\n                 useful to detect the current datagram's boundary\n                 in case \\c mbedtls_ssl_read has written the maximal\n                 amount of data fitting into the input buffer.\n"]
    pub fn mbedtls_ssl_get_bytes_avail(ssl: *const mbedtls_ssl_context) -> usize;
}
extern "C" {
    #[doc = " \\brief          Return the result of the certificate verification\n\n \\param ssl      The SSL context to use.\n\n \\return         \\c 0 if the certificate verification was successful.\n \\return         \\c -1u if the result is not available. This may happen\n                 e.g. if the handshake aborts early, or a verification\n                 callback returned a fatal error.\n \\return         A bitwise combination of \\c MBEDTLS_X509_BADCERT_XXX\n                 and \\c MBEDTLS_X509_BADCRL_XXX failure flags; see x509.h."]
    pub fn mbedtls_ssl_get_verify_result(ssl: *const mbedtls_ssl_context) -> u32;
}
extern "C" {
    #[doc = " \\brief          Return the id of the current ciphersuite\n\n \\param ssl      SSL context\n\n \\return         a ciphersuite id"]
    pub fn mbedtls_ssl_get_ciphersuite_id_from_ssl(
        ssl: *const mbedtls_ssl_context,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Return the name of the current ciphersuite\n\n \\param ssl      SSL context\n\n \\return         a string containing the ciphersuite name"]
    pub fn mbedtls_ssl_get_ciphersuite(
        ssl: *const mbedtls_ssl_context,
    ) -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " \\brief          Return the current TLS version\n\n \\param ssl      SSL context\n\n \\return         a string containing the TLS version"]
    pub fn mbedtls_ssl_get_version(
        ssl: *const mbedtls_ssl_context,
    ) -> *const crate::c_types::c_char;
}
extern "C" {
    #[doc = " \\brief          Return the (maximum) number of bytes added by the record\n                 layer: header + encryption/MAC overhead (inc. padding)\n\n \\param ssl      SSL context\n\n \\return         Current maximum record expansion in bytes"]
    pub fn mbedtls_ssl_get_record_expansion(
        ssl: *const mbedtls_ssl_context,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Return the current maximum outgoing record payload in bytes.\n\n \\note           The logic to determine the maximum outgoing record payload is\n                 version-specific. It takes into account various factors, such as\n                 the mbedtls_config.h setting \\c MBEDTLS_SSL_OUT_CONTENT_LEN, extensions\n                 such as the max fragment length or record size limit extension if\n                 used, and for DTLS the path MTU as configured and current\n                 record expansion.\n\n \\note           With DTLS, \\c mbedtls_ssl_write() will return an error if\n                 called with a larger length value.\n                 With TLS, \\c mbedtls_ssl_write() will fragment the input if\n                 necessary and return the number of bytes written; it is up\n                 to the caller to call \\c mbedtls_ssl_write() again in\n                 order to send the remaining bytes if any.\n\n \\sa             mbedtls_ssl_get_max_out_record_payload()\n \\sa             mbedtls_ssl_get_record_expansion()\n\n \\param ssl      SSL context\n\n \\return         Current maximum payload for an outgoing record,\n                 or a negative error code."]
    pub fn mbedtls_ssl_get_max_out_record_payload(
        ssl: *const mbedtls_ssl_context,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Return the current maximum incoming record payload in bytes.\n\n \\note           The logic to determine the maximum incoming record payload is\n                 version-specific. It takes into account various factors, such as\n                 the mbedtls_config.h setting \\c MBEDTLS_SSL_IN_CONTENT_LEN, extensions\n                 such as the max fragment length extension or record size limit\n                 extension if used, and the current record expansion.\n\n \\sa             mbedtls_ssl_set_mtu()\n \\sa             mbedtls_ssl_get_max_in_record_payload()\n \\sa             mbedtls_ssl_get_record_expansion()\n\n \\param ssl      SSL context\n\n \\return         Current maximum payload for an incoming record,\n                 or a negative error code."]
    pub fn mbedtls_ssl_get_max_in_record_payload(
        ssl: *const mbedtls_ssl_context,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Return the peer certificate from the current connection.\n\n \\param  ssl     The SSL context to use. This must be initialized and setup.\n\n \\return         The current peer certificate, if available.\n                 The returned certificate is owned by the SSL context and\n                 is valid only until the next call to the SSL API.\n \\return         \\c NULL if no peer certificate is available. This might\n                 be because the chosen ciphersuite doesn't use CRTs\n                 (PSK-based ciphersuites, for example), or because\n                 #MBEDTLS_SSL_KEEP_PEER_CERTIFICATE has been disabled,\n                 allowing the stack to free the peer's CRT to save memory.\n\n \\note           For one-time inspection of the peer's certificate during\n                 the handshake, consider registering an X.509 CRT verification\n                 callback through mbedtls_ssl_conf_verify() instead of calling\n                 this function. Using mbedtls_ssl_conf_verify() also comes at\n                 the benefit of allowing you to influence the verification\n                 process, for example by masking expected and tolerated\n                 verification failures.\n\n \\warning        You must not use the pointer returned by this function\n                 after any further call to the SSL API, including\n                 mbedtls_ssl_read() and mbedtls_ssl_write(); this is\n                 because the pointer might change during renegotiation,\n                 which happens transparently to the user.\n                 If you want to use the certificate across API calls,\n                 you must make a copy."]
    pub fn mbedtls_ssl_get_peer_cert(ssl: *const mbedtls_ssl_context) -> *const mbedtls_x509_crt;
}
extern "C" {
    #[doc = " \\brief          Export a session in order to resume it later.\n\n \\param ssl      The SSL context representing the connection for which to\n                 to export a session structure for later resumption.\n \\param session  The target structure in which to store the exported session.\n                 This must have been initialized with mbedtls_ssl_init_session()\n                 but otherwise be unused.\n\n \\note           This function can handle a variety of mechanisms for session\n                 resumption: For TLS 1.2, both session ID-based resumption and\n                 ticket-based resumption will be considered. For TLS 1.3,\n                 once implemented, sessions equate to tickets, and calling\n                 this function multiple times will export the available\n                 tickets one a time until no further tickets are available,\n                 in which case MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE will\n                 be returned.\n\n \\note           Calling this function multiple times will only be useful\n                 once TLS 1.3 is supported. For TLS 1.2 connections, this\n                 function should be called at most once.\n\n \\return         \\c 0 if successful. In this case, \\p session can be used for\n                 session resumption by passing it to mbedtls_ssl_set_session(),\n                 and serialized for storage via mbedtls_ssl_session_save().\n \\return         #MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE if no further session\n                 is available for export.\n                 This error is a non-fatal, and has no observable effect on\n                 the SSL context or the destination session.\n \\return         Another negative error code on other kinds of failure.\n\n \\sa             mbedtls_ssl_set_session()\n \\sa             mbedtls_ssl_session_save()"]
    pub fn mbedtls_ssl_get_session(
        ssl: *const mbedtls_ssl_context,
        session: *mut mbedtls_ssl_session,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform the SSL handshake\n\n \\param ssl      SSL context\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_SSL_WANT_READ or #MBEDTLS_ERR_SSL_WANT_WRITE\n                 if the handshake is incomplete and waiting for data to\n                 be available for reading from or writing to the underlying\n                 transport - in this case you must call this function again\n                 when the underlying transport is ready for the operation.\n \\return         #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS if an asynchronous\n                 operation is in progress (see\n                 mbedtls_ssl_conf_async_private_cb()) - in this case you\n                 must call this function again when the operation is ready.\n \\return         #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS if a cryptographic\n                 operation is in progress (see mbedtls_ecp_set_max_ops()) -\n                 in this case you must call this function again to complete\n                 the handshake when you're done attending other tasks.\n \\return         #MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED if DTLS is in use\n                 and the client did not demonstrate reachability yet - in\n                 this case you must stop using the context (see below).\n \\return         Another SSL error code - in this case you must stop using\n                 the context (see below).\n\n \\warning        If this function returns something other than\n                 \\c 0,\n                 #MBEDTLS_ERR_SSL_WANT_READ,\n                 #MBEDTLS_ERR_SSL_WANT_WRITE,\n                 #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS or\n                 #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS,\n                 you must stop using the SSL context for reading or writing,\n                 and either free it or call \\c mbedtls_ssl_session_reset()\n                 on it before re-using it for a new connection; the current\n                 connection must be closed.\n\n \\note           If DTLS is in use, then you may choose to handle\n                 #MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED specially for logging\n                 purposes, as it is an expected return value rather than an\n                 actual error, but you still need to reset/free the context.\n\n \\note           Remarks regarding event-driven DTLS:\n                 If the function returns #MBEDTLS_ERR_SSL_WANT_READ, no datagram\n                 from the underlying transport layer is currently being processed,\n                 and it is safe to idle until the timer or the underlying transport\n                 signal a new event. This is not true for a successful handshake,\n                 in which case the datagram of the underlying transport that is\n                 currently being processed might or might not contain further\n                 DTLS records.\n\n \\note           If the context is configured to allow TLS 1.3, or if\n                 #MBEDTLS_USE_PSA_CRYPTO is enabled, the PSA crypto\n                 subsystem must have been initialized by calling\n                 psa_crypto_init() before calling this function."]
    pub fn mbedtls_ssl_handshake(ssl: *mut mbedtls_ssl_context) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Perform a single step of the SSL handshake\n\n \\note           The state of the context (ssl->state) will be at\n                 the next state after this function returns \\c 0. Do not\n                 call this function if mbedtls_ssl_is_handshake_over()\n                 returns \\c 1.\n\n \\warning        Whilst in the past you may have used direct access to the\n                 context state (ssl->state) in order to ascertain when to\n                 stop calling this function and although you can still do\n                 so with something like ssl->MBEDTLS_PRIVATE(state) or by\n                 defining MBEDTLS_ALLOW_PRIVATE_ACCESS, this is now\n                 considered deprecated and could be broken in any future\n                 release. If you still find you have good reason for such\n                 direct access, then please do contact the team to explain\n                 this (raise an issue or post to the mailing list), so that\n                 we can add a solution to your problem that will be\n                 guaranteed to work in the future.\n\n \\param ssl      SSL context\n\n \\return         See mbedtls_ssl_handshake().\n\n \\warning        If this function returns something other than \\c 0,\n                 #MBEDTLS_ERR_SSL_WANT_READ, #MBEDTLS_ERR_SSL_WANT_WRITE,\n                 #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS or\n                 #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS, you must stop using\n                 the SSL context for reading or writing, and either free it\n                 or call \\c mbedtls_ssl_session_reset() on it before\n                 re-using it for a new connection; the current connection\n                 must be closed."]
    pub fn mbedtls_ssl_handshake_step(ssl: *mut mbedtls_ssl_context) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Initiate an SSL renegotiation on the running connection.\n                 Client: perform the renegotiation right now.\n                 Server: request renegotiation, which will be performed\n                 during the next call to mbedtls_ssl_read() if honored by\n                 client.\n\n \\param ssl      SSL context\n\n \\return         0 if successful, or any mbedtls_ssl_handshake() return\n                 value except #MBEDTLS_ERR_SSL_CLIENT_RECONNECT that can't\n                 happen during a renegotiation.\n\n \\warning        If this function returns something other than \\c 0,\n                 #MBEDTLS_ERR_SSL_WANT_READ, #MBEDTLS_ERR_SSL_WANT_WRITE,\n                 #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS or\n                 #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS, you must stop using\n                 the SSL context for reading or writing, and either free it\n                 or call \\c mbedtls_ssl_session_reset() on it before\n                 re-using it for a new connection; the current connection\n                 must be closed.\n"]
    pub fn mbedtls_ssl_renegotiate(ssl: *mut mbedtls_ssl_context) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Read at most 'len' application data bytes\n\n \\param ssl      SSL context\n \\param buf      buffer that will hold the data\n \\param len      maximum number of bytes to read\n\n \\return         The (positive) number of bytes read if successful.\n \\return         \\c 0 if the read end of the underlying transport was closed\n                 without sending a CloseNotify beforehand, which might happen\n                 because of various reasons (internal error of an underlying\n                 stack, non-conformant peer not sending a CloseNotify and\n                 such) - in this case you must stop using the context\n                 (see below).\n \\return         #MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY if the underlying\n                 transport is still functional, but the peer has\n                 acknowledged to not send anything anymore.\n \\return         #MBEDTLS_ERR_SSL_WANT_READ or #MBEDTLS_ERR_SSL_WANT_WRITE\n                 if the handshake is incomplete and waiting for data to\n                 be available for reading from or writing to the underlying\n                 transport - in this case you must call this function again\n                 when the underlying transport is ready for the operation.\n \\return         #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS if an asynchronous\n                 operation is in progress (see\n                 mbedtls_ssl_conf_async_private_cb()) - in this case you\n                 must call this function again when the operation is ready.\n \\return         #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS if a cryptographic\n                 operation is in progress (see mbedtls_ecp_set_max_ops()) -\n                 in this case you must call this function again to complete\n                 the handshake when you're done attending other tasks.\n \\return         #MBEDTLS_ERR_SSL_CLIENT_RECONNECT if we're at the server\n                 side of a DTLS connection and the client is initiating a\n                 new connection using the same source port. See below.\n \\return         Another SSL error code - in this case you must stop using\n                 the context (see below).\n\n \\warning        If this function returns something other than\n                 a positive value,\n                 #MBEDTLS_ERR_SSL_WANT_READ,\n                 #MBEDTLS_ERR_SSL_WANT_WRITE,\n                 #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS,\n                 #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS or\n                 #MBEDTLS_ERR_SSL_CLIENT_RECONNECT,\n                 you must stop using the SSL context for reading or writing,\n                 and either free it or call \\c mbedtls_ssl_session_reset()\n                 on it before re-using it for a new connection; the current\n                 connection must be closed.\n\n \\note           When this function returns #MBEDTLS_ERR_SSL_CLIENT_RECONNECT\n                 (which can only happen server-side), it means that a client\n                 is initiating a new connection using the same source port.\n                 You can either treat that as a connection close and wait\n                 for the client to resend a ClientHello, or directly\n                 continue with \\c mbedtls_ssl_handshake() with the same\n                 context (as it has been reset internally). Either way, you\n                 must make sure this is seen by the application as a new\n                 connection: application state, if any, should be reset, and\n                 most importantly the identity of the client must be checked\n                 again. WARNING: not validating the identity of the client\n                 again, or not transmitting the new identity to the\n                 application layer, would allow authentication bypass!\n\n \\note           Remarks regarding event-driven DTLS:\n                 - If the function returns #MBEDTLS_ERR_SSL_WANT_READ, no datagram\n                   from the underlying transport layer is currently being processed,\n                   and it is safe to idle until the timer or the underlying transport\n                   signal a new event.\n                 - This function may return MBEDTLS_ERR_SSL_WANT_READ even if data was\n                   initially available on the underlying transport, as this data may have\n                   been only e.g. duplicated messages or a renegotiation request.\n                   Therefore, you must be prepared to receive MBEDTLS_ERR_SSL_WANT_READ even\n                   when reacting to an incoming-data event from the underlying transport.\n                 - On success, the datagram of the underlying transport that is currently\n                   being processed may contain further DTLS records. You should call\n                   \\c mbedtls_ssl_check_pending to check for remaining records.\n"]
    pub fn mbedtls_ssl_read(
        ssl: *mut mbedtls_ssl_context,
        buf: *mut crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Try to write exactly 'len' application data bytes\n\n \\warning        This function will do partial writes in some cases. If the\n                 return value is non-negative but less than length, the\n                 function must be called again with updated arguments:\n                 buf + ret, len - ret (if ret is the return value) until\n                 it returns a value equal to the last 'len' argument.\n\n \\param ssl      SSL context\n \\param buf      buffer holding the data\n \\param len      how many bytes must be written\n\n \\return         The (non-negative) number of bytes actually written if\n                 successful (may be less than \\p len).\n \\return         #MBEDTLS_ERR_SSL_WANT_READ or #MBEDTLS_ERR_SSL_WANT_WRITE\n                 if the handshake is incomplete and waiting for data to\n                 be available for reading from or writing to the underlying\n                 transport - in this case you must call this function again\n                 when the underlying transport is ready for the operation.\n \\return         #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS if an asynchronous\n                 operation is in progress (see\n                 mbedtls_ssl_conf_async_private_cb()) - in this case you\n                 must call this function again when the operation is ready.\n \\return         #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS if a cryptographic\n                 operation is in progress (see mbedtls_ecp_set_max_ops()) -\n                 in this case you must call this function again to complete\n                 the handshake when you're done attending other tasks.\n \\return         Another SSL error code - in this case you must stop using\n                 the context (see below).\n\n \\warning        If this function returns something other than\n                 a non-negative value,\n                 #MBEDTLS_ERR_SSL_WANT_READ,\n                 #MBEDTLS_ERR_SSL_WANT_WRITE,\n                 #MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS or\n                 #MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS,\n                 you must stop using the SSL context for reading or writing,\n                 and either free it or call \\c mbedtls_ssl_session_reset()\n                 on it before re-using it for a new connection; the current\n                 connection must be closed.\n\n \\note           When this function returns #MBEDTLS_ERR_SSL_WANT_WRITE/READ,\n                 it must be called later with the *same* arguments,\n                 until it returns a value greater than or equal to 0. When\n                 the function returns #MBEDTLS_ERR_SSL_WANT_WRITE there may be\n                 some partial data in the output buffer, however this is not\n                 yet sent.\n\n \\note           If the requested length is greater than the maximum\n                 fragment length (either the built-in limit or the one set\n                 or negotiated with the peer), then:\n                 - with TLS, less bytes than requested are written.\n                 - with DTLS, MBEDTLS_ERR_SSL_BAD_INPUT_DATA is returned.\n                 \\c mbedtls_ssl_get_max_out_record_payload() may be used to\n                 query the active maximum fragment length.\n\n \\note           Attempting to write 0 bytes will result in an empty TLS\n                 application record being sent."]
    pub fn mbedtls_ssl_write(
        ssl: *mut mbedtls_ssl_context,
        buf: *const crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Send an alert message\n\n \\param ssl       SSL context\n \\param level     The alert level of the message\n                  (MBEDTLS_SSL_ALERT_LEVEL_WARNING or MBEDTLS_SSL_ALERT_LEVEL_FATAL)\n \\param message   The alert message (SSL_ALERT_MSG_*)\n\n \\return          0 if successful, or a specific SSL error code.\n\n \\note           If this function returns something other than 0 or\n                 MBEDTLS_ERR_SSL_WANT_READ/WRITE, you must stop using\n                 the SSL context for reading or writing, and either free it or\n                 call \\c mbedtls_ssl_session_reset() on it before re-using it\n                 for a new connection; the current connection must be closed."]
    pub fn mbedtls_ssl_send_alert_message(
        ssl: *mut mbedtls_ssl_context,
        level: crate::c_types::c_uchar,
        message: crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Notify the peer that the connection is being closed\n\n \\param ssl      SSL context\n\n \\return          0 if successful, or a specific SSL error code.\n\n \\note           If this function returns something other than 0 or\n                 MBEDTLS_ERR_SSL_WANT_READ/WRITE, you must stop using\n                 the SSL context for reading or writing, and either free it or\n                 call \\c mbedtls_ssl_session_reset() on it before re-using it\n                 for a new connection; the current connection must be closed."]
    pub fn mbedtls_ssl_close_notify(ssl: *mut mbedtls_ssl_context) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Free referenced items in an SSL context and clear memory\n\n \\param ssl      SSL context"]
    pub fn mbedtls_ssl_free(ssl: *mut mbedtls_ssl_context);
}
extern "C" {
    #[doc = " \\brief          Save an active connection as serialized data in a buffer.\n                 This allows the freeing or re-using of the SSL context\n                 while still picking up the connection later in a way that\n                 it entirely transparent to the peer.\n\n \\see            mbedtls_ssl_context_load()\n\n \\note           The serialized data only contains the data that is\n                 necessary to resume the connection: negotiated protocol\n                 options, session identifier, keys, etc.\n                 Loading a saved SSL context does not restore settings and\n                 state related to how the application accesses the context,\n                 such as configured callback functions, user data, pending\n                 incoming or outgoing data, etc.\n\n \\note           This feature is currently only available under certain\n                 conditions, see the documentation of the return value\n                 #MBEDTLS_ERR_SSL_BAD_INPUT_DATA for details.\n\n \\note           When this function succeeds, it calls\n                 mbedtls_ssl_session_reset() on \\p ssl which as a result is\n                 no longer associated with the connection that has been\n                 serialized. This avoids creating copies of the connection\n                 state. You're then free to either re-use the context\n                 structure for a different connection, or call\n                 mbedtls_ssl_free() on it. See the documentation of\n                 mbedtls_ssl_session_reset() for more details.\n\n \\param ssl      The SSL context to save. On success, it is no longer\n                 associated with the connection that has been serialized.\n \\param buf      The buffer to write the serialized data to. It must be a\n                 writeable buffer of at least \\p buf_len bytes, or may be \\c\n                 NULL if \\p buf_len is \\c 0.\n \\param buf_len  The number of bytes available for writing in \\p buf.\n \\param olen     The size in bytes of the data that has been or would have\n                 been written. It must point to a valid \\c size_t.\n\n \\note           \\p olen is updated to the correct value regardless of\n                 whether \\p buf_len was large enough. This makes it possible\n                 to determine the necessary size by calling this function\n                 with \\p buf set to \\c NULL and \\p buf_len to \\c 0. However,\n                 the value of \\p olen is only guaranteed to be correct when\n                 the function returns #MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL or\n                 \\c 0. If the return value is different, then the value of\n                 \\p olen is undefined.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL if \\p buf is too small.\n \\return         #MBEDTLS_ERR_SSL_ALLOC_FAILED if memory allocation failed\n                 while resetting the context.\n \\return         #MBEDTLS_ERR_SSL_BAD_INPUT_DATA if a handshake is in\n                 progress, or there is pending data for reading or sending,\n                 or the connection does not use DTLS 1.2 with an AEAD\n                 ciphersuite, or renegotiation is enabled."]
    pub fn mbedtls_ssl_context_save(
        ssl: *mut mbedtls_ssl_context,
        buf: *mut crate::c_types::c_uchar,
        buf_len: usize,
        olen: *mut usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Load serialized connection data to an SSL context.\n\n \\see            mbedtls_ssl_context_save()\n\n \\warning        The same serialized data must never be loaded into more\n                 that one context. In order to ensure that, after\n                 successfully loading serialized data to an SSL context, you\n                 should immediately destroy or invalidate all copies of the\n                 serialized data that was loaded. Loading the same data in\n                 more than one context would cause severe security failures\n                 including but not limited to loss of confidentiality.\n\n \\note           Before calling this function, the SSL context must be\n                 prepared in one of the two following ways. The first way is\n                 to take a context freshly initialised with\n                 mbedtls_ssl_init() and call mbedtls_ssl_setup() on it with\n                 the same ::mbedtls_ssl_config structure that was used in\n                 the original connection. The second way is to\n                 call mbedtls_ssl_session_reset() on a context that was\n                 previously prepared as above but used in the meantime.\n                 Either way, you must not use the context to perform a\n                 handshake between calling mbedtls_ssl_setup() or\n                 mbedtls_ssl_session_reset() and calling this function. You\n                 may however call other setter functions in that time frame\n                 as indicated in the note below.\n\n \\note           Before or after calling this function successfully, you\n                 also need to configure some connection-specific callbacks\n                 and settings before you can use the connection again\n                 (unless they were already set before calling\n                 mbedtls_ssl_session_reset() and the values are suitable for\n                 the present connection). Specifically, you want to call\n                 at least mbedtls_ssl_set_bio(),\n                 mbedtls_ssl_set_timer_cb(), and\n                 mbedtls_ssl_set_user_data_n() or\n                 mbedtls_ssl_set_user_data_p() if they were set originally.\n                 All other SSL setter functions\n                 are not necessary to call, either because they're only used\n                 in handshakes, or because the setting is already saved. You\n                 might choose to call them anyway, for example in order to\n                 share code between the cases of establishing a new\n                 connection and the case of loading an already-established\n                 connection.\n\n \\note           If you have new information about the path MTU, you want to\n                 call mbedtls_ssl_set_mtu() after calling this function, as\n                 otherwise this function would overwrite your\n                 newly-configured value with the value that was active when\n                 the context was saved.\n\n \\note           When this function returns an error code, it calls\n                 mbedtls_ssl_free() on \\p ssl. In this case, you need to\n                 prepare the context with the usual sequence starting with a\n                 call to mbedtls_ssl_init() if you want to use it again.\n\n \\param ssl      The SSL context structure to be populated. It must have\n                 been prepared as described in the note above.\n \\param buf      The buffer holding the serialized connection data. It must\n                 be a readable buffer of at least \\p len bytes.\n \\param len      The size of the serialized data in bytes.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_SSL_ALLOC_FAILED if memory allocation failed.\n \\return         #MBEDTLS_ERR_SSL_VERSION_MISMATCH if the serialized data\n                 comes from a different Mbed TLS version or build.\n \\return         #MBEDTLS_ERR_SSL_BAD_INPUT_DATA if input data is invalid."]
    pub fn mbedtls_ssl_context_load(
        ssl: *mut mbedtls_ssl_context,
        buf: *const crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Initialize an SSL configuration context\n                 Just makes the context ready for\n                 mbedtls_ssl_config_defaults() or mbedtls_ssl_config_free().\n\n \\note           You need to call mbedtls_ssl_config_defaults() unless you\n                 manually set all of the relevant fields yourself.\n\n \\param conf     SSL configuration context"]
    pub fn mbedtls_ssl_config_init(conf: *mut mbedtls_ssl_config);
}
extern "C" {
    #[doc = " \\brief          Load reasonable default SSL configuration values.\n                 (You need to call mbedtls_ssl_config_init() first.)\n\n \\param conf     SSL configuration context\n \\param endpoint MBEDTLS_SSL_IS_CLIENT or MBEDTLS_SSL_IS_SERVER\n \\param transport MBEDTLS_SSL_TRANSPORT_STREAM for TLS, or\n                  MBEDTLS_SSL_TRANSPORT_DATAGRAM for DTLS\n \\param preset   a MBEDTLS_SSL_PRESET_XXX value\n\n \\note           See \\c mbedtls_ssl_conf_transport() for notes on DTLS.\n\n \\return         0 if successful, or\n                 MBEDTLS_ERR_XXX_ALLOC_FAILED on memory allocation error."]
    pub fn mbedtls_ssl_config_defaults(
        conf: *mut mbedtls_ssl_config,
        endpoint: crate::c_types::c_int,
        transport: crate::c_types::c_int,
        preset: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Free an SSL configuration context\n\n \\param conf     SSL configuration context"]
    pub fn mbedtls_ssl_config_free(conf: *mut mbedtls_ssl_config);
}
extern "C" {
    #[doc = " \\brief          Initialize SSL session structure\n\n \\param session  SSL session"]
    pub fn mbedtls_ssl_session_init(session: *mut mbedtls_ssl_session);
}
extern "C" {
    #[doc = " \\brief          Free referenced items in an SSL session including the\n                 peer certificate and clear memory\n\n \\note           A session object can be freed even if the SSL context\n                 that was used to retrieve the session is still in use.\n\n \\param session  SSL session"]
    pub fn mbedtls_ssl_session_free(session: *mut mbedtls_ssl_session);
}
extern "C" {
    #[doc = " \\brief          TLS-PRF function for key derivation.\n\n \\param prf      The tls_prf type function type to be used.\n \\param secret   Secret for the key derivation function.\n \\param slen     Length of the secret.\n \\param label    String label for the key derivation function,\n                 terminated with null character.\n \\param random   Random bytes.\n \\param rlen     Length of the random bytes buffer.\n \\param dstbuf   The buffer holding the derived key.\n \\param dlen     Length of the output buffer.\n\n \\return         0 on success. An SSL specific error on failure."]
    pub fn mbedtls_ssl_tls_prf(
        prf: mbedtls_tls_prf_types,
        secret: *const crate::c_types::c_uchar,
        slen: usize,
        label: *const crate::c_types::c_char,
        random: *const crate::c_types::c_uchar,
        rlen: usize,
        dstbuf: *mut crate::c_types::c_uchar,
        dlen: usize,
    ) -> crate::c_types::c_int;
}
#[doc = " \\brief           Entropy poll callback pointer\n\n \\param data      Callback-specific data pointer\n \\param output    Data to fill\n \\param len       Maximum size to provide\n \\param olen      The actual amount of bytes put into the buffer (Can be 0)\n\n \\return          0 if no critical failures occurred,\n                  MBEDTLS_ERR_ENTROPY_SOURCE_FAILED otherwise"]
pub type mbedtls_entropy_f_source_ptr = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut crate::c_types::c_void,
        output: *mut crate::c_types::c_uchar,
        len: usize,
        olen: *mut usize,
    ) -> crate::c_types::c_int,
>;
#[doc = " \\brief           Entropy source state"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_entropy_source_state {
    pub private_f_source: mbedtls_entropy_f_source_ptr,
    pub private_p_source: *mut crate::c_types::c_void,
    pub private_size: usize,
    pub private_threshold: usize,
    pub private_strong: crate::c_types::c_int,
}
#[doc = " \\brief           Entropy context structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_entropy_context {
    pub private_accumulator_started: crate::c_types::c_int,
    pub private_accumulator: mbedtls_sha512_context,
    pub private_source_count: crate::c_types::c_int,
    pub private_source: [mbedtls_entropy_source_state; 20usize],
}
extern "C" {
    #[doc = " \\brief           Initialize the context\n\n \\param ctx       Entropy context to initialize"]
    pub fn mbedtls_entropy_init(ctx: *mut mbedtls_entropy_context);
}
extern "C" {
    #[doc = " \\brief           Free the data in the context\n\n \\param ctx       Entropy context to free"]
    pub fn mbedtls_entropy_free(ctx: *mut mbedtls_entropy_context);
}
extern "C" {
    #[doc = " \\brief           Adds an entropy source to poll\n                  (Thread-safe if MBEDTLS_THREADING_C is enabled)\n\n \\param ctx       Entropy context\n \\param f_source  Entropy function\n \\param p_source  Function data\n \\param threshold Minimum required from source before entropy is released\n                  ( with mbedtls_entropy_func() ) (in bytes)\n \\param strong    MBEDTLS_ENTROPY_SOURCE_STRONG or\n                  MBEDTLS_ENTROPY_SOURCE_WEAK.\n                  At least one strong source needs to be added.\n                  Weaker sources (such as the cycle counter) can be used as\n                  a complement.\n\n \\return          0 if successful or MBEDTLS_ERR_ENTROPY_MAX_SOURCES"]
    pub fn mbedtls_entropy_add_source(
        ctx: *mut mbedtls_entropy_context,
        f_source: mbedtls_entropy_f_source_ptr,
        p_source: *mut crate::c_types::c_void,
        threshold: usize,
        strong: crate::c_types::c_int,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Trigger an extra gather poll for the accumulator\n                  (Thread-safe if MBEDTLS_THREADING_C is enabled)\n\n \\param ctx       Entropy context\n\n \\return          0 if successful, or MBEDTLS_ERR_ENTROPY_SOURCE_FAILED"]
    pub fn mbedtls_entropy_gather(ctx: *mut mbedtls_entropy_context) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Retrieve entropy from the accumulator\n                  (Maximum length: MBEDTLS_ENTROPY_BLOCK_SIZE)\n                  (Thread-safe if MBEDTLS_THREADING_C is enabled)\n\n \\param data      Entropy context\n \\param output    Buffer to fill\n \\param len       Number of bytes desired, must be at most MBEDTLS_ENTROPY_BLOCK_SIZE\n\n \\return          0 if successful, or MBEDTLS_ERR_ENTROPY_SOURCE_FAILED"]
    pub fn mbedtls_entropy_func(
        data: *mut crate::c_types::c_void,
        output: *mut crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Add data to the accumulator manually\n                  (Thread-safe if MBEDTLS_THREADING_C is enabled)\n\n \\param ctx       Entropy context\n \\param data      Data to add\n \\param len       Length of data\n\n \\return          0 if successful"]
    pub fn mbedtls_entropy_update_manual(
        ctx: *mut mbedtls_entropy_context,
        data: *const crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Checkup routine\n\n                 This module self-test also calls the entropy self-test,\n                 mbedtls_entropy_source_self_test();\n\n \\return         0 if successful, or 1 if a test failed"]
    pub fn mbedtls_entropy_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief   Set the threshold error level to handle globally all debug output.\n          Debug messages that have a level over the threshold value are\n          discarded.\n          (Default value: 0 = No debug )\n\n \\param threshold     threshold level of messages to filter on. Messages at a\n                      higher level will be discarded.\n                          - Debug levels\n                              - 0 No debug\n                              - 1 Error\n                              - 2 State change\n                              - 3 Informational\n                              - 4 Verbose"]
    pub fn mbedtls_debug_set_threshold(threshold: crate::c_types::c_int);
}
extern "C" {
    #[doc = " \\brief    Print a message to the debug output. This function is always used\n          through the MBEDTLS_SSL_DEBUG_MSG() macro, which supplies the ssl\n          context, file and line number parameters.\n\n \\param ssl       SSL context\n \\param level     error level of the debug message\n \\param file      file the message has occurred in\n \\param line      line number the message has occurred at\n \\param format    format specifier, in printf format\n \\param ...       variables used by the format specifier\n\n \\attention       This function is intended for INTERNAL usage within the\n                  library only."]
    pub fn mbedtls_debug_print_msg(
        ssl: *const mbedtls_ssl_context,
        level: crate::c_types::c_int,
        file: *const crate::c_types::c_char,
        line: crate::c_types::c_int,
        format: *const crate::c_types::c_char,
        ...
    );
}
extern "C" {
    #[doc = " \\brief   Print the return value of a function to the debug output. This\n          function is always used through the MBEDTLS_SSL_DEBUG_RET() macro,\n          which supplies the ssl context, file and line number parameters.\n\n \\param ssl       SSL context\n \\param level     error level of the debug message\n \\param file      file the error has occurred in\n \\param line      line number the error has occurred in\n \\param text      the name of the function that returned the error\n \\param ret       the return code value\n\n \\attention       This function is intended for INTERNAL usage within the\n                  library only."]
    pub fn mbedtls_debug_print_ret(
        ssl: *const mbedtls_ssl_context,
        level: crate::c_types::c_int,
        file: *const crate::c_types::c_char,
        line: crate::c_types::c_int,
        text: *const crate::c_types::c_char,
        ret: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief   Output a buffer of size len bytes to the debug output. This function\n          is always used through the MBEDTLS_SSL_DEBUG_BUF() macro,\n          which supplies the ssl context, file and line number parameters.\n\n \\param ssl       SSL context\n \\param level     error level of the debug message\n \\param file      file the error has occurred in\n \\param line      line number the error has occurred in\n \\param text      a name or label for the buffer being dumped. Normally the\n                  variable or buffer name\n \\param buf       the buffer to be outputted\n \\param len       length of the buffer\n\n \\attention       This function is intended for INTERNAL usage within the\n                  library only."]
    pub fn mbedtls_debug_print_buf(
        ssl: *const mbedtls_ssl_context,
        level: crate::c_types::c_int,
        file: *const crate::c_types::c_char,
        line: crate::c_types::c_int,
        text: *const crate::c_types::c_char,
        buf: *const crate::c_types::c_uchar,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief   Print a MPI variable to the debug output. This function is always\n          used through the MBEDTLS_SSL_DEBUG_MPI() macro, which supplies the\n          ssl context, file and line number parameters.\n\n \\param ssl       SSL context\n \\param level     error level of the debug message\n \\param file      file the error has occurred in\n \\param line      line number the error has occurred in\n \\param text      a name or label for the MPI being output. Normally the\n                  variable name\n \\param X         the MPI variable\n\n \\attention       This function is intended for INTERNAL usage within the\n                  library only."]
    pub fn mbedtls_debug_print_mpi(
        ssl: *const mbedtls_ssl_context,
        level: crate::c_types::c_int,
        file: *const crate::c_types::c_char,
        line: crate::c_types::c_int,
        text: *const crate::c_types::c_char,
        X: *const mbedtls_mpi,
    );
}
extern "C" {
    #[doc = " \\brief   Print an ECP point to the debug output. This function is always\n          used through the MBEDTLS_SSL_DEBUG_ECP() macro, which supplies the\n          ssl context, file and line number parameters.\n\n \\param ssl       SSL context\n \\param level     error level of the debug message\n \\param file      file the error has occurred in\n \\param line      line number the error has occurred in\n \\param text      a name or label for the ECP point being output. Normally the\n                  variable name\n \\param X         the ECP point\n\n \\attention       This function is intended for INTERNAL usage within the\n                  library only."]
    pub fn mbedtls_debug_print_ecp(
        ssl: *const mbedtls_ssl_context,
        level: crate::c_types::c_int,
        file: *const crate::c_types::c_char,
        line: crate::c_types::c_int,
        text: *const crate::c_types::c_char,
        X: *const mbedtls_ecp_point,
    );
}
extern "C" {
    #[doc = " \\brief   Print a X.509 certificate structure to the debug output. This\n          function is always used through the MBEDTLS_SSL_DEBUG_CRT() macro,\n          which supplies the ssl context, file and line number parameters.\n\n \\param ssl       SSL context\n \\param level     error level of the debug message\n \\param file      file the error has occurred in\n \\param line      line number the error has occurred in\n \\param text      a name or label for the certificate being output\n \\param crt       X.509 certificate structure\n\n \\attention       This function is intended for INTERNAL usage within the\n                  library only."]
    pub fn mbedtls_debug_print_crt(
        ssl: *const mbedtls_ssl_context,
        level: crate::c_types::c_int,
        file: *const crate::c_types::c_char,
        line: crate::c_types::c_int,
        text: *const crate::c_types::c_char,
        crt: *const mbedtls_x509_crt,
    );
}
pub const mbedtls_debug_ecdh_attr_MBEDTLS_DEBUG_ECDH_Q: mbedtls_debug_ecdh_attr = 0;
pub const mbedtls_debug_ecdh_attr_MBEDTLS_DEBUG_ECDH_QP: mbedtls_debug_ecdh_attr = 1;
pub const mbedtls_debug_ecdh_attr_MBEDTLS_DEBUG_ECDH_Z: mbedtls_debug_ecdh_attr = 2;
pub type mbedtls_debug_ecdh_attr = crate::c_types::c_uint;
extern "C" {
    #[doc = " \\brief   Print a field of the ECDH structure in the SSL context to the debug\n          output. This function is always used through the\n          MBEDTLS_SSL_DEBUG_ECDH() macro, which supplies the ssl context, file\n          and line number parameters.\n\n \\param ssl       SSL context\n \\param level     error level of the debug message\n \\param file      file the error has occurred in\n \\param line      line number the error has occurred in\n \\param ecdh      the ECDH context\n \\param attr      the identifier of the attribute being output\n\n \\attention       This function is intended for INTERNAL usage within the\n                  library only."]
    pub fn mbedtls_debug_printf_ecdh(
        ssl: *const mbedtls_ssl_context,
        level: crate::c_types::c_int,
        file: *const crate::c_types::c_char,
        line: crate::c_types::c_int,
        ecdh: *const mbedtls_ecdh_context,
        attr: mbedtls_debug_ecdh_attr,
    );
}
#[doc = " \\brief The AES context-type definition."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_aes_context {
    pub private_nr: crate::c_types::c_int,
    pub private_rk_offset: usize,
    pub private_buf: [u32; 68usize],
}
#[doc = " \\brief The AES XTS context-type definition."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_aes_xts_context {
    pub private_crypt: mbedtls_aes_context,
    pub private_tweak: mbedtls_aes_context,
}
extern "C" {
    #[doc = " \\brief          This function initializes the specified AES context.\n\n                 It must be the first API called before using\n                 the context.\n\n \\param ctx      The AES context to initialize. This must not be \\c NULL."]
    pub fn mbedtls_aes_init(ctx: *mut mbedtls_aes_context);
}
extern "C" {
    #[doc = " \\brief          This function releases and clears the specified AES context.\n\n \\param ctx      The AES context to clear.\n                 If this is \\c NULL, this function does nothing.\n                 Otherwise, the context must have been at least initialized."]
    pub fn mbedtls_aes_free(ctx: *mut mbedtls_aes_context);
}
extern "C" {
    #[doc = " \\brief          This function initializes the specified AES XTS context.\n\n                 It must be the first API called before using\n                 the context.\n\n \\param ctx      The AES XTS context to initialize. This must not be \\c NULL."]
    pub fn mbedtls_aes_xts_init(ctx: *mut mbedtls_aes_xts_context);
}
extern "C" {
    #[doc = " \\brief          This function releases and clears the specified AES XTS context.\n\n \\param ctx      The AES XTS context to clear.\n                 If this is \\c NULL, this function does nothing.\n                 Otherwise, the context must have been at least initialized."]
    pub fn mbedtls_aes_xts_free(ctx: *mut mbedtls_aes_xts_context);
}
extern "C" {
    #[doc = " \\brief          This function sets the encryption key.\n\n \\param ctx      The AES context to which the key should be bound.\n                 It must be initialized.\n \\param key      The encryption key.\n                 This must be a readable buffer of size \\p keybits bits.\n \\param keybits  The size of data passed in bits. Valid options are:\n                 <ul><li>128 bits</li>\n                 <li>192 bits</li>\n                 <li>256 bits</li></ul>\n\n \\return         \\c 0 on success.\n \\return         #MBEDTLS_ERR_AES_INVALID_KEY_LENGTH on failure."]
    pub fn mbedtls_aes_setkey_enc(
        ctx: *mut mbedtls_aes_context,
        key: *const crate::c_types::c_uchar,
        keybits: crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function sets the decryption key.\n\n \\param ctx      The AES context to which the key should be bound.\n                 It must be initialized.\n \\param key      The decryption key.\n                 This must be a readable buffer of size \\p keybits bits.\n \\param keybits  The size of data passed. Valid options are:\n                 <ul><li>128 bits</li>\n                 <li>192 bits</li>\n                 <li>256 bits</li></ul>\n\n \\return         \\c 0 on success.\n \\return         #MBEDTLS_ERR_AES_INVALID_KEY_LENGTH on failure."]
    pub fn mbedtls_aes_setkey_dec(
        ctx: *mut mbedtls_aes_context,
        key: *const crate::c_types::c_uchar,
        keybits: crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function prepares an XTS context for encryption and\n                 sets the encryption key.\n\n \\param ctx      The AES XTS context to which the key should be bound.\n                 It must be initialized.\n \\param key      The encryption key. This is comprised of the XTS key1\n                 concatenated with the XTS key2.\n                 This must be a readable buffer of size \\p keybits bits.\n \\param keybits  The size of \\p key passed in bits. Valid options are:\n                 <ul><li>256 bits (each of key1 and key2 is a 128-bit key)</li>\n                 <li>512 bits (each of key1 and key2 is a 256-bit key)</li></ul>\n\n \\return         \\c 0 on success.\n \\return         #MBEDTLS_ERR_AES_INVALID_KEY_LENGTH on failure."]
    pub fn mbedtls_aes_xts_setkey_enc(
        ctx: *mut mbedtls_aes_xts_context,
        key: *const crate::c_types::c_uchar,
        keybits: crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function prepares an XTS context for decryption and\n                 sets the decryption key.\n\n \\param ctx      The AES XTS context to which the key should be bound.\n                 It must be initialized.\n \\param key      The decryption key. This is comprised of the XTS key1\n                 concatenated with the XTS key2.\n                 This must be a readable buffer of size \\p keybits bits.\n \\param keybits  The size of \\p key passed in bits. Valid options are:\n                 <ul><li>256 bits (each of key1 and key2 is a 128-bit key)</li>\n                 <li>512 bits (each of key1 and key2 is a 256-bit key)</li></ul>\n\n \\return         \\c 0 on success.\n \\return         #MBEDTLS_ERR_AES_INVALID_KEY_LENGTH on failure."]
    pub fn mbedtls_aes_xts_setkey_dec(
        ctx: *mut mbedtls_aes_xts_context,
        key: *const crate::c_types::c_uchar,
        keybits: crate::c_types::c_uint,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          This function performs an AES single-block encryption or\n                 decryption operation.\n\n                 It performs the operation defined in the \\p mode parameter\n                 (encrypt or decrypt), on the input data buffer defined in\n                 the \\p input parameter.\n\n                 mbedtls_aes_init(), and either mbedtls_aes_setkey_enc() or\n                 mbedtls_aes_setkey_dec() must be called before the first\n                 call to this API with the same context.\n\n \\param ctx      The AES context to use for encryption or decryption.\n                 It must be initialized and bound to a key.\n \\param mode     The AES operation: #MBEDTLS_AES_ENCRYPT or\n                 #MBEDTLS_AES_DECRYPT.\n \\param input    The buffer holding the input data.\n                 It must be readable and at least \\c 16 Bytes long.\n \\param output   The buffer where the output data will be written.\n                 It must be writeable and at least \\c 16 Bytes long.\n\n \\return         \\c 0 on success."]
    pub fn mbedtls_aes_crypt_ecb(
        ctx: *mut mbedtls_aes_context,
        mode: crate::c_types::c_int,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief  This function performs an AES-CBC encryption or decryption operation\n         on full blocks.\n\n         It performs the operation defined in the \\p mode\n         parameter (encrypt/decrypt), on the input data buffer defined in\n         the \\p input parameter.\n\n         It can be called as many times as needed, until all the input\n         data is processed. mbedtls_aes_init(), and either\n         mbedtls_aes_setkey_enc() or mbedtls_aes_setkey_dec() must be called\n         before the first call to this API with the same context.\n\n \\note   This function operates on full blocks, that is, the input size\n         must be a multiple of the AES block size of \\c 16 Bytes.\n\n \\note   Upon exit, the content of the IV is updated so that you can\n         call the same function again on the next\n         block(s) of data and get the same result as if it was\n         encrypted in one call. This allows a \"streaming\" usage.\n         If you need to retain the contents of the IV, you should\n         either save it manually or use the cipher module instead.\n\n\n \\param ctx      The AES context to use for encryption or decryption.\n                 It must be initialized and bound to a key.\n \\param mode     The AES operation: #MBEDTLS_AES_ENCRYPT or\n                 #MBEDTLS_AES_DECRYPT.\n \\param length   The length of the input data in Bytes. This must be a\n                 multiple of the block size (\\c 16 Bytes).\n \\param iv       Initialization vector (updated after use).\n                 It must be a readable and writeable buffer of \\c 16 Bytes.\n \\param input    The buffer holding the input data.\n                 It must be readable and of size \\p length Bytes.\n \\param output   The buffer holding the output data.\n                 It must be writeable and of size \\p length Bytes.\n\n \\return         \\c 0 on success.\n \\return         #MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH\n                 on failure."]
    pub fn mbedtls_aes_crypt_cbc(
        ctx: *mut mbedtls_aes_context,
        mode: crate::c_types::c_int,
        length: usize,
        iv: *mut crate::c_types::c_uchar,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief      This function performs an AES-XTS encryption or decryption\n             operation for an entire XTS data unit.\n\n             AES-XTS encrypts or decrypts blocks based on their location as\n             defined by a data unit number. The data unit number must be\n             provided by \\p data_unit.\n\n             NIST SP 800-38E limits the maximum size of a data unit to 2^20\n             AES blocks. If the data unit is larger than this, this function\n             returns #MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH.\n\n \\param ctx          The AES XTS context to use for AES XTS operations.\n                     It must be initialized and bound to a key.\n \\param mode         The AES operation: #MBEDTLS_AES_ENCRYPT or\n                     #MBEDTLS_AES_DECRYPT.\n \\param length       The length of a data unit in Bytes. This can be any\n                     length between 16 bytes and 2^24 bytes inclusive\n                     (between 1 and 2^20 block cipher blocks).\n \\param data_unit    The address of the data unit encoded as an array of 16\n                     bytes in little-endian format. For disk encryption, this\n                     is typically the index of the block device sector that\n                     contains the data.\n \\param input        The buffer holding the input data (which is an entire\n                     data unit). This function reads \\p length Bytes from \\p\n                     input.\n \\param output       The buffer holding the output data (which is an entire\n                     data unit). This function writes \\p length Bytes to \\p\n                     output.\n\n \\return             \\c 0 on success.\n \\return             #MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH if \\p length is\n                     smaller than an AES block in size (16 Bytes) or if \\p\n                     length is larger than 2^20 blocks (16 MiB)."]
    pub fn mbedtls_aes_crypt_xts(
        ctx: *mut mbedtls_aes_xts_context,
        mode: crate::c_types::c_int,
        length: usize,
        data_unit: *const crate::c_types::c_uchar,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief This function performs an AES-CFB128 encryption or decryption\n        operation.\n\n        It performs the operation defined in the \\p mode\n        parameter (encrypt or decrypt), on the input data buffer\n        defined in the \\p input parameter.\n\n        For CFB, you must set up the context with mbedtls_aes_setkey_enc(),\n        regardless of whether you are performing an encryption or decryption\n        operation, that is, regardless of the \\p mode parameter. This is\n        because CFB mode uses the same key schedule for encryption and\n        decryption.\n\n \\note  Upon exit, the content of the IV is updated so that you can\n        call the same function again on the next\n        block(s) of data and get the same result as if it was\n        encrypted in one call. This allows a \"streaming\" usage.\n        If you need to retain the contents of the\n        IV, you must either save it manually or use the cipher\n        module instead.\n\n\n \\param ctx      The AES context to use for encryption or decryption.\n                 It must be initialized and bound to a key.\n \\param mode     The AES operation: #MBEDTLS_AES_ENCRYPT or\n                 #MBEDTLS_AES_DECRYPT.\n \\param length   The length of the input data in Bytes.\n \\param iv_off   The offset in IV (updated after use).\n                 It must point to a valid \\c size_t.\n \\param iv       The initialization vector (updated after use).\n                 It must be a readable and writeable buffer of \\c 16 Bytes.\n \\param input    The buffer holding the input data.\n                 It must be readable and of size \\p length Bytes.\n \\param output   The buffer holding the output data.\n                 It must be writeable and of size \\p length Bytes.\n\n \\return         \\c 0 on success."]
    pub fn mbedtls_aes_crypt_cfb128(
        ctx: *mut mbedtls_aes_context,
        mode: crate::c_types::c_int,
        length: usize,
        iv_off: *mut usize,
        iv: *mut crate::c_types::c_uchar,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief This function performs an AES-CFB8 encryption or decryption\n        operation.\n\n        It performs the operation defined in the \\p mode\n        parameter (encrypt/decrypt), on the input data buffer defined\n        in the \\p input parameter.\n\n        Due to the nature of CFB, you must use the same key schedule for\n        both encryption and decryption operations. Therefore, you must\n        use the context initialized with mbedtls_aes_setkey_enc() for\n        both #MBEDTLS_AES_ENCRYPT and #MBEDTLS_AES_DECRYPT.\n\n \\note  Upon exit, the content of the IV is updated so that you can\n        call the same function again on the next\n        block(s) of data and get the same result as if it was\n        encrypted in one call. This allows a \"streaming\" usage.\n        If you need to retain the contents of the\n        IV, you should either save it manually or use the cipher\n        module instead.\n\n\n \\param ctx      The AES context to use for encryption or decryption.\n                 It must be initialized and bound to a key.\n \\param mode     The AES operation: #MBEDTLS_AES_ENCRYPT or\n                 #MBEDTLS_AES_DECRYPT\n \\param length   The length of the input data.\n \\param iv       The initialization vector (updated after use).\n                 It must be a readable and writeable buffer of \\c 16 Bytes.\n \\param input    The buffer holding the input data.\n                 It must be readable and of size \\p length Bytes.\n \\param output   The buffer holding the output data.\n                 It must be writeable and of size \\p length Bytes.\n\n \\return         \\c 0 on success."]
    pub fn mbedtls_aes_crypt_cfb8(
        ctx: *mut mbedtls_aes_context,
        mode: crate::c_types::c_int,
        length: usize,
        iv: *mut crate::c_types::c_uchar,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief       This function performs an AES-OFB (Output Feedback Mode)\n              encryption or decryption operation.\n\n              For OFB, you must set up the context with\n              mbedtls_aes_setkey_enc(), regardless of whether you are\n              performing an encryption or decryption operation. This is\n              because OFB mode uses the same key schedule for encryption and\n              decryption.\n\n              The OFB operation is identical for encryption or decryption,\n              therefore no operation mode needs to be specified.\n\n \\note        Upon exit, the content of iv, the Initialisation Vector, is\n              updated so that you can call the same function again on the next\n              block(s) of data and get the same result as if it was encrypted\n              in one call. This allows a \"streaming\" usage, by initialising\n              iv_off to 0 before the first call, and preserving its value\n              between calls.\n\n              For non-streaming use, the iv should be initialised on each call\n              to a unique value, and iv_off set to 0 on each call.\n\n              If you need to retain the contents of the initialisation vector,\n              you must either save it manually or use the cipher module\n              instead.\n\n \\warning     For the OFB mode, the initialisation vector must be unique\n              every encryption operation. Reuse of an initialisation vector\n              will compromise security.\n\n \\param ctx      The AES context to use for encryption or decryption.\n                 It must be initialized and bound to a key.\n \\param length   The length of the input data.\n \\param iv_off   The offset in IV (updated after use).\n                 It must point to a valid \\c size_t.\n \\param iv       The initialization vector (updated after use).\n                 It must be a readable and writeable buffer of \\c 16 Bytes.\n \\param input    The buffer holding the input data.\n                 It must be readable and of size \\p length Bytes.\n \\param output   The buffer holding the output data.\n                 It must be writeable and of size \\p length Bytes.\n\n \\return         \\c 0 on success."]
    pub fn mbedtls_aes_crypt_ofb(
        ctx: *mut mbedtls_aes_context,
        length: usize,
        iv_off: *mut usize,
        iv: *mut crate::c_types::c_uchar,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief      This function performs an AES-CTR encryption or decryption\n             operation.\n\n             Due to the nature of CTR, you must use the same key schedule\n             for both encryption and decryption operations. Therefore, you\n             must use the context initialized with mbedtls_aes_setkey_enc()\n             for both #MBEDTLS_AES_ENCRYPT and #MBEDTLS_AES_DECRYPT.\n\n \\warning    You must never reuse a nonce value with the same key. Doing so\n             would void the encryption for the two messages encrypted with\n             the same nonce and key.\n\n             There are two common strategies for managing nonces with CTR:\n\n             1. You can handle everything as a single message processed over\n             successive calls to this function. In that case, you want to\n             set \\p nonce_counter and \\p nc_off to 0 for the first call, and\n             then preserve the values of \\p nonce_counter, \\p nc_off and \\p\n             stream_block across calls to this function as they will be\n             updated by this function.\n\n             With this strategy, you must not encrypt more than 2**128\n             blocks of data with the same key.\n\n             2. You can encrypt separate messages by dividing the \\p\n             nonce_counter buffer in two areas: the first one used for a\n             per-message nonce, handled by yourself, and the second one\n             updated by this function internally.\n\n             For example, you might reserve the first 12 bytes for the\n             per-message nonce, and the last 4 bytes for internal use. In that\n             case, before calling this function on a new message you need to\n             set the first 12 bytes of \\p nonce_counter to your chosen nonce\n             value, the last 4 to 0, and \\p nc_off to 0 (which will cause \\p\n             stream_block to be ignored). That way, you can encrypt at most\n             2**96 messages of up to 2**32 blocks each with the same key.\n\n             The per-message nonce (or information sufficient to reconstruct\n             it) needs to be communicated with the ciphertext and must be unique.\n             The recommended way to ensure uniqueness is to use a message\n             counter. An alternative is to generate random nonces, but this\n             limits the number of messages that can be securely encrypted:\n             for example, with 96-bit random nonces, you should not encrypt\n             more than 2**32 messages with the same key.\n\n             Note that for both strategies, sizes are measured in blocks and\n             that an AES block is 16 bytes.\n\n \\warning    Upon return, \\p stream_block contains sensitive data. Its\n             content must not be written to insecure storage and should be\n             securely discarded as soon as it's no longer needed.\n\n \\param ctx              The AES context to use for encryption or decryption.\n                         It must be initialized and bound to a key.\n \\param length           The length of the input data.\n \\param nc_off           The offset in the current \\p stream_block, for\n                         resuming within the current cipher stream. The\n                         offset pointer should be 0 at the start of a stream.\n                         It must point to a valid \\c size_t.\n \\param nonce_counter    The 128-bit nonce and counter.\n                         It must be a readable-writeable buffer of \\c 16 Bytes.\n \\param stream_block     The saved stream block for resuming. This is\n                         overwritten by the function.\n                         It must be a readable-writeable buffer of \\c 16 Bytes.\n \\param input            The buffer holding the input data.\n                         It must be readable and of size \\p length Bytes.\n \\param output           The buffer holding the output data.\n                         It must be writeable and of size \\p length Bytes.\n\n \\return                 \\c 0 on success."]
    pub fn mbedtls_aes_crypt_ctr(
        ctx: *mut mbedtls_aes_context,
        length: usize,
        nc_off: *mut usize,
        nonce_counter: *mut crate::c_types::c_uchar,
        stream_block: *mut crate::c_types::c_uchar,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Internal AES block encryption function. This is only\n                  exposed to allow overriding it using\n                  \\c MBEDTLS_AES_ENCRYPT_ALT.\n\n \\param ctx       The AES context to use for encryption.\n \\param input     The plaintext block.\n \\param output    The output (ciphertext) block.\n\n \\return          \\c 0 on success."]
    pub fn mbedtls_internal_aes_encrypt(
        ctx: *mut mbedtls_aes_context,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief           Internal AES block decryption function. This is only\n                  exposed to allow overriding it using see\n                  \\c MBEDTLS_AES_DECRYPT_ALT.\n\n \\param ctx       The AES context to use for decryption.\n \\param input     The ciphertext block.\n \\param output    The output (plaintext) block.\n\n \\return          \\c 0 on success."]
    pub fn mbedtls_internal_aes_decrypt(
        ctx: *mut mbedtls_aes_context,
        input: *const crate::c_types::c_uchar,
        output: *mut crate::c_types::c_uchar,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief          Checkup routine.\n\n \\return         \\c 0 on success.\n \\return         \\c 1 on failure."]
    pub fn mbedtls_aes_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
#[doc = " \\brief          The CTR_DRBG context structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_ctr_drbg_context {
    pub private_counter: [crate::c_types::c_uchar; 16usize],
    pub private_reseed_counter: crate::c_types::c_int,
    pub private_prediction_resistance: crate::c_types::c_int,
    pub private_entropy_len: usize,
    pub private_reseed_interval: crate::c_types::c_int,
    pub private_aes_ctx: mbedtls_aes_context,
    pub private_f_entropy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut crate::c_types::c_void,
            arg2: *mut crate::c_types::c_uchar,
            arg3: usize,
        ) -> crate::c_types::c_int,
    >,
    pub private_p_entropy: *mut crate::c_types::c_void,
}
extern "C" {
    #[doc = " \\brief               This function initializes the CTR_DRBG context,\n                      and prepares it for mbedtls_ctr_drbg_seed()\n                      or mbedtls_ctr_drbg_free().\n\n \\note                The reseed interval is\n                      #MBEDTLS_CTR_DRBG_RESEED_INTERVAL by default.\n                      You can override it by calling\n                      mbedtls_ctr_drbg_set_reseed_interval().\n\n \\param ctx           The CTR_DRBG context to initialize."]
    pub fn mbedtls_ctr_drbg_init(ctx: *mut mbedtls_ctr_drbg_context);
}
extern "C" {
    #[doc = " - The \\p custom string.\n\n \\note                To achieve the nominal security strength permitted\n                      by CTR_DRBG, the entropy length must be:\n                      - at least 16 bytes for a 128-bit strength\n                      (maximum achievable strength when using AES-128);\n                      - at least 32 bytes for a 256-bit strength\n                      (maximum achievable strength when using AES-256).\n\n                      In addition, if you do not pass a nonce in \\p custom,\n                      the sum of the entropy length\n                      and the entropy nonce length must be:\n                      - at least 24 bytes for a 128-bit strength\n                      (maximum achievable strength when using AES-128);\n                      - at least 48 bytes for a 256-bit strength\n                      (maximum achievable strength when using AES-256).\n\n \\param ctx           The CTR_DRBG context to seed.\n                      It must have been initialized with\n                      mbedtls_ctr_drbg_init().\n                      After a successful call to mbedtls_ctr_drbg_seed(),\n                      you may not call mbedtls_ctr_drbg_seed() again on\n                      the same context unless you call\n                      mbedtls_ctr_drbg_free() and mbedtls_ctr_drbg_init()\n                      again first.\n                      After a failed call to mbedtls_ctr_drbg_seed(),\n                      you must call mbedtls_ctr_drbg_free().\n \\param f_entropy     The entropy callback, taking as arguments the\n                      \\p p_entropy context, the buffer to fill, and the\n                      length of the buffer.\n                      \\p f_entropy is always called with a buffer size\n                      less than or equal to the entropy length.\n \\param p_entropy     The entropy context to pass to \\p f_entropy.\n \\param custom        The personalization string.\n                      This can be \\c NULL, in which case the personalization\n                      string is empty regardless of the value of \\p len.\n \\param len           The length of the personalization string.\n                      This must be at most\n                      #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT\n                      - #MBEDTLS_CTR_DRBG_ENTROPY_LEN.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED on failure."]
    pub fn mbedtls_ctr_drbg_seed(
        ctx: *mut mbedtls_ctr_drbg_context,
        f_entropy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut crate::c_types::c_void,
                arg2: *mut crate::c_types::c_uchar,
                arg3: usize,
            ) -> crate::c_types::c_int,
        >,
        p_entropy: *mut crate::c_types::c_void,
        custom: *const crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function resets CTR_DRBG context to the state immediately\n                      after initial call of mbedtls_ctr_drbg_init().\n\n \\param ctx           The CTR_DRBG context to clear."]
    pub fn mbedtls_ctr_drbg_free(ctx: *mut mbedtls_ctr_drbg_context);
}
extern "C" {
    #[doc = " \\brief               This function turns prediction resistance on or off.\n                      The default value is off.\n\n \\note                If enabled, entropy is gathered at the beginning of\n                      every call to mbedtls_ctr_drbg_random_with_add()\n                      or mbedtls_ctr_drbg_random().\n                      Only use this if your entropy source has sufficient\n                      throughput.\n\n \\param ctx           The CTR_DRBG context.\n \\param resistance    #MBEDTLS_CTR_DRBG_PR_ON or #MBEDTLS_CTR_DRBG_PR_OFF."]
    pub fn mbedtls_ctr_drbg_set_prediction_resistance(
        ctx: *mut mbedtls_ctr_drbg_context,
        resistance: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief               This function sets the amount of entropy grabbed on each\n                      seed or reseed.\n\n The default value is #MBEDTLS_CTR_DRBG_ENTROPY_LEN.\n\n \\note                The security strength of CTR_DRBG is bounded by the\n                      entropy length. Thus:\n                      - When using AES-256\n                        (\\c MBEDTLS_CTR_DRBG_USE_128_BIT_KEY is disabled,\n                        which is the default),\n                        \\p len must be at least 32 (in bytes)\n                        to achieve a 256-bit strength.\n                      - When using AES-128\n                        (\\c MBEDTLS_CTR_DRBG_USE_128_BIT_KEY is enabled)\n                        \\p len must be at least 16 (in bytes)\n                        to achieve a 128-bit strength.\n\n \\param ctx           The CTR_DRBG context.\n \\param len           The amount of entropy to grab, in bytes.\n                      This must be at most #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT\n                      and at most the maximum length accepted by the\n                      entropy function that is set in the context."]
    pub fn mbedtls_ctr_drbg_set_entropy_len(ctx: *mut mbedtls_ctr_drbg_context, len: usize);
}
extern "C" {
    #[doc = " \\brief               This function sets the amount of entropy grabbed\n                      as a nonce for the initial seeding.\n\n Call this function before calling mbedtls_ctr_drbg_seed() to read\n a nonce from the entropy source during the initial seeding.\n\n \\param ctx           The CTR_DRBG context.\n \\param len           The amount of entropy to grab for the nonce, in bytes.\n                      This must be at most #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT\n                      and at most the maximum length accepted by the\n                      entropy function that is set in the context.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG if \\p len is\n                      more than #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT.\n \\return              #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED\n                      if the initial seeding has already taken place."]
    pub fn mbedtls_ctr_drbg_set_nonce_len(
        ctx: *mut mbedtls_ctr_drbg_context,
        len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               This function sets the reseed interval.\n\n The reseed interval is the number of calls to mbedtls_ctr_drbg_random()\n or mbedtls_ctr_drbg_random_with_add() after which the entropy function\n is called again.\n\n The default value is #MBEDTLS_CTR_DRBG_RESEED_INTERVAL.\n\n \\param ctx           The CTR_DRBG context.\n \\param interval      The reseed interval."]
    pub fn mbedtls_ctr_drbg_set_reseed_interval(
        ctx: *mut mbedtls_ctr_drbg_context,
        interval: crate::c_types::c_int,
    );
}
extern "C" {
    #[doc = " \\brief               This function reseeds the CTR_DRBG context, that is\n                      extracts data from the entropy source.\n\n \\note                This function is not thread-safe. It is not safe\n                      to call this function if another thread might be\n                      concurrently obtaining random numbers from the same\n                      context or updating or reseeding the same context.\n\n \\param ctx           The CTR_DRBG context.\n \\param additional    Additional data to add to the state. Can be \\c NULL.\n \\param len           The length of the additional data.\n                      This must be less than\n                      #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT - \\c entropy_len\n                      where \\c entropy_len is the entropy length\n                      configured for the context.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED on failure."]
    pub fn mbedtls_ctr_drbg_reseed(
        ctx: *mut mbedtls_ctr_drbg_context,
        additional: *const crate::c_types::c_uchar,
        len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief              This function updates the state of the CTR_DRBG context.\n\n \\note                This function is not thread-safe. It is not safe\n                      to call this function if another thread might be\n                      concurrently obtaining random numbers from the same\n                      context or updating or reseeding the same context.\n\n \\param ctx          The CTR_DRBG context.\n \\param additional   The data to update the state with. This must not be\n                     \\c NULL unless \\p add_len is \\c 0.\n \\param add_len      Length of \\p additional in bytes. This must be at\n                     most #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT.\n\n \\return             \\c 0 on success.\n \\return             #MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG if\n                     \\p add_len is more than\n                     #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT.\n \\return             An error from the underlying AES cipher on failure."]
    pub fn mbedtls_ctr_drbg_update(
        ctx: *mut mbedtls_ctr_drbg_context,
        additional: *const crate::c_types::c_uchar,
        add_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief   This function updates a CTR_DRBG instance with additional\n          data and uses it to generate random data.\n\n This function automatically reseeds if the reseed counter is exceeded\n or prediction resistance is enabled.\n\n \\note                This function is not thread-safe. It is not safe\n                      to call this function if another thread might be\n                      concurrently obtaining random numbers from the same\n                      context or updating or reseeding the same context.\n\n \\param p_rng         The CTR_DRBG context. This must be a pointer to a\n                      #mbedtls_ctr_drbg_context structure.\n \\param output        The buffer to fill.\n \\param output_len    The length of the buffer in bytes.\n \\param additional    Additional data to update. Can be \\c NULL, in which\n                      case the additional data is empty regardless of\n                      the value of \\p add_len.\n \\param add_len       The length of the additional data\n                      if \\p additional is not \\c NULL.\n                      This must be less than #MBEDTLS_CTR_DRBG_MAX_INPUT\n                      and less than\n                      #MBEDTLS_CTR_DRBG_MAX_SEED_INPUT - \\c entropy_len\n                      where \\c entropy_len is the entropy length\n                      configured for the context.\n\n \\return    \\c 0 on success.\n \\return    #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED or\n            #MBEDTLS_ERR_CTR_DRBG_REQUEST_TOO_BIG on failure."]
    pub fn mbedtls_ctr_drbg_random_with_add(
        p_rng: *mut crate::c_types::c_void,
        output: *mut crate::c_types::c_uchar,
        output_len: usize,
        additional: *const crate::c_types::c_uchar,
        add_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\param p_rng         The CTR_DRBG context. This must be a pointer to a\n                      #mbedtls_ctr_drbg_context structure.\n \\param output        The buffer to fill.\n \\param output_len    The length of the buffer in bytes.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED or\n                      #MBEDTLS_ERR_CTR_DRBG_REQUEST_TOO_BIG on failure."]
    pub fn mbedtls_ctr_drbg_random(
        p_rng: *mut crate::c_types::c_void,
        output: *mut crate::c_types::c_uchar,
        output_len: usize,
    ) -> crate::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief               The CTR_DRBG checkup routine.\n\n \\return              \\c 0 on success.\n \\return              \\c 1 on failure."]
    pub fn mbedtls_ctr_drbg_self_test(verbose: crate::c_types::c_int) -> crate::c_types::c_int;
}
